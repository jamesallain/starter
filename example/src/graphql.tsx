import gql from 'graphql-tag';
import * as ApolloReactCommon from '@apollo/react-common';
import * as ApolloReactHooks from '@apollo/react-hooks';
export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string,
  String: string,
  Boolean: boolean,
  Int: number,
  Float: number,
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any,
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any,
  /** 
 * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
 */
  Datetime: any,
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: any,
  /** 
 * Base StructureDefinition for id type: Any combination of letters, numerals, '-'
   * and '.', with a length limit of 64 characters.  (This might be an integer, an
   * unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
 */
  FHIRId: any,
  /** Base StructureDefinition for base64Binary Type: A stream of bytes */
  FHIRBase64Binary: any,
  /** Base StructureDefinition for canonical type: A URI that is a reference to a canonical URL on a FHIR resource */
  FHIRCanonical: any,
  /** 
 * Base StructureDefinition for code type: A string which has at least one
   * character and no leading or trailing whitespace and where there is no whitespace
   * other than single spaces in the contents
 */
  FHIRCode: any,
  /** 
 * Base StructureDefinition for date Type: A date or partial date (e.g. just year
   * or year + month). There is no time zone. The format is a union of the schema
   * types gYear, gYearMonth and date.  Dates SHALL be valid dates.
 */
  FHIRDate: any,
  /** 
 * Base StructureDefinition for dateTime Type: A date, date-time or partial date
   * (e.g. just year or year + month).  If hours and minutes are specified, a time
   * zone SHALL be populated. The format is a union of the schema types gYear,
   * gYearMonth, date and dateTime. Seconds must be provided due to schema type
   * constraints but may be zero-filled and may be ignored.                 Dates
   * SHALL be valid dates.
 */
  FHIRDateTime: any,
  /** Base StructureDefinition for instant Type: An instant in time - known at least to the second */
  FHIRInstant: any,
  /** Base StructureDefinition for oid type: An OID represented as a URI */
  FHIROid: any,
  /** Base StructureDefinition for positiveInt type: An integer with a value that is positive (e.g. >0) */
  FHIRPositiveInt: any,
  /** Base StructureDefinition for time Type: A time during the day, with no date specified */
  FHIRTime: any,
  /** Base StructureDefinition for unsignedInt type: An integer with a value that is not negative (e.g. >= 0) */
  FHIRUnsignedInt: any,
  /** Base StructureDefinition for uri Type: String of characters used to identify a name or a resource */
  FHIRUri: any,
  /** Base StructureDefinition for url type: A URI that is a literal reference */
  FHIRUrl: any,
  /** Base StructureDefinition for uuid type: A UUID, represented as a URI */
  FHIRUuid: any,
  /** Base StructureDefinition for xhtml Type */
  FHIRXhtml: any,
};

/** All input for the `acceptProfileInvite` mutation. */
export type AcceptProfileInviteInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  code?: Maybe<Scalars['String']>,
};

/** The output of our `acceptProfileInvite` mutation. */
export type AcceptProfileInvitePayload = {
   __typename?: 'AcceptProfileInvitePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profile?: Maybe<Profile>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>,
};


/** The output of our `acceptProfileInvite` mutation. */
export type AcceptProfileInvitePayloadprofileEdgeArgs = {
  orderBy?: Maybe<Array<ProfilesOrderBy>>
};

/** All input for the `applyMenuToProfile` mutation. */
export type ApplyMenuToProfileInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menuId: Scalars['Int'],
  profileId: Scalars['Int'],
};

/** The output of our `applyMenuToProfile` mutation. */
export type ApplyMenuToProfilePayload = {
   __typename?: 'ApplyMenuToProfilePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profile?: Maybe<Profile>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>,
};


/** The output of our `applyMenuToProfile` mutation. */
export type ApplyMenuToProfilePayloadprofileEdgeArgs = {
  orderBy?: Maybe<Array<ProfilesOrderBy>>
};

/** All input for the `applyMenuToProfiles` mutation. */
export type ApplyMenuToProfilesInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menuId: Scalars['Int'],
  profileIds: Array<Maybe<Scalars['Int']>>,
};

/** The output of our `applyMenuToProfiles` mutation. */
export type ApplyMenuToProfilesPayload = {
   __typename?: 'ApplyMenuToProfilesPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profiles?: Maybe<Array<Profile>>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>,
};

export type Consumable = Node & {
   __typename?: 'Consumable',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  userId?: Maybe<Scalars['Int']>,
  source: Scalars['String'],
  identifier: Scalars['String'],
  upc?: Maybe<Scalars['String']>,
  name: Scalars['String'],
  foodGroup: Scalars['Int'],
  shortDescription?: Maybe<Scalars['String']>,
  scientificName?: Maybe<Scalars['String']>,
  commercialName?: Maybe<Scalars['String']>,
  manufacturer?: Maybe<Scalars['String']>,
  nitrogenToProteinConversionFactor?: Maybe<Scalars['Float']>,
  carbohydrateFactor?: Maybe<Scalars['Float']>,
  fatFactor?: Maybe<Scalars['Float']>,
  proteinFactor?: Maybe<Scalars['Float']>,
  refusePercent?: Maybe<Scalars['Float']>,
  refuseDescription?: Maybe<Scalars['String']>,
  databaseSource?: Maybe<Scalars['String']>,
  reportingUnit: Scalars['String'],
  sourceMeta: Scalars['JSON'],
  verifiedByUserId?: Maybe<Scalars['Int']>,
  verified: Scalars['Boolean'],
  consumableSourceId: Scalars['Int'],
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** Reads and enables pagination through a set of `ConsumableNutrient`. */
  consumableNutrientsByConsumableId: ConsumableNutrientsConnection,
  /** Reads and enables pagination through a set of `ConsumableMeasure`. */
  consumableMeasuresByConsumableId: ConsumableMeasuresConnection,
  /** Reads and enables pagination through a set of `ConsumableIngredient`. */
  consumableIngredientsByConsumableId: ConsumableIngredientsConnection,
  /** Reads and enables pagination through a set of `MealConsumable`. */
  mealConsumablesByConsumableId: MealConsumablesConnection,
  /** Reads and enables pagination through a set of `ConsumableLangual`. */
  consumableLangualsByConsumableId: ConsumableLangualsConnection,
};


export type ConsumableconsumableNutrientsByConsumableIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableNutrientsOrderBy>>,
  condition?: Maybe<ConsumableNutrientCondition>,
  filter?: Maybe<ConsumableNutrientFilter>
};


export type ConsumableconsumableMeasuresByConsumableIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableMeasuresOrderBy>>,
  condition?: Maybe<ConsumableMeasureCondition>,
  filter?: Maybe<ConsumableMeasureFilter>
};


export type ConsumableconsumableIngredientsByConsumableIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableIngredientsOrderBy>>,
  condition?: Maybe<ConsumableIngredientCondition>,
  filter?: Maybe<ConsumableIngredientFilter>
};


export type ConsumablemealConsumablesByConsumableIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>,
  condition?: Maybe<MealConsumableCondition>,
  filter?: Maybe<MealConsumableFilter>
};


export type ConsumableconsumableLangualsByConsumableIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableLangualsOrderBy>>,
  condition?: Maybe<ConsumableLangualCondition>,
  filter?: Maybe<ConsumableLangualFilter>
};

/** A connection to a list of `ConsumableCategory` values. */
export type ConsumableCategoriesConnection = {
   __typename?: 'ConsumableCategoriesConnection',
  /** A list of `ConsumableCategory` objects. */
  nodes: Array<ConsumableCategory>,
  /** A list of edges which contains the `ConsumableCategory` and cursor to aid in pagination. */
  edges: Array<ConsumableCategoriesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableCategory` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableCategory` edge in the connection. */
export type ConsumableCategoriesEdge = {
   __typename?: 'ConsumableCategoriesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableCategory` at the end of the edge. */
  node: ConsumableCategory,
};

/** Methods to use when ordering `ConsumableCategory`. */
export enum ConsumableCategoriesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  CODE_ASC = 'CODE_ASC',
  CODE_DESC = 'CODE_DESC',
  DESCRIPTION_ASC = 'DESCRIPTION_ASC',
  DESCRIPTION_DESC = 'DESCRIPTION_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ConsumableCategory = Node & {
   __typename?: 'ConsumableCategory',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  code: Scalars['Int'],
  description: Scalars['String'],
};

/** 
 * A condition to be used against `ConsumableCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>,
};

/** A filter to be used against `ConsumableCategory` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `code` field. */
  code?: Maybe<IntFilter>,
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableCategoryFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableCategoryFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableCategoryFilter>,
};

/** 
 * A condition to be used against `Consumable` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ConsumableCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `foodGroup` field. */
  foodGroup?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `scientificName` field. */
  scientificName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `commercialName` field. */
  commercialName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `manufacturer` field. */
  manufacturer?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `nitrogenToProteinConversionFactor` field. */
  nitrogenToProteinConversionFactor?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `carbohydrateFactor` field. */
  carbohydrateFactor?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `fatFactor` field. */
  fatFactor?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `proteinFactor` field. */
  proteinFactor?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `refusePercent` field. */
  refusePercent?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `refuseDescription` field. */
  refuseDescription?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `databaseSource` field. */
  databaseSource?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `reportingUnit` field. */
  reportingUnit?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<Scalars['JSON']>,
  /** Checks for equality with the object’s `verifiedByUserId` field. */
  verifiedByUserId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `verified` field. */
  verified?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `consumableSourceId` field. */
  consumableSourceId?: Maybe<Scalars['Int']>,
};

/** A filter to be used against `Consumable` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>,
  /** Filter by the object’s `identifier` field. */
  identifier?: Maybe<StringFilter>,
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `foodGroup` field. */
  foodGroup?: Maybe<IntFilter>,
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: Maybe<StringFilter>,
  /** Filter by the object’s `scientificName` field. */
  scientificName?: Maybe<StringFilter>,
  /** Filter by the object’s `commercialName` field. */
  commercialName?: Maybe<StringFilter>,
  /** Filter by the object’s `manufacturer` field. */
  manufacturer?: Maybe<StringFilter>,
  /** Filter by the object’s `nitrogenToProteinConversionFactor` field. */
  nitrogenToProteinConversionFactor?: Maybe<FloatFilter>,
  /** Filter by the object’s `carbohydrateFactor` field. */
  carbohydrateFactor?: Maybe<FloatFilter>,
  /** Filter by the object’s `fatFactor` field. */
  fatFactor?: Maybe<FloatFilter>,
  /** Filter by the object’s `proteinFactor` field. */
  proteinFactor?: Maybe<FloatFilter>,
  /** Filter by the object’s `refusePercent` field. */
  refusePercent?: Maybe<FloatFilter>,
  /** Filter by the object’s `refuseDescription` field. */
  refuseDescription?: Maybe<StringFilter>,
  /** Filter by the object’s `databaseSource` field. */
  databaseSource?: Maybe<StringFilter>,
  /** Filter by the object’s `reportingUnit` field. */
  reportingUnit?: Maybe<StringFilter>,
  /** Filter by the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<JSONFilter>,
  /** Filter by the object’s `verifiedByUserId` field. */
  verifiedByUserId?: Maybe<IntFilter>,
  /** Filter by the object’s `verified` field. */
  verified?: Maybe<BooleanFilter>,
  /** Filter by the object’s `consumableSourceId` field. */
  consumableSourceId?: Maybe<IntFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableFilter>,
};

export type ConsumableGroup = Node & {
   __typename?: 'ConsumableGroup',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  source: Scalars['String'],
  identifier: Scalars['String'],
  name: Scalars['String'],
  /** Reads and enables pagination through a set of `Consumable`. */
  consumablesByFoodGroup: ConsumablesConnection,
};


export type ConsumableGroupconsumablesByFoodGroupArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumablesOrderBy>>,
  condition?: Maybe<ConsumableCondition>,
  filter?: Maybe<ConsumableFilter>
};

/** 
 * A condition to be used against `ConsumableGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
};

/** A filter to be used against `ConsumableGroup` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableGroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>,
  /** Filter by the object’s `identifier` field. */
  identifier?: Maybe<StringFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableGroupFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableGroupFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableGroupFilter>,
};

/** A connection to a list of `ConsumableGroup` values. */
export type ConsumableGroupsConnection = {
   __typename?: 'ConsumableGroupsConnection',
  /** A list of `ConsumableGroup` objects. */
  nodes: Array<ConsumableGroup>,
  /** A list of edges which contains the `ConsumableGroup` and cursor to aid in pagination. */
  edges: Array<ConsumableGroupsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableGroup` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableGroup` edge in the connection. */
export type ConsumableGroupsEdge = {
   __typename?: 'ConsumableGroupsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableGroup` at the end of the edge. */
  node: ConsumableGroup,
};

/** Methods to use when ordering `ConsumableGroup`. */
export enum ConsumableGroupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  SOURCE_ASC = 'SOURCE_ASC',
  SOURCE_DESC = 'SOURCE_DESC',
  IDENTIFIER_ASC = 'IDENTIFIER_ASC',
  IDENTIFIER_DESC = 'IDENTIFIER_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ConsumableIngredient = Node & {
   __typename?: 'ConsumableIngredient',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  consumableId?: Maybe<Scalars['Int']>,
  sequence: Scalars['Int'],
  name: Scalars['String'],
  updated?: Maybe<Scalars['String']>,
  /** Reads a single `Consumable` that is related to this `ConsumableIngredient`. */
  consumableByConsumableId?: Maybe<Consumable>,
};

/** 
 * A condition to be used against `ConsumableIngredient` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ConsumableIngredientCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `consumableId` field. */
  consumableId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `updated` field. */
  updated?: Maybe<Scalars['String']>,
};

/** A filter to be used against `ConsumableIngredient` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableIngredientFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `consumableId` field. */
  consumableId?: Maybe<IntFilter>,
  /** Filter by the object’s `sequence` field. */
  sequence?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `updated` field. */
  updated?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableIngredientFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableIngredientFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableIngredientFilter>,
};

/** A connection to a list of `ConsumableIngredient` values. */
export type ConsumableIngredientsConnection = {
   __typename?: 'ConsumableIngredientsConnection',
  /** A list of `ConsumableIngredient` objects. */
  nodes: Array<ConsumableIngredient>,
  /** A list of edges which contains the `ConsumableIngredient` and cursor to aid in pagination. */
  edges: Array<ConsumableIngredientsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableIngredient` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableIngredient` edge in the connection. */
export type ConsumableIngredientsEdge = {
   __typename?: 'ConsumableIngredientsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableIngredient` at the end of the edge. */
  node: ConsumableIngredient,
};

/** Methods to use when ordering `ConsumableIngredient`. */
export enum ConsumableIngredientsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  CONSUMABLE_ID_ASC = 'CONSUMABLE_ID_ASC',
  CONSUMABLE_ID_DESC = 'CONSUMABLE_ID_DESC',
  SEQUENCE_ASC = 'SEQUENCE_ASC',
  SEQUENCE_DESC = 'SEQUENCE_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  UPDATED_ASC = 'UPDATED_ASC',
  UPDATED_DESC = 'UPDATED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Consumable` */
export type ConsumableInput = {
  identifier: Scalars['String'],
  name: Scalars['String'],
  foodGroup: Scalars['Int'],
  shortDescription?: Maybe<Scalars['String']>,
  scientificName?: Maybe<Scalars['String']>,
  commercialName?: Maybe<Scalars['String']>,
  manufacturer?: Maybe<Scalars['String']>,
  nitrogenToProteinConversionFactor?: Maybe<Scalars['Float']>,
  carbohydrateFactor?: Maybe<Scalars['Float']>,
  fatFactor?: Maybe<Scalars['Float']>,
  proteinFactor?: Maybe<Scalars['Float']>,
  refusePercent?: Maybe<Scalars['Float']>,
  refuseDescription?: Maybe<Scalars['String']>,
  reportingUnit?: Maybe<Scalars['String']>,
  sourceMeta?: Maybe<Scalars['JSON']>,
};

export type ConsumableLangual = Node & {
   __typename?: 'ConsumableLangual',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  consumableId: Scalars['Int'],
  langualCode: Scalars['String'],
  /** Reads a single `Consumable` that is related to this `ConsumableLangual`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `Langual` that is related to this `ConsumableLangual`. */
  langualByLangualCode?: Maybe<Langual>,
};

/** 
 * A condition to be used against `ConsumableLangual` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableLangualCondition = {
  /** Checks for equality with the object’s `consumableId` field. */
  consumableId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `langualCode` field. */
  langualCode?: Maybe<Scalars['String']>,
};

/** A filter to be used against `ConsumableLangual` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableLangualFilter = {
  /** Filter by the object’s `consumableId` field. */
  consumableId?: Maybe<IntFilter>,
  /** Filter by the object’s `langualCode` field. */
  langualCode?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableLangualFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableLangualFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableLangualFilter>,
};

/** A connection to a list of `ConsumableLangual` values. */
export type ConsumableLangualsConnection = {
   __typename?: 'ConsumableLangualsConnection',
  /** A list of `ConsumableLangual` objects. */
  nodes: Array<ConsumableLangual>,
  /** A list of edges which contains the `ConsumableLangual` and cursor to aid in pagination. */
  edges: Array<ConsumableLangualsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableLangual` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableLangual` edge in the connection. */
export type ConsumableLangualsEdge = {
   __typename?: 'ConsumableLangualsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableLangual` at the end of the edge. */
  node: ConsumableLangual,
};

/** Methods to use when ordering `ConsumableLangual`. */
export enum ConsumableLangualsOrderBy {
  NATURAL = 'NATURAL',
  CONSUMABLE_ID_ASC = 'CONSUMABLE_ID_ASC',
  CONSUMABLE_ID_DESC = 'CONSUMABLE_ID_DESC',
  LANGUAL_CODE_ASC = 'LANGUAL_CODE_ASC',
  LANGUAL_CODE_DESC = 'LANGUAL_CODE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ConsumableMeasure = Node & {
   __typename?: 'ConsumableMeasure',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  consumableId: Scalars['Int'],
  /** amount of label definition per serving */
  quantity: Scalars['Float'],
  /** name of the measure, e.g. "large" */
  label: Scalars['String'],
  factor: Scalars['Float'],
  /** additional meta data for record */
  sourceMeta: Scalars['JSON'],
  /** equivalent of the measure expressed as an equivalentUnit */
  equivalent?: Maybe<Scalars['Float']>,
  /** Unit in which the equivalent amount is expressed. Usually either gram (g) or milliliter (ml) */
  equivalentUnit?: Maybe<Scalars['String']>,
  measureCategory: ConsumableMeasureCategory,
  /** Reads a single `Consumable` that is related to this `ConsumableMeasure`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads and enables pagination through a set of `MealConsumable`. */
  mealConsumablesByConsumableIdAndConsumableMeasureId: MealConsumablesConnection,
  /** Reads and enables pagination through a set of `MealConsumable`. */
  mealConsumablesByConsumableMeasureId: MealConsumablesConnection,
};


export type ConsumableMeasuremealConsumablesByConsumableIdAndConsumableMeasureIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>,
  condition?: Maybe<MealConsumableCondition>,
  filter?: Maybe<MealConsumableFilter>
};


export type ConsumableMeasuremealConsumablesByConsumableMeasureIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>,
  condition?: Maybe<MealConsumableCondition>,
  filter?: Maybe<MealConsumableFilter>
};

export enum ConsumableMeasureCategory {
  UNKNOWN = 'UNKNOWN',
  WEIGHT = 'WEIGHT',
  VOLUME = 'VOLUME',
  EACH = 'EACH'
}

/** A filter to be used against ConsumableMeasureCategory fields. All fields are combined with a logical ‘and.’ */
export type ConsumableMeasureCategoryFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<ConsumableMeasureCategory>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ConsumableMeasureCategory>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ConsumableMeasureCategory>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ConsumableMeasureCategory>,
  /** Included in the specified list. */
  in?: Maybe<Array<ConsumableMeasureCategory>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ConsumableMeasureCategory>>,
  /** Less than the specified value. */
  lessThan?: Maybe<ConsumableMeasureCategory>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ConsumableMeasureCategory>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<ConsumableMeasureCategory>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ConsumableMeasureCategory>,
};

/** 
 * A condition to be used against `ConsumableMeasure` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableMeasureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `consumableId` field. */
  consumableId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `factor` field. */
  factor?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<Scalars['JSON']>,
  /** Checks for equality with the object’s `equivalent` field. */
  equivalent?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `equivalentUnit` field. */
  equivalentUnit?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `measureCategory` field. */
  measureCategory?: Maybe<ConsumableMeasureCategory>,
};

/** A filter to be used against `ConsumableMeasure` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableMeasureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `consumableId` field. */
  consumableId?: Maybe<IntFilter>,
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<FloatFilter>,
  /** Filter by the object’s `label` field. */
  label?: Maybe<StringFilter>,
  /** Filter by the object’s `factor` field. */
  factor?: Maybe<FloatFilter>,
  /** Filter by the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<JSONFilter>,
  /** Filter by the object’s `equivalent` field. */
  equivalent?: Maybe<FloatFilter>,
  /** Filter by the object’s `equivalentUnit` field. */
  equivalentUnit?: Maybe<StringFilter>,
  /** Filter by the object’s `measureCategory` field. */
  measureCategory?: Maybe<ConsumableMeasureCategoryFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableMeasureFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableMeasureFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableMeasureFilter>,
};

/** A connection to a list of `ConsumableMeasure` values. */
export type ConsumableMeasuresConnection = {
   __typename?: 'ConsumableMeasuresConnection',
  /** A list of `ConsumableMeasure` objects. */
  nodes: Array<ConsumableMeasure>,
  /** A list of edges which contains the `ConsumableMeasure` and cursor to aid in pagination. */
  edges: Array<ConsumableMeasuresEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableMeasure` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableMeasure` edge in the connection. */
export type ConsumableMeasuresEdge = {
   __typename?: 'ConsumableMeasuresEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableMeasure` at the end of the edge. */
  node: ConsumableMeasure,
};

/** Methods to use when ordering `ConsumableMeasure`. */
export enum ConsumableMeasuresOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  CONSUMABLE_ID_ASC = 'CONSUMABLE_ID_ASC',
  CONSUMABLE_ID_DESC = 'CONSUMABLE_ID_DESC',
  QUANTITY_ASC = 'QUANTITY_ASC',
  QUANTITY_DESC = 'QUANTITY_DESC',
  LABEL_ASC = 'LABEL_ASC',
  LABEL_DESC = 'LABEL_DESC',
  FACTOR_ASC = 'FACTOR_ASC',
  FACTOR_DESC = 'FACTOR_DESC',
  SOURCE_META_ASC = 'SOURCE_META_ASC',
  SOURCE_META_DESC = 'SOURCE_META_DESC',
  EQUIVALENT_ASC = 'EQUIVALENT_ASC',
  EQUIVALENT_DESC = 'EQUIVALENT_DESC',
  EQUIVALENT_UNIT_ASC = 'EQUIVALENT_UNIT_ASC',
  EQUIVALENT_UNIT_DESC = 'EQUIVALENT_UNIT_DESC',
  MEASURE_CATEGORY_ASC = 'MEASURE_CATEGORY_ASC',
  MEASURE_CATEGORY_DESC = 'MEASURE_CATEGORY_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ConsumableNutrient = Node & {
   __typename?: 'ConsumableNutrient',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  consumableId: Scalars['Int'],
  nutrientId: Scalars['Int'],
  unit: Scalars['String'],
  value: Scalars['Float'],
  sourceMeta: Scalars['JSON'],
  /** Reads a single `Consumable` that is related to this `ConsumableNutrient`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `Nutrient` that is related to this `ConsumableNutrient`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
};

/** 
 * A condition to be used against `ConsumableNutrient` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableNutrientCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `consumableId` field. */
  consumableId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `nutrientId` field. */
  nutrientId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `unit` field. */
  unit?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<Scalars['JSON']>,
};

/** A filter to be used against `ConsumableNutrient` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableNutrientFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `consumableId` field. */
  consumableId?: Maybe<IntFilter>,
  /** Filter by the object’s `nutrientId` field. */
  nutrientId?: Maybe<IntFilter>,
  /** Filter by the object’s `unit` field. */
  unit?: Maybe<StringFilter>,
  /** Filter by the object’s `value` field. */
  value?: Maybe<FloatFilter>,
  /** Filter by the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<JSONFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableNutrientFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableNutrientFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableNutrientFilter>,
};

/** A connection to a list of `ConsumableNutrient` values. */
export type ConsumableNutrientsConnection = {
   __typename?: 'ConsumableNutrientsConnection',
  /** A list of `ConsumableNutrient` objects. */
  nodes: Array<ConsumableNutrient>,
  /** A list of edges which contains the `ConsumableNutrient` and cursor to aid in pagination. */
  edges: Array<ConsumableNutrientsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableNutrient` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableNutrient` edge in the connection. */
export type ConsumableNutrientsEdge = {
   __typename?: 'ConsumableNutrientsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableNutrient` at the end of the edge. */
  node: ConsumableNutrient,
};

/** Methods to use when ordering `ConsumableNutrient`. */
export enum ConsumableNutrientsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  CONSUMABLE_ID_ASC = 'CONSUMABLE_ID_ASC',
  CONSUMABLE_ID_DESC = 'CONSUMABLE_ID_DESC',
  NUTRIENT_ID_ASC = 'NUTRIENT_ID_ASC',
  NUTRIENT_ID_DESC = 'NUTRIENT_ID_DESC',
  UNIT_ASC = 'UNIT_ASC',
  UNIT_DESC = 'UNIT_DESC',
  VALUE_ASC = 'VALUE_ASC',
  VALUE_DESC = 'VALUE_DESC',
  SOURCE_META_ASC = 'SOURCE_META_ASC',
  SOURCE_META_DESC = 'SOURCE_META_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Consumable`. Fields that are set will be updated. */
export type ConsumablePatch = {
  name?: Maybe<Scalars['String']>,
  foodGroup?: Maybe<Scalars['Int']>,
  shortDescription?: Maybe<Scalars['String']>,
  scientificName?: Maybe<Scalars['String']>,
  commercialName?: Maybe<Scalars['String']>,
  manufacturer?: Maybe<Scalars['String']>,
  nitrogenToProteinConversionFactor?: Maybe<Scalars['Float']>,
  carbohydrateFactor?: Maybe<Scalars['Float']>,
  fatFactor?: Maybe<Scalars['Float']>,
  proteinFactor?: Maybe<Scalars['Float']>,
  refusePercent?: Maybe<Scalars['Float']>,
  refuseDescription?: Maybe<Scalars['String']>,
  reportingUnit?: Maybe<Scalars['String']>,
  sourceMeta?: Maybe<Scalars['JSON']>,
};

/** A connection to a list of `Consumable` values. */
export type ConsumablesConnection = {
   __typename?: 'ConsumablesConnection',
  /** A list of `Consumable` objects. */
  nodes: Array<Consumable>,
  /** A list of edges which contains the `Consumable` and cursor to aid in pagination. */
  edges: Array<ConsumablesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Consumable` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Consumable` edge in the connection. */
export type ConsumablesEdge = {
   __typename?: 'ConsumablesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Consumable` at the end of the edge. */
  node: Consumable,
};

/** All input for the `consumableSetIngredients` mutation. */
export type ConsumableSetIngredientsInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  consumableId?: Maybe<Scalars['Int']>,
  ingredients?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** The output of our `consumableSetIngredients` mutation. */
export type ConsumableSetIngredientsPayload = {
   __typename?: 'ConsumableSetIngredientsPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  consumable?: Maybe<Consumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** An edge for our `Consumable`. May be used by Relay 1. */
  consumableEdge?: Maybe<ConsumablesEdge>,
};


/** The output of our `consumableSetIngredients` mutation. */
export type ConsumableSetIngredientsPayloadconsumableEdgeArgs = {
  orderBy?: Maybe<Array<ConsumablesOrderBy>>
};

/** Methods to use when ordering `Consumable`. */
export enum ConsumablesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  SOURCE_ASC = 'SOURCE_ASC',
  SOURCE_DESC = 'SOURCE_DESC',
  IDENTIFIER_ASC = 'IDENTIFIER_ASC',
  IDENTIFIER_DESC = 'IDENTIFIER_DESC',
  UPC_ASC = 'UPC_ASC',
  UPC_DESC = 'UPC_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  FOOD_GROUP_ASC = 'FOOD_GROUP_ASC',
  FOOD_GROUP_DESC = 'FOOD_GROUP_DESC',
  SHORT_DESCRIPTION_ASC = 'SHORT_DESCRIPTION_ASC',
  SHORT_DESCRIPTION_DESC = 'SHORT_DESCRIPTION_DESC',
  SCIENTIFIC_NAME_ASC = 'SCIENTIFIC_NAME_ASC',
  SCIENTIFIC_NAME_DESC = 'SCIENTIFIC_NAME_DESC',
  COMMERCIAL_NAME_ASC = 'COMMERCIAL_NAME_ASC',
  COMMERCIAL_NAME_DESC = 'COMMERCIAL_NAME_DESC',
  MANUFACTURER_ASC = 'MANUFACTURER_ASC',
  MANUFACTURER_DESC = 'MANUFACTURER_DESC',
  NITROGEN_TO_PROTEIN_CONVERSION_FACTOR_ASC = 'NITROGEN_TO_PROTEIN_CONVERSION_FACTOR_ASC',
  NITROGEN_TO_PROTEIN_CONVERSION_FACTOR_DESC = 'NITROGEN_TO_PROTEIN_CONVERSION_FACTOR_DESC',
  CARBOHYDRATE_FACTOR_ASC = 'CARBOHYDRATE_FACTOR_ASC',
  CARBOHYDRATE_FACTOR_DESC = 'CARBOHYDRATE_FACTOR_DESC',
  FAT_FACTOR_ASC = 'FAT_FACTOR_ASC',
  FAT_FACTOR_DESC = 'FAT_FACTOR_DESC',
  PROTEIN_FACTOR_ASC = 'PROTEIN_FACTOR_ASC',
  PROTEIN_FACTOR_DESC = 'PROTEIN_FACTOR_DESC',
  REFUSE_PERCENT_ASC = 'REFUSE_PERCENT_ASC',
  REFUSE_PERCENT_DESC = 'REFUSE_PERCENT_DESC',
  REFUSE_DESCRIPTION_ASC = 'REFUSE_DESCRIPTION_ASC',
  REFUSE_DESCRIPTION_DESC = 'REFUSE_DESCRIPTION_DESC',
  DATABASE_SOURCE_ASC = 'DATABASE_SOURCE_ASC',
  DATABASE_SOURCE_DESC = 'DATABASE_SOURCE_DESC',
  REPORTING_UNIT_ASC = 'REPORTING_UNIT_ASC',
  REPORTING_UNIT_DESC = 'REPORTING_UNIT_DESC',
  SOURCE_META_ASC = 'SOURCE_META_ASC',
  SOURCE_META_DESC = 'SOURCE_META_DESC',
  VERIFIED_BY_USER_ID_ASC = 'VERIFIED_BY_USER_ID_ASC',
  VERIFIED_BY_USER_ID_DESC = 'VERIFIED_BY_USER_ID_DESC',
  VERIFIED_ASC = 'VERIFIED_ASC',
  VERIFIED_DESC = 'VERIFIED_DESC',
  CONSUMABLE_SOURCE_ID_ASC = 'CONSUMABLE_SOURCE_ID_ASC',
  CONSUMABLE_SOURCE_ID_DESC = 'CONSUMABLE_SOURCE_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ConsumableSource = Node & {
   __typename?: 'ConsumableSource',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  name: Scalars['String'],
  /** Reads and enables pagination through a set of `Consumable`. */
  consumablesByConsumableSourceId: ConsumablesConnection,
};


export type ConsumableSourceconsumablesByConsumableSourceIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumablesOrderBy>>,
  condition?: Maybe<ConsumableCondition>,
  filter?: Maybe<ConsumableFilter>
};

/** 
 * A condition to be used against `ConsumableSource` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsumableSourceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
};

/** A filter to be used against `ConsumableSource` object types. All fields are combined with a logical ‘and.’ */
export type ConsumableSourceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ConsumableSourceFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ConsumableSourceFilter>>,
  /** Negates the expression. */
  not?: Maybe<ConsumableSourceFilter>,
};

/** A connection to a list of `ConsumableSource` values. */
export type ConsumableSourcesConnection = {
   __typename?: 'ConsumableSourcesConnection',
  /** A list of `ConsumableSource` objects. */
  nodes: Array<ConsumableSource>,
  /** A list of edges which contains the `ConsumableSource` and cursor to aid in pagination. */
  edges: Array<ConsumableSourcesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ConsumableSource` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ConsumableSource` edge in the connection. */
export type ConsumableSourcesEdge = {
   __typename?: 'ConsumableSourcesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ConsumableSource` at the end of the edge. */
  node: ConsumableSource,
};

/** Methods to use when ordering `ConsumableSource`. */
export enum ConsumableSourcesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `consumableVerify` mutation. */
export type ConsumableVerifyInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  consumableId?: Maybe<Scalars['Int']>,
};

/** The output of our `consumableVerify` mutation. */
export type ConsumableVerifyPayload = {
   __typename?: 'ConsumableVerifyPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  consumable?: Maybe<Consumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** An edge for our `Consumable`. May be used by Relay 1. */
  consumableEdge?: Maybe<ConsumablesEdge>,
};


/** The output of our `consumableVerify` mutation. */
export type ConsumableVerifyPayloadconsumableEdgeArgs = {
  orderBy?: Maybe<Array<ConsumablesOrderBy>>
};

/** All input for the create `Consumable` mutation. */
export type CreateConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Consumable` to be created by this mutation. */
  consumable: ConsumableInput,
};

/** The output of our create `Consumable` mutation. */
export type CreateConsumablePayload = {
   __typename?: 'CreateConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Consumable` that was created by this mutation. */
  consumable?: Maybe<Consumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** An edge for our `Consumable`. May be used by Relay 1. */
  consumableEdge?: Maybe<ConsumablesEdge>,
};


/** The output of our create `Consumable` mutation. */
export type CreateConsumablePayloadconsumableEdgeArgs = {
  orderBy?: Maybe<Array<ConsumablesOrderBy>>
};

/** All input for the create `MealConsumable` mutation. */
export type CreateMealConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealConsumable` to be created by this mutation. */
  mealConsumable: MealConsumableInput,
};

/** The output of our create `MealConsumable` mutation. */
export type CreateMealConsumablePayload = {
   __typename?: 'CreateMealConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealConsumable` that was created by this mutation. */
  mealConsumable?: Maybe<MealConsumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Meal` that is related to this `MealConsumable`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Consumable` that is related to this `MealConsumable`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableIdAndConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** Reads a single `MealConsumableCategory` that is related to this `MealConsumable`. */
  mealConsumableCategoryByMealConsumableCategoryId?: Maybe<MealConsumableCategory>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** An edge for our `MealConsumable`. May be used by Relay 1. */
  mealConsumableEdge?: Maybe<MealConsumablesEdge>,
};


/** The output of our create `MealConsumable` mutation. */
export type CreateMealConsumablePayloadmealConsumableEdgeArgs = {
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>
};

/** All input for the create `Meal` mutation. */
export type CreateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Meal` to be created by this mutation. */
  meal: MealInput,
};

/** The output of our create `Meal` mutation. */
export type CreateMealPayload = {
   __typename?: 'CreateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Meal` that was created by this mutation. */
  meal?: Maybe<Meal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `Meal`. May be used by Relay 1. */
  mealEdge?: Maybe<MealsEdge>,
};


/** The output of our create `Meal` mutation. */
export type CreateMealPayloadmealEdgeArgs = {
  orderBy?: Maybe<Array<MealsOrderBy>>
};

/** All input for the create `MealTag` mutation. */
export type CreateMealTagInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealTag` to be created by this mutation. */
  mealTag: MealTagInput,
};

/** The output of our create `MealTag` mutation. */
export type CreateMealTagPayload = {
   __typename?: 'CreateMealTagPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealTag` that was created by this mutation. */
  mealTag?: Maybe<MealTag>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Meal` that is related to this `MealTag`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Tag` that is related to this `MealTag`. */
  tagByTagId?: Maybe<Tag>,
  /** An edge for our `MealTag`. May be used by Relay 1. */
  mealTagEdge?: Maybe<MealTagsEdge>,
};


/** The output of our create `MealTag` mutation. */
export type CreateMealTagPayloadmealTagEdgeArgs = {
  orderBy?: Maybe<Array<MealTagsOrderBy>>
};

/** All input for the create `Menu` mutation. */
export type CreateMenuInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Menu` to be created by this mutation. */
  menu: MenuInput,
};

/** The output of our create `Menu` mutation. */
export type CreateMenuPayload = {
   __typename?: 'CreateMenuPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Menu` that was created by this mutation. */
  menu?: Maybe<Menu>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** An edge for our `Menu`. May be used by Relay 1. */
  menuEdge?: Maybe<MenusEdge>,
};


/** The output of our create `Menu` mutation. */
export type CreateMenuPayloadmenuEdgeArgs = {
  orderBy?: Maybe<Array<MenusOrderBy>>
};

/** All input for the create `MenuTemplateMeal` mutation. */
export type CreateMenuTemplateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MenuTemplateMeal` to be created by this mutation. */
  menuTemplateMeal: MenuTemplateMealInput,
};

/** The output of our create `MenuTemplateMeal` mutation. */
export type CreateMenuTemplateMealPayload = {
   __typename?: 'CreateMenuTemplateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MenuTemplateMeal` that was created by this mutation. */
  menuTemplateMeal?: Maybe<MenuTemplateMeal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Menu` that is related to this `MenuTemplateMeal`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Mealtime` that is related to this `MenuTemplateMeal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `User` that is related to this `MenuTemplateMeal`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `MenuTemplateMeal`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `MenuTemplateMeal` that is related to this `MenuTemplateMeal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** An edge for our `MenuTemplateMeal`. May be used by Relay 1. */
  menuTemplateMealEdge?: Maybe<MenuTemplateMealsEdge>,
};


/** The output of our create `MenuTemplateMeal` mutation. */
export type CreateMenuTemplateMealPayloadmenuTemplateMealEdgeArgs = {
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>
};

/** All input for the create `NutrientRange` mutation. */
export type CreateNutrientRangeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `NutrientRange` to be created by this mutation. */
  nutrientRange: NutrientRangeInput,
};

/** The output of our create `NutrientRange` mutation. */
export type CreateNutrientRangePayload = {
   __typename?: 'CreateNutrientRangePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `NutrientRange` that was created by this mutation. */
  nutrientRange?: Maybe<NutrientRange>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `SnomedProblemList` that is related to this `NutrientRange`. */
  snomedProblemListBySnomedCid?: Maybe<SnomedProblemList>,
  /** Reads a single `Nutrient` that is related to this `NutrientRange`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
  /** An edge for our `NutrientRange`. May be used by Relay 1. */
  nutrientRangeEdge?: Maybe<NutrientRangesEdge>,
};


/** The output of our create `NutrientRange` mutation. */
export type CreateNutrientRangePayloadnutrientRangeEdgeArgs = {
  orderBy?: Maybe<Array<NutrientRangesOrderBy>>
};

export type CreateNutritionIntakeInput = {
  clientMutationId?: Maybe<Scalars['String']>,
  id?: Maybe<Scalars['FHIRId']>,
  meta?: Maybe<FHIRMeta_Input>,
  status?: Maybe<Scalars['FHIRCode']>,
  patientId?: Maybe<Scalars['FHIRId']>,
};

export type CreateNutritionIntakePayload = {
   __typename?: 'CreateNutritionIntakePayload',
  clientMutationId?: Maybe<Scalars['String']>,
  nutritionIntake?: Maybe<NutritionIntake>,
  query?: Maybe<Query>,
};

/** All input for the create `Organization` mutation. */
export type CreateOrganizationInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Organization` to be created by this mutation. */
  organization: OrganizationInput,
};

/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayload = {
   __typename?: 'CreateOrganizationPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Organization` that was created by this mutation. */
  organization?: Maybe<Organization>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>,
};


/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayloadorganizationEdgeArgs = {
  orderBy?: Maybe<Array<OrganizationsOrderBy>>
};

/** All input for the create `Profile` mutation. */
export type CreateProfileInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Profile` to be created by this mutation. */
  profile: ProfileInput,
};

/** All input for the `createProfileInviteCode` mutation. */
export type CreateProfileInviteCodeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profileId?: Maybe<Scalars['Int']>,
};

/** The output of our `createProfileInviteCode` mutation. */
export type CreateProfileInviteCodePayload = {
   __typename?: 'CreateProfileInviteCodePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  string?: Maybe<Scalars['String']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

/** The output of our create `Profile` mutation. */
export type CreateProfilePayload = {
   __typename?: 'CreateProfilePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Profile` that was created by this mutation. */
  profile?: Maybe<Profile>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>,
};


/** The output of our create `Profile` mutation. */
export type CreateProfilePayloadprofileEdgeArgs = {
  orderBy?: Maybe<Array<ProfilesOrderBy>>
};

/** All input for the create `ProfileScheduledMealtime` mutation. */
export type CreateProfileScheduledMealtimeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileScheduledMealtime` to be created by this mutation. */
  profileScheduledMealtime: ProfileScheduledMealtimeInput,
};

/** The output of our create `ProfileScheduledMealtime` mutation. */
export type CreateProfileScheduledMealtimePayload = {
   __typename?: 'CreateProfileScheduledMealtimePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileScheduledMealtime` that was created by this mutation. */
  profileScheduledMealtime?: Maybe<ProfileScheduledMealtime>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Profile` that is related to this `ProfileScheduledMealtime`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `MenuTemplateMeal` that is related to this `ProfileScheduledMealtime`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `Organization` that is related to this `ProfileScheduledMealtime`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileScheduledMealtime`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByOriginalMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `ProfileScheduledMealtime`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `Menu` that is related to this `ProfileScheduledMealtime`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `ProfileScheduledMealtime`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `ProfileScheduledMealtime`. May be used by Relay 1. */
  profileScheduledMealtimeEdge?: Maybe<ProfileScheduledMealtimesEdge>,
};


/** The output of our create `ProfileScheduledMealtime` mutation. */
export type CreateProfileScheduledMealtimePayloadprofileScheduledMealtimeEdgeArgs = {
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Tag` to be created by this mutation. */
  tag: TagInput,
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
   __typename?: 'CreateTagPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<Tag>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>,
};


/** The output of our create `Tag` mutation. */
export type CreateTagPayloadtagEdgeArgs = {
  orderBy?: Maybe<Array<TagsOrderBy>>
};

/** All input for the create `UserDatum` mutation. */
export type CreateUserDatumInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserDatum` to be created by this mutation. */
  userDatum: UserDatumInput,
};

/** The output of our create `UserDatum` mutation. */
export type CreateUserDatumPayload = {
   __typename?: 'CreateUserDatumPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserDatum` that was created by this mutation. */
  userDatum?: Maybe<UserDatum>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `UserDatum`. */
  userByUserId?: Maybe<User>,
  /** An edge for our `UserDatum`. May be used by Relay 1. */
  userDatumEdge?: Maybe<UserDataEdge>,
};


/** The output of our create `UserDatum` mutation. */
export type CreateUserDatumPayloaduserDatumEdgeArgs = {
  orderBy?: Maybe<Array<UserDataOrderBy>>
};

/** All input for the create `UserRole` mutation. */
export type CreateUserRoleInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserRole` to be created by this mutation. */
  userRole: UserRoleInput,
};

/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayload = {
   __typename?: 'CreateUserRolePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserRole` that was created by this mutation. */
  userRole?: Maybe<UserRole>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `UserRole`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Role` that is related to this `UserRole`. */
  roleByRoleId?: Maybe<Role>,
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>,
};


/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayloaduserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
};



/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>,
};

export enum DaysOfWeek {
  SUN = 'SUN',
  MON = 'MON',
  TUE = 'TUE',
  WED = 'WED',
  THU = 'THU',
  FRI = 'FRI',
  SAT = 'SAT'
}

/** A filter to be used against DaysOfWeek fields. All fields are combined with a logical ‘and.’ */
export type DaysOfWeekFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<DaysOfWeek>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<DaysOfWeek>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<DaysOfWeek>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<DaysOfWeek>,
  /** Included in the specified list. */
  in?: Maybe<Array<DaysOfWeek>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<DaysOfWeek>>,
  /** Less than the specified value. */
  lessThan?: Maybe<DaysOfWeek>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<DaysOfWeek>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<DaysOfWeek>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<DaysOfWeek>,
};

/** All input for the `deleteConsumableById` mutation. */
export type DeleteConsumableByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteConsumableBySourceAndIdentifier` mutation. */
export type DeleteConsumableBySourceAndIdentifierInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  source: Scalars['String'],
  identifier: Scalars['String'],
};

/** All input for the `deleteConsumable` mutation. */
export type DeleteConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Consumable` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `Consumable` mutation. */
export type DeleteConsumablePayload = {
   __typename?: 'DeleteConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Consumable` that was deleted by this mutation. */
  consumable?: Maybe<Consumable>,
  deletedConsumableId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** An edge for our `Consumable`. May be used by Relay 1. */
  consumableEdge?: Maybe<ConsumablesEdge>,
};


/** The output of our delete `Consumable` mutation. */
export type DeleteConsumablePayloadconsumableEdgeArgs = {
  orderBy?: Maybe<Array<ConsumablesOrderBy>>
};

/** All input for the `deleteMealById` mutation. */
export type DeleteMealByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteMealConsumableById` mutation. */
export type DeleteMealConsumableByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteMealConsumable` mutation. */
export type DeleteMealConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `MealConsumable` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `MealConsumable` mutation. */
export type DeleteMealConsumablePayload = {
   __typename?: 'DeleteMealConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealConsumable` that was deleted by this mutation. */
  mealConsumable?: Maybe<MealConsumable>,
  deletedMealConsumableId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Meal` that is related to this `MealConsumable`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Consumable` that is related to this `MealConsumable`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableIdAndConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** Reads a single `MealConsumableCategory` that is related to this `MealConsumable`. */
  mealConsumableCategoryByMealConsumableCategoryId?: Maybe<MealConsumableCategory>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** An edge for our `MealConsumable`. May be used by Relay 1. */
  mealConsumableEdge?: Maybe<MealConsumablesEdge>,
};


/** The output of our delete `MealConsumable` mutation. */
export type DeleteMealConsumablePayloadmealConsumableEdgeArgs = {
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>
};

/** All input for the `deleteMeal` mutation. */
export type DeleteMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Meal` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `Meal` mutation. */
export type DeleteMealPayload = {
   __typename?: 'DeleteMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Meal` that was deleted by this mutation. */
  meal?: Maybe<Meal>,
  deletedMealId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `Meal`. May be used by Relay 1. */
  mealEdge?: Maybe<MealsEdge>,
};


/** The output of our delete `Meal` mutation. */
export type DeleteMealPayloadmealEdgeArgs = {
  orderBy?: Maybe<Array<MealsOrderBy>>
};

/** All input for the `deleteMealTagByMealIdAndTagId` mutation. */
export type DeleteMealTagByMealIdAndTagIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  mealId: Scalars['Int'],
  tagId: Scalars['Int'],
};

/** All input for the `deleteMealTag` mutation. */
export type DeleteMealTagInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `MealTag` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `MealTag` mutation. */
export type DeleteMealTagPayload = {
   __typename?: 'DeleteMealTagPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealTag` that was deleted by this mutation. */
  mealTag?: Maybe<MealTag>,
  deletedMealTagId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Meal` that is related to this `MealTag`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Tag` that is related to this `MealTag`. */
  tagByTagId?: Maybe<Tag>,
  /** An edge for our `MealTag`. May be used by Relay 1. */
  mealTagEdge?: Maybe<MealTagsEdge>,
};


/** The output of our delete `MealTag` mutation. */
export type DeleteMealTagPayloadmealTagEdgeArgs = {
  orderBy?: Maybe<Array<MealTagsOrderBy>>
};

/** All input for the `deleteMenuById` mutation. */
export type DeleteMenuByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteMenuDayRange` mutation. */
export type DeleteMenuDayRangeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menuId?: Maybe<Scalars['Int']>,
  dayNumberStart?: Maybe<Scalars['Int']>,
  dayNumberEnd?: Maybe<Scalars['Int']>,
  collapse?: Maybe<Scalars['Boolean']>,
};

/** The output of our `deleteMenuDayRange` mutation. */
export type DeleteMenuDayRangePayload = {
   __typename?: 'DeleteMenuDayRangePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menu?: Maybe<Menu>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** An edge for our `Menu`. May be used by Relay 1. */
  menuEdge?: Maybe<MenusEdge>,
};


/** The output of our `deleteMenuDayRange` mutation. */
export type DeleteMenuDayRangePayloadmenuEdgeArgs = {
  orderBy?: Maybe<Array<MenusOrderBy>>
};

/** All input for the `deleteMenu` mutation. */
export type DeleteMenuInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Menu` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `Menu` mutation. */
export type DeleteMenuPayload = {
   __typename?: 'DeleteMenuPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Menu` that was deleted by this mutation. */
  menu?: Maybe<Menu>,
  deletedMenuId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** An edge for our `Menu`. May be used by Relay 1. */
  menuEdge?: Maybe<MenusEdge>,
};


/** The output of our delete `Menu` mutation. */
export type DeleteMenuPayloadmenuEdgeArgs = {
  orderBy?: Maybe<Array<MenusOrderBy>>
};

/** All input for the `deleteMenuTemplateMealById` mutation. */
export type DeleteMenuTemplateMealByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteMenuTemplateMeal` mutation. */
export type DeleteMenuTemplateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `MenuTemplateMeal` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `MenuTemplateMeal` mutation. */
export type DeleteMenuTemplateMealPayload = {
   __typename?: 'DeleteMenuTemplateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MenuTemplateMeal` that was deleted by this mutation. */
  menuTemplateMeal?: Maybe<MenuTemplateMeal>,
  deletedMenuTemplateMealId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Menu` that is related to this `MenuTemplateMeal`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Mealtime` that is related to this `MenuTemplateMeal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `User` that is related to this `MenuTemplateMeal`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `MenuTemplateMeal`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `MenuTemplateMeal` that is related to this `MenuTemplateMeal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** An edge for our `MenuTemplateMeal`. May be used by Relay 1. */
  menuTemplateMealEdge?: Maybe<MenuTemplateMealsEdge>,
};


/** The output of our delete `MenuTemplateMeal` mutation. */
export type DeleteMenuTemplateMealPayloadmenuTemplateMealEdgeArgs = {
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>
};

/** All input for the `deleteOrganizationById` mutation. */
export type DeleteOrganizationByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteOrganization` mutation. */
export type DeleteOrganizationInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Organization` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayload = {
   __typename?: 'DeleteOrganizationPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Organization` that was deleted by this mutation. */
  organization?: Maybe<Organization>,
  deletedOrganizationId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>,
};


/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayloadorganizationEdgeArgs = {
  orderBy?: Maybe<Array<OrganizationsOrderBy>>
};

/** All input for the `deleteProfileById` mutation. */
export type DeleteProfileByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteProfileByOpenId` mutation. */
export type DeleteProfileByOpenIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  openId: Scalars['String'],
};

/** All input for the `deleteProfileDatumByProfileId` mutation. */
export type DeleteProfileDatumByProfileIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profileId: Scalars['Int'],
};

/** All input for the `deleteProfileDatum` mutation. */
export type DeleteProfileDatumInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `ProfileDatum` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `ProfileDatum` mutation. */
export type DeleteProfileDatumPayload = {
   __typename?: 'DeleteProfileDatumPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileDatum` that was deleted by this mutation. */
  profileDatum?: Maybe<ProfileDatum>,
  deletedProfileDatumId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Profile` that is related to this `ProfileDatum`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `Organization` that is related to this `ProfileDatum`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `ProfileDatum`. May be used by Relay 1. */
  profileDatumEdge?: Maybe<ProfileDataEdge>,
};


/** The output of our delete `ProfileDatum` mutation. */
export type DeleteProfileDatumPayloadprofileDatumEdgeArgs = {
  orderBy?: Maybe<Array<ProfileDataOrderBy>>
};

/** All input for the `deleteProfile` mutation. */
export type DeleteProfileInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Profile` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `Profile` mutation. */
export type DeleteProfilePayload = {
   __typename?: 'DeleteProfilePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Profile` that was deleted by this mutation. */
  profile?: Maybe<Profile>,
  deletedProfileId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>,
};


/** The output of our delete `Profile` mutation. */
export type DeleteProfilePayloadprofileEdgeArgs = {
  orderBy?: Maybe<Array<ProfilesOrderBy>>
};

/** All input for the `deleteProfileScheduledMealtimeById` mutation. */
export type DeleteProfileScheduledMealtimeByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** All input for the `deleteProfileScheduledMealtime` mutation. */
export type DeleteProfileScheduledMealtimeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `ProfileScheduledMealtime` to be deleted. */
  nodeId: Scalars['ID'],
};

/** The output of our delete `ProfileScheduledMealtime` mutation. */
export type DeleteProfileScheduledMealtimePayload = {
   __typename?: 'DeleteProfileScheduledMealtimePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileScheduledMealtime` that was deleted by this mutation. */
  profileScheduledMealtime?: Maybe<ProfileScheduledMealtime>,
  deletedProfileScheduledMealtimeId?: Maybe<Scalars['ID']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Profile` that is related to this `ProfileScheduledMealtime`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `MenuTemplateMeal` that is related to this `ProfileScheduledMealtime`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `Organization` that is related to this `ProfileScheduledMealtime`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileScheduledMealtime`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByOriginalMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `ProfileScheduledMealtime`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `Menu` that is related to this `ProfileScheduledMealtime`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `ProfileScheduledMealtime`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `ProfileScheduledMealtime`. May be used by Relay 1. */
  profileScheduledMealtimeEdge?: Maybe<ProfileScheduledMealtimesEdge>,
};


/** The output of our delete `ProfileScheduledMealtime` mutation. */
export type DeleteProfileScheduledMealtimePayloadprofileScheduledMealtimeEdgeArgs = {
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>
};

/** All input for the `duplicateMenuDayRange` mutation. */
export type DuplicateMenuDayRangeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  sourceMenuId?: Maybe<Scalars['Int']>,
  sourceDayNumberStart?: Maybe<Scalars['Int']>,
  sourceDayNumberEnd?: Maybe<Scalars['Int']>,
  targetMenuId?: Maybe<Scalars['Int']>,
  targetDayNumberStart?: Maybe<Scalars['Int']>,
};

/** The output of our `duplicateMenuDayRange` mutation. */
export type DuplicateMenuDayRangePayload = {
   __typename?: 'DuplicateMenuDayRangePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menu?: Maybe<Menu>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** An edge for our `Menu`. May be used by Relay 1. */
  menuEdge?: Maybe<MenusEdge>,
};


/** The output of our `duplicateMenuDayRange` mutation. */
export type DuplicateMenuDayRangePayloadmenuEdgeArgs = {
  orderBy?: Maybe<Array<MenusOrderBy>>
};

/** 
 * A financial tool for tracking value accrued for a particular purpose.  In the
 * healthcare field, used to track charges for a patient, cost centers, etc.
 */
export type FHIRAccount = {
   __typename?: 'FHIRAccount',
  /** Type of resource */
  resourceType: FHIRAccount_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number). */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates whether the account is presently used/usable or not. */
  status: Scalars['FHIRCode'],
  /** Categorizes the account for reporting and searching purposes. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Name used for the account when displaying it to humans in reports, etc. */
  name?: Maybe<Scalars['String']>,
  /** 
 * Identifies the entity which incurs the expenses. While the immediate
   * recipients of services or goods might be entities related to the subject, the
   * expenses were ultimately incurred by the subject of the Account.
 */
  subject?: Maybe<Array<Maybe<FHIRAccountsubject_subject_Union>>>,
  /** The date range of services associated with this account. */
  servicePeriod?: Maybe<FHIRPeriod>,
  /** 
 * The party(s) that are responsible for covering the payment of this account,
   * and what order should they be applied to the account.
 */
  coverage?: Maybe<Array<Maybe<FHIRAccountcoverage>>>,
  /** Indicates the service area, hospital, department, etc. with responsibility for managing the Account. */
  owner?: Maybe<FHIRAccountowner_owner_Union>,
  /** Provides additional information about what the account tracks and how it is used. */
  description?: Maybe<Scalars['String']>,
  /** The parties responsible for balancing the account if other payment options fall short. */
  guarantor?: Maybe<Array<Maybe<FHIRAccountguarantor>>>,
  /** Reference to a parent Account. */
  partOf?: Maybe<FHIRAccountpartOf_partOf_Union>,
};

export enum FHIRAccount_Enum_schema {
  Account = 'Account'
}

export type FHIRAccountcoverage = {
   __typename?: 'FHIRAccountcoverage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The party(s) that contribute to payment (or part of) of the charges applied to
   * this account (including self-pay).  A coverage may only be responsible for
   * specific types of charges, and the sequence of the coverages in the account
   * could be important when processing billing.
 */
  coverage: FHIRAccountcoveragecoverage_coverage_Union,
  /** The priority of the coverage in the context of this account. */
  priority?: Maybe<Scalars['FHIRPositiveInt']>,
};

/** 
 * The party(s) that contribute to payment (or part of) of the charges applied to
 * this account (including self-pay).  A coverage may only be responsible for
 * specific types of charges, and the sequence of the coverages in the account
 * could be important when processing billing.
 */
export type FHIRAccountcoveragecoverage_coverage_Union = FHIRCoverage;

export type FHIRAccountguarantor = {
   __typename?: 'FHIRAccountguarantor',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The entity who is responsible. */
  party: FHIRAccountguarantorparty_party_Union,
  /** A guarantor may be placed on credit hold or otherwise have their role temporarily suspended. */
  onHold?: Maybe<Scalars['Boolean']>,
  /** The timeframe during which the guarantor accepts responsibility for the account. */
  period?: Maybe<FHIRPeriod>,
};

/** The entity who is responsible. */
export type FHIRAccountguarantorparty_party_Union = FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** Indicates the service area, hospital, department, etc. with responsibility for managing the Account. */
export type FHIRAccountowner_owner_Union = FHIROrganization;

/** Reference to a parent Account. */
export type FHIRAccountpartOf_partOf_Union = FHIRAccount;

/** 
 * Identifies the entity which incurs the expenses. While the immediate recipients
 * of services or goods might be entities related to the subject, the expenses were
 * ultimately incurred by the subject of the Account.
 */
export type FHIRAccountsubject_subject_Union = FHIRPatient | FHIRDevice | FHIRPractitioner | FHIRPractitionerRole | FHIRLocation | FHIRHealthcareService | FHIROrganization;

/** 
 * This resource allows for the definition of some activity to be performed,
 * independent of a particular patient, practitioner, or other performance context.
 */
export type FHIRActivityDefinition = {
   __typename?: 'FHIRActivityDefinition',
  /** Type of resource */
  resourceType: FHIRActivityDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this activity definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this activity
   * definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the activity definition is
   * stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this activity definition when it
   * is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the activity
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the activity definition author
   * and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence. To
   * provide a version consistent with the Decision Support Service specification,
   * use the format Major.Minor.Revision (e.g. 1.0.0). For more information on
   * versioning knowledge assets, refer to the Decision Support Service
   * specification. Note that a version is required for non-experimental active assets.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the activity definition. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the activity definition. */
  title?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the activity definition giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this activity definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this activity definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** A code or group definition that describes the intended subject of the activity being defined. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A code or group definition that describes the intended subject of the activity being defined. */
  subjectReference?: Maybe<FHIRActivityDefinitionsubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the activity definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the activity definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the activity definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the activity definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate activity
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the activity definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this activity definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description of how the activity definition is used from a clinical perspective. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the activity definition and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the activity definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the activity definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the activity. Topics provide a
   * high-level categorization of the activity that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a Library resource containing any formal logic used by the activity definition. */
  library?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * A description of the kind of resource the activity definition is representing.
   * For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest.
   * Typically, but not always, this is a Request resource.
 */
  kind?: Maybe<Scalars['FHIRCode']>,
  /** A profile to which the target of the activity definition is expected to conform. */
  profile?: Maybe<Scalars['FHIRCanonical']>,
  /** Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter. */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * Indicates the level of authority/intentionality associated with the activity
   * and where the request should fit into the workflow chain.
 */
  intent?: Maybe<Scalars['FHIRCode']>,
  /** Indicates how quickly the activity  should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Set this to true if the definition is to indicate that a particular activity
   * should NOT be performed. If true, this element should be interpreted to
   * reinforce a negative coding. For example NPO as a code with a doNotPerform of
   * true would still indicate to NOT perform the action.
 */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingTiming?: Maybe<FHIRTiming>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingAge?: Maybe<FHIRAge>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingRange?: Maybe<FHIRRange>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  timingDuration?: Maybe<FHIRDuration>,
  /** Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. */
  location?: Maybe<FHIRActivityDefinitionlocation_location_Union>,
  /** Indicates who should participate in performing the action described. */
  participant?: Maybe<Array<Maybe<FHIRActivityDefinitionparticipant>>>,
  /** Identifies the food, drug or other product being consumed or supplied in the activity. */
  productReference?: Maybe<FHIRActivityDefinitionproductReference_productReference_Union>,
  /** Identifies the food, drug or other product being consumed or supplied in the activity. */
  productCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Identifies the quantity expected to be consumed at once (per dose, per meal, etc.). */
  quantity?: Maybe<FHIRQuantity>,
  /** Provides detailed dosage instructions in the same way that they are described for MedicationRequest resources. */
  dosage?: Maybe<Array<Maybe<FHIRDosage>>>,
  /** Indicates the sites on the subject's body where the procedure should be performed (I.e. the target sites). */
  bodySite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Defines specimen requirements for the action to be performed, such as required specimens for a lab test. */
  specimenRequirement?: Maybe<Array<Maybe<FHIRActivityDefinitionspecimenRequirement_specimenRequirement_Union>>>,
  /** Defines observation requirements for the action to be performed, such as body weight or surface area. */
  observationRequirement?: Maybe<Array<Maybe<FHIRActivityDefinitionobservationRequirement_observationRequirement_Union>>>,
  /** Defines the observations that are expected to be produced by the action. */
  observationResultRequirement?: Maybe<Array<Maybe<FHIRActivityDefinitionobservationResultRequirement_observationResultRequirement_Union>>>,
  /** 
 * A reference to a StructureMap resource that defines a transform that can be
   * executed to produce the intent resource using the ActivityDefinition instance as the input.
 */
  transform?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Dynamic values that will be evaluated to produce values for elements of the
   * resulting resource. For example, if the dosage of a medication must be
   * computed based on the patient's weight, a dynamic value would be used to
   * specify an expression that calculated the weight, and the path on the request
   * resource that would contain the result.
 */
  dynamicValue?: Maybe<Array<Maybe<FHIRActivityDefinitiondynamicValue>>>,
};

export enum FHIRActivityDefinition_Enum_schema {
  ActivityDefinition = 'ActivityDefinition'
}

export type FHIRActivityDefinitiondynamicValue = {
   __typename?: 'FHIRActivityDefinitiondynamicValue',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The path to the element to be customized. This is the path on the resource
   * that will hold the result of the calculation defined by the expression. The
   * specified path SHALL be a FHIRPath resolveable on the specified target type of
   * the ActivityDefinition, and SHALL consist only of identifiers, constant
   * indexers, and a restricted subset of functions. The path is allowed to contain
   * qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
   * multiple-cardinality sub-elements (see the [Simple FHIRPath
   * Profile](fhirpath.html#simple) for full details).
 */
  path: Scalars['String'],
  /** An expression specifying the value of the customized element. */
  expression: FHIRExpression,
};

/** Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. */
export type FHIRActivityDefinitionlocation_location_Union = FHIRLocation;

/** Defines observation requirements for the action to be performed, such as body weight or surface area. */
export type FHIRActivityDefinitionobservationRequirement_observationRequirement_Union = FHIRObservationDefinition;

/** Defines the observations that are expected to be produced by the action. */
export type FHIRActivityDefinitionobservationResultRequirement_observationResultRequirement_Union = FHIRObservationDefinition;

export type FHIRActivityDefinitionparticipant = {
   __typename?: 'FHIRActivityDefinitionparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of participant in the action. */
  type: Scalars['FHIRCode'],
  /** The role the participant should play in performing the described action. */
  role?: Maybe<FHIRCodeableConcept>,
};

/** Identifies the food, drug or other product being consumed or supplied in the activity. */
export type FHIRActivityDefinitionproductReference_productReference_Union = FHIRMedication | FHIRSubstance;

/** Defines specimen requirements for the action to be performed, such as required specimens for a lab test. */
export type FHIRActivityDefinitionspecimenRequirement_specimenRequirement_Union = FHIRSpecimenDefinition;

/** A code or group definition that describes the intended subject of the activity being defined. */
export type FHIRActivityDefinitionsubjectReference_subjectReference_Union = FHIRGroup;

/** 
 * Base StructureDefinition for Address Type: An address expressed using postal
 * conventions (as opposed to GPS or other location definition formats).  This data
 * type may be used to convey addresses for use in delivering mail as well as for
 * visiting locations which might not be valid for mail delivery.  There are a
 * variety of postal address formats defined around the world.
 */
export type FHIRAddress = {
   __typename?: 'FHIRAddress',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The purpose of this address. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Distinguishes between physical addresses (those you can visit) and mailing
   * addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
 */
  type?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies the entire address as it should be displayed e.g. on a postal label.
   * This may be provided instead of or as well as the specific parts.
 */
  text?: Maybe<Scalars['String']>,
  /** 
 * This component contains the house number, apartment number, street name,
   * street direction,  P.O. Box number, delivery hints, and similar address information.
 */
  line?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The name of the city, town, suburb, village or other community or delivery center. */
  city?: Maybe<Scalars['String']>,
  /** The name of the administrative area (county). */
  district?: Maybe<Scalars['String']>,
  /** 
 * Sub-unit of a country with limited sovereignty in a federally organized
   * country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
 */
  state?: Maybe<Scalars['String']>,
  /** A postal code designating a region defined by the postal service. */
  postalCode?: Maybe<Scalars['String']>,
  /** Country - a nation as commonly understood or generally accepted. */
  country?: Maybe<Scalars['String']>,
  /** Time period when address was/is in use. */
  period?: Maybe<FHIRPeriod>,
};

/** 
 * Base StructureDefinition for Address Type: An address expressed using postal
 * conventions (as opposed to GPS or other location definition formats).  This data
 * type may be used to convey addresses for use in delivering mail as well as for
 * visiting locations which might not be valid for mail delivery.  There are a
 * variety of postal address formats defined around the world.
 */
export type FHIRAddress_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The purpose of this address. */
  _use?: Maybe<FHIRElement_Input>,
  /** The purpose of this address. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Distinguishes between physical addresses (those you can visit) and mailing
   * addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
 */
  _type?: Maybe<FHIRElement_Input>,
  /** 
 * Distinguishes between physical addresses (those you can visit) and mailing
   * addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
 */
  type?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies the entire address as it should be displayed e.g. on a postal label.
   * This may be provided instead of or as well as the specific parts.
 */
  _text?: Maybe<FHIRElement_Input>,
  /** 
 * Specifies the entire address as it should be displayed e.g. on a postal label.
   * This may be provided instead of or as well as the specific parts.
 */
  text?: Maybe<Scalars['String']>,
  /** 
 * This component contains the house number, apartment number, street name,
   * street direction,  P.O. Box number, delivery hints, and similar address information.
 */
  _line?: Maybe<FHIRElement_Input>,
  /** 
 * This component contains the house number, apartment number, street name,
   * street direction,  P.O. Box number, delivery hints, and similar address information.
 */
  line?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The name of the city, town, suburb, village or other community or delivery center. */
  _city?: Maybe<FHIRElement_Input>,
  /** The name of the city, town, suburb, village or other community or delivery center. */
  city?: Maybe<Scalars['String']>,
  /** The name of the administrative area (county). */
  _district?: Maybe<FHIRElement_Input>,
  /** The name of the administrative area (county). */
  district?: Maybe<Scalars['String']>,
  /** 
 * Sub-unit of a country with limited sovereignty in a federally organized
   * country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
 */
  _state?: Maybe<FHIRElement_Input>,
  /** 
 * Sub-unit of a country with limited sovereignty in a federally organized
   * country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
 */
  state?: Maybe<Scalars['String']>,
  /** A postal code designating a region defined by the postal service. */
  _postalCode?: Maybe<FHIRElement_Input>,
  /** A postal code designating a region defined by the postal service. */
  postalCode?: Maybe<Scalars['String']>,
  /** Country - a nation as commonly understood or generally accepted. */
  _country?: Maybe<FHIRElement_Input>,
  /** Country - a nation as commonly understood or generally accepted. */
  country?: Maybe<Scalars['String']>,
  /** Time period when address was/is in use. */
  period?: Maybe<FHIRPeriod_Input>,
};

/** 
 * Actual or  potential/avoided event causing unintended physical injury resulting
 * from or contributed to by medical care, a research study or other healthcare
 * setting factors that requires additional monitoring, treatment, or
 * hospitalization, or that results in death.
 */
export type FHIRAdverseEvent = {
   __typename?: 'FHIRAdverseEvent',
  /** Type of resource */
  resourceType: FHIRAdverseEvent_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this adverse event by the performer or other
   * systems which remain constant as the resource is updated and propagates from
   * server to server.
 */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * Whether the event actually happened, or just had the potential to. Note that
   * this is independent of whether anyone was affected or harmed or how severely.
 */
  actuality: Scalars['FHIRCode'],
  /** The overall type of event, intended for search and filtering purposes. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** This element defines the specific type of event that occurred or that was prevented from occurring. */
  event?: Maybe<FHIRCodeableConcept>,
  /** This subject or group impacted by the event. */
  subject: FHIRAdverseEventsubject_subject_Union,
  /** The Encounter during which AdverseEvent was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRAdverseEventencounter_encounter_Union>,
  /** The date (and perhaps time) when the adverse event occurred. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Estimated or actual date the AdverseEvent began, in the opinion of the reporter. */
  detected?: Maybe<Scalars['FHIRDateTime']>,
  /** The date on which the existence of the AdverseEvent was first recorded. */
  recordedDate?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Includes information about the reaction that occurred as a result of exposure
   * to a substance (for example, a drug or a chemical).
 */
  resultingCondition?: Maybe<Array<Maybe<FHIRAdverseEventresultingCondition_resultingCondition_Union>>>,
  /** The information about where the adverse event occurred. */
  location?: Maybe<FHIRAdverseEventlocation_location_Union>,
  /** Assessment whether this event was of real importance. */
  seriousness?: Maybe<FHIRCodeableConcept>,
  /** 
 * Describes the severity of the adverse event, in relation to the subject.
   * Contrast to AdverseEvent.seriousness - a severe rash might not be serious, but
   * a mild heart problem is.
 */
  severity?: Maybe<FHIRCodeableConcept>,
  /** Describes the type of outcome from the adverse event. */
  outcome?: Maybe<FHIRCodeableConcept>,
  /** Information on who recorded the adverse event.  May be the patient or a practitioner. */
  recorder?: Maybe<FHIRAdverseEventrecorder_recorder_Union>,
  /** 
 * Parties that may or should contribute or have contributed information to the
   * adverse event, which can consist of one or more activities.  Such information
   * includes information leading to the decision to perform the activity and how
   * to perform the activity (e.g. consultant), information that the activity
   * itself seeks to reveal (e.g. informant of clinical history), or information
   * about what activity was performed (e.g. informant witness).
 */
  contributor?: Maybe<Array<Maybe<FHIRAdverseEventcontributor_contributor_Union>>>,
  /** Describes the entity that is suspected to have caused the adverse event. */
  suspectEntity?: Maybe<Array<Maybe<FHIRAdverseEventsuspectEntity>>>,
  /** AdverseEvent.subjectMedicalHistory. */
  subjectMedicalHistory?: Maybe<Array<Maybe<FHIRAdverseEventsubjectMedicalHistory_subjectMedicalHistory_Union>>>,
  /** AdverseEvent.referenceDocument. */
  referenceDocument?: Maybe<Array<Maybe<FHIRAdverseEventreferenceDocument_referenceDocument_Union>>>,
  /** AdverseEvent.study. */
  study?: Maybe<Array<Maybe<FHIRAdverseEventstudy_study_Union>>>,
};

export enum FHIRAdverseEvent_Enum_schema {
  AdverseEvent = 'AdverseEvent'
}

/** 
 * Parties that may or should contribute or have contributed information to the
 * adverse event, which can consist of one or more activities.  Such information
 * includes information leading to the decision to perform the activity and how to
 * perform the activity (e.g. consultant), information that the activity itself
 * seeks to reveal (e.g. informant of clinical history), or information about what
 * activity was performed (e.g. informant witness).
 */
export type FHIRAdverseEventcontributor_contributor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRDevice;

/** The Encounter during which AdverseEvent was created or to which the creation of this record is tightly associated. */
export type FHIRAdverseEventencounter_encounter_Union = FHIREncounter;

/** The information about where the adverse event occurred. */
export type FHIRAdverseEventlocation_location_Union = FHIRLocation;

/** Information on who recorded the adverse event.  May be the patient or a practitioner. */
export type FHIRAdverseEventrecorder_recorder_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** AdverseEvent.referenceDocument. */
export type FHIRAdverseEventreferenceDocument_referenceDocument_Union = FHIRDocumentReference;

/** 
 * Includes information about the reaction that occurred as a result of exposure to
 * a substance (for example, a drug or a chemical).
 */
export type FHIRAdverseEventresultingCondition_resultingCondition_Union = FHIRCondition;

/** AdverseEvent.study. */
export type FHIRAdverseEventstudy_study_Union = FHIRResearchStudy;

/** This subject or group impacted by the event. */
export type FHIRAdverseEventsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRPractitioner | FHIRRelatedPerson;

/** AdverseEvent.subjectMedicalHistory. */
export type FHIRAdverseEventsubjectMedicalHistory_subjectMedicalHistory_Union = FHIRCondition | FHIRObservation | FHIRAllergyIntolerance | FHIRFamilyMemberHistory | FHIRImmunization | FHIRProcedure | FHIRMedia | FHIRDocumentReference;

export type FHIRAdverseEventsuspectEntity = {
   __typename?: 'FHIRAdverseEventsuspectEntity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifies the actual instance of what caused the adverse event.  May be a
   * substance, medication, medication administration, medication statement or a device.
 */
  instance: FHIRAdverseEventsuspectEntityinstance_instance_Union,
  /** Information on the possible cause of the event. */
  causality?: Maybe<Array<Maybe<FHIRAdverseEventsuspectEntitycausality>>>,
};

export type FHIRAdverseEventsuspectEntitycausality = {
   __typename?: 'FHIRAdverseEventsuspectEntitycausality',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Assessment of if the entity caused the event. */
  assessment?: Maybe<FHIRCodeableConcept>,
  /** AdverseEvent.suspectEntity.causalityProductRelatedness. */
  productRelatedness?: Maybe<Scalars['String']>,
  /** AdverseEvent.suspectEntity.causalityAuthor. */
  author?: Maybe<FHIRAdverseEventsuspectEntitycausalityauthor_author_Union>,
  /** ProbabilityScale | Bayesian | Checklist. */
  method?: Maybe<FHIRCodeableConcept>,
};

/** AdverseEvent.suspectEntity.causalityAuthor. */
export type FHIRAdverseEventsuspectEntitycausalityauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole;

/** 
 * Identifies the actual instance of what caused the adverse event.  May be a
 * substance, medication, medication administration, medication statement or a device.
 */
export type FHIRAdverseEventsuspectEntityinstance_instance_Union = FHIRImmunization | FHIRProcedure | FHIRSubstance | FHIRMedication | FHIRMedicationAdministration | FHIRMedicationStatement | FHIRDevice;

/** Base StructureDefinition for Age Type: A duration of time during which an organism (or a process) has existed. */
export type FHIRAge = {
   __typename?: 'FHIRAge',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** Base StructureDefinition for Age Type: A duration of time during which an organism (or a process) has existed. */
export type FHIRAge_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  _value?: Maybe<FHIRElement_Input>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  _comparator?: Maybe<FHIRElement_Input>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  _unit?: Maybe<FHIRElement_Input>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  _code?: Maybe<FHIRElement_Input>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * Risk of harmful or undesirable, physiological response which is unique to an
 * individual and associated with exposure to a substance.
 */
export type FHIRAllergyIntolerance = {
   __typename?: 'FHIRAllergyIntolerance',
  /** Type of resource */
  resourceType: FHIRAllergyIntolerance_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this AllergyIntolerance by the performer or
   * other systems which remain constant as the resource is updated and propagates
   * from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The clinical status of the allergy or intolerance. */
  clinicalStatus?: Maybe<FHIRCodeableConcept>,
  /** 
 * Assertion about certainty associated with the propensity, or potential risk,
   * of a reaction to the identified substance (including pharmaceutical product).
 */
  verificationStatus?: Maybe<FHIRCodeableConcept>,
  /** Identification of the underlying physiological mechanism for the reaction risk. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** Category of the identified substance. */
  category?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Estimate of the potential clinical harm, or seriousness, of the reaction to the identified substance. */
  criticality?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Code for an allergy or intolerance statement (either a positive or a
   * negated/excluded statement).  This may be a code for a substance or
   * pharmaceutical product that is considered to be responsible for the adverse
   * reaction risk (e.g., 'Latex'), an allergy or intolerance condition (e.g.,
   * 'Latex allergy'), or a negated/excluded code for a specific substance or class
   * (e.g., 'No latex allergy') or a general or categorical negated statement
   * (e.g.,  'No known allergy', 'No known drug allergies').  Note: the substance
   * for a specific reaction may be different from the substance identified as the
   * cause of the risk, but it must be consistent with it. For instance, it may be
   * a more specific substance (e.g. a brand medication) or a composite product
   * that includes the identified substance. It must be clinically safe to only
   * process the 'code' and ignore the 'reaction.substance'.  If a receiving system
   * is unable to confirm that AllergyIntolerance.reaction.substance falls within
   * the semantic scope of AllergyIntolerance.code, then the receiving system
   * should ignore AllergyIntolerance.reaction.substance.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The patient who has the allergy or intolerance. */
  patient: FHIRAllergyIntolerancepatient_patient_Union,
  /** The encounter when the allergy or intolerance was asserted. */
  encounter?: Maybe<FHIRAllergyIntoleranceencounter_encounter_Union>,
  /** Estimated or actual date,  date-time, or age when allergy or intolerance was identified. */
  onsetDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Estimated or actual date,  date-time, or age when allergy or intolerance was identified. */
  onsetAge?: Maybe<FHIRAge>,
  /** Estimated or actual date,  date-time, or age when allergy or intolerance was identified. */
  onsetPeriod?: Maybe<FHIRPeriod>,
  /** Estimated or actual date,  date-time, or age when allergy or intolerance was identified. */
  onsetRange?: Maybe<FHIRRange>,
  /** Estimated or actual date,  date-time, or age when allergy or intolerance was identified. */
  onsetString?: Maybe<Scalars['String']>,
  /** 
 * The recordedDate represents when this particular AllergyIntolerance record was
   * created in the system, which is often a system-generated date.
 */
  recordedDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Individual who recorded the record and takes responsibility for its content. */
  recorder?: Maybe<FHIRAllergyIntolerancerecorder_recorder_Union>,
  /** The source of the information about the allergy that is recorded. */
  asserter?: Maybe<FHIRAllergyIntoleranceasserter_asserter_Union>,
  /** Represents the date and/or time of the last known occurrence of a reaction event. */
  lastOccurrence?: Maybe<Scalars['FHIRDateTime']>,
  /** Additional narrative about the propensity for the Adverse Reaction, not captured in other fields. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Details about each adverse reaction event linked to exposure to the identified substance. */
  reaction?: Maybe<Array<Maybe<FHIRAllergyIntolerancereaction>>>,
};

export enum FHIRAllergyIntolerance_Enum_schema {
  AllergyIntolerance = 'AllergyIntolerance'
}

/** The source of the information about the allergy that is recorded. */
export type FHIRAllergyIntoleranceasserter_asserter_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole;

/** The encounter when the allergy or intolerance was asserted. */
export type FHIRAllergyIntoleranceencounter_encounter_Union = FHIREncounter;

export type FHIRAllergyIntoleranceList = {
   __typename?: 'FHIRAllergyIntoleranceList',
  nodes?: Maybe<Array<Maybe<FHIRAllergyIntolerance>>>,
  listInfo?: Maybe<FHIRListInfo>,
};

/** The patient who has the allergy or intolerance. */
export type FHIRAllergyIntolerancepatient_patient_Union = FHIRPatient;

export type FHIRAllergyIntolerancereaction = {
   __typename?: 'FHIRAllergyIntolerancereaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identification of the specific substance (or pharmaceutical product)
   * considered to be responsible for the Adverse Reaction event. Note: the
   * substance for a specific reaction may be different from the substance
   * identified as the cause of the risk, but it must be consistent with it. For
   * instance, it may be a more specific substance (e.g. a brand medication) or a
   * composite product that includes the identified substance. It must be
   * clinically safe to only process the 'code' and ignore the
   * 'reaction.substance'.  If a receiving system is unable to confirm that
   * AllergyIntolerance.reaction.substance falls within the semantic scope of
   * AllergyIntolerance.code, then the receiving system should ignore
   * AllergyIntolerance.reaction.substance.
 */
  substance?: Maybe<FHIRCodeableConcept>,
  /** Clinical symptoms and/or signs that are observed or associated with the adverse reaction event. */
  manifestation?: Maybe<Array<FHIRCodeableConcept>>,
  /** Text description about the reaction as a whole, including details of the manifestation if required. */
  description?: Maybe<Scalars['String']>,
  /** Record of the date and/or time of the onset of the Reaction. */
  onset?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Clinical assessment of the severity of the reaction event as a whole,
   * potentially considering multiple different manifestations.
 */
  severity?: Maybe<Scalars['FHIRCode']>,
  /** Identification of the route by which the subject was exposed to the substance. */
  exposureRoute?: Maybe<FHIRCodeableConcept>,
  /** Additional text about the adverse reaction event not captured in other fields. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

/** Individual who recorded the record and takes responsibility for its content. */
export type FHIRAllergyIntolerancerecorder_recorder_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson;

/** 
 * Base StructureDefinition for Annotation Type: A  text note which also  contains
 * information about who made the statement and when.
 */
export type FHIRAnnotation = {
   __typename?: 'FHIRAnnotation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The individual responsible for making the annotation. */
  authorReference?: Maybe<FHIRAnnotationauthorReference_authorReference_Union>,
  /** The individual responsible for making the annotation. */
  authorString?: Maybe<Scalars['String']>,
  /** Indicates when this particular annotation was made. */
  time?: Maybe<Scalars['FHIRDateTime']>,
  /** The text of the annotation in markdown format. */
  text: Scalars['String'],
};

/** 
 * Base StructureDefinition for Annotation Type: A  text note which also  contains
 * information about who made the statement and when.
 */
export type FHIRAnnotation_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The individual responsible for making the annotation. */
  authorReference?: Maybe<Scalars['String']>,
  /** The individual responsible for making the annotation. */
  _authorString?: Maybe<FHIRElement_Input>,
  /** The individual responsible for making the annotation. */
  authorString?: Maybe<Scalars['String']>,
  /** Indicates when this particular annotation was made. */
  _time?: Maybe<FHIRElement_Input>,
  /** Indicates when this particular annotation was made. */
  time?: Maybe<Scalars['FHIRDateTime']>,
  /** The text of the annotation in markdown format. */
  _text?: Maybe<FHIRElement_Input>,
  /** The text of the annotation in markdown format. */
  text: Scalars['String'],
};

/** The individual responsible for making the annotation. */
export type FHIRAnnotationauthorReference_authorReference_Union = FHIRPractitioner | FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** 
 * A booking of a healthcare event among patient(s), practitioner(s), related
 * person(s) and/or device(s) for a specific date/time. This may result in one or
 * more Encounter(s).
 */
export type FHIRAppointment = {
   __typename?: 'FHIRAppointment',
  /** Type of resource */
  resourceType: FHIRAppointment_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * This records identifiers associated with this appointment concern that are
   * defined by business processes and/or used to refer to it when a direct URL
   * reference to the resource itself is not appropriate (e.g. in CDA documents, or
   * in written / printed documentation).
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The overall status of the Appointment. Each of the participants has their own
   * participation status which indicates their involvement in the process, however
   * this status indicates the shared status.
 */
  status: Scalars['FHIRCode'],
  /** 
 * The coded reason for the appointment being cancelled. This is often used in
   * reporting/billing/futher processing to determine if further actions are
   * required, or specific fees apply.
 */
  cancelationReason?: Maybe<FHIRCodeableConcept>,
  /** A broad categorization of the service that is to be performed during this appointment. */
  serviceCategory?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specific service that is to be performed during this appointment. */
  serviceType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specialty of a practitioner that would be required to perform the service requested in this appointment. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The style of appointment or patient that has been booked in the slot (not service type). */
  appointmentType?: Maybe<FHIRCodeableConcept>,
  /** The coded reason that this appointment is being scheduled. This is more clinical than administrative. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Reason the appointment has been scheduled to take place, as specified using
   * information from another resource. When the patient arrives and the encounter
   * begins it may be used as the admission diagnosis. The indication will
   * typically be a Condition (with other resources referenced in the
   * evidence.detail), or a Procedure.
 */
  reasonReference?: Maybe<Array<Maybe<FHIRAppointmentreasonReference_reasonReference_Union>>>,
  /** 
 * The priority of the appointment. Can be used to make informed decisions if
   * needing to re-prioritize appointments. (The iCal Standard specifies 0 as
   * undefined, 1 as highest, 9 as lowest priority).
 */
  priority?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * The brief description of the appointment as would be shown on a subject line
   * in a meeting request, or appointment list. Detailed or expanded information
   * should be put in the comment field.
 */
  description?: Maybe<Scalars['String']>,
  /** Additional information to support the appointment provided when making the appointment. */
  supportingInformation?: Maybe<Array<Maybe<FHIRAppointmentsupportingInformation_supportingInformation_Union>>>,
  /** Date/Time that the appointment is to take place. */
  start?: Maybe<Scalars['FHIRInstant']>,
  /** Date/Time that the appointment is to conclude. */
  end?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Number of minutes that the appointment is to take. This can be less than the
   * duration between the start and end times.  For example, where the actual time
   * of appointment is only an estimate or if a 30 minute appointment is being
   * requested, but any time would work.  Also, if there is, for example, a planned
   * 15 minute break in the middle of a long appointment, the duration may be 15
   * minutes less than the difference between the start and end.
 */
  minutesDuration?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The slots from the participants' schedules that will be filled by the appointment. */
  slot?: Maybe<Array<Maybe<FHIRAppointmentslot_slot_Union>>>,
  /** 
 * The date that this appointment was initially created. This could be different
   * to the meta.lastModified value on the initial entry, as this could have been
   * before the resource was created on the FHIR server, and should remain
   * unchanged over the lifespan of the appointment.
 */
  created?: Maybe<Scalars['FHIRDateTime']>,
  /** Additional comments about the appointment. */
  comment?: Maybe<Scalars['String']>,
  /** 
 * While Appointment.comment contains information for internal use,
   * Appointment.patientInstructions is used to capture patient facing information
   * about the Appointment (e.g. please bring your referral or fast from 8pm night before).
 */
  patientInstruction?: Maybe<Scalars['String']>,
  /** The service request this appointment is allocated to assess (e.g. incoming referral or procedure request). */
  basedOn?: Maybe<Array<Maybe<FHIRAppointmentbasedOn_basedOn_Union>>>,
  /** List of participants involved in the appointment. */
  participant?: Maybe<Array<FHIRAppointmentparticipant>>,
  /** 
 * A set of date ranges (potentially including times) that the appointment is
   * preferred to be scheduled within.  The duration (usually in minutes) could
   * also be provided to indicate the length of the appointment to fill and
   * populate the start/end times for the actual allocated time. However, in other
   * situations the duration may be calculated by the scheduling system.
 */
  requestedPeriod?: Maybe<Array<Maybe<FHIRPeriod>>>,
};

export enum FHIRAppointment_Enum_schema {
  Appointment = 'Appointment'
}

/** The service request this appointment is allocated to assess (e.g. incoming referral or procedure request). */
export type FHIRAppointmentbasedOn_basedOn_Union = FHIRServiceRequest;

export type FHIRAppointmentparticipant = {
   __typename?: 'FHIRAppointmentparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Role of participant in the appointment. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A Person, Location/HealthcareService or Device that is participating in the appointment. */
  actor?: Maybe<FHIRAppointmentparticipantactor_actor_Union>,
  /** 
 * Whether this participant is required to be present at the meeting. This covers
   * a use-case where two doctors need to meet to discuss the results for a
   * specific patient, and the patient is not required to be present.
 */
  required?: Maybe<Scalars['FHIRCode']>,
  /** Participation status of the actor. */
  status: Scalars['FHIRCode'],
  /** Participation period of the actor. */
  period?: Maybe<FHIRPeriod>,
};

/** A Person, Location/HealthcareService or Device that is participating in the appointment. */
export type FHIRAppointmentparticipantactor_actor_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRDevice | FHIRHealthcareService | FHIRLocation;

/** 
 * Reason the appointment has been scheduled to take place, as specified using
 * information from another resource. When the patient arrives and the encounter
 * begins it may be used as the admission diagnosis. The indication will typically
 * be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
 */
export type FHIRAppointmentreasonReference_reasonReference_Union = FHIRCondition | FHIRProcedure | FHIRObservation | FHIRImmunizationRecommendation;

/** A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
export type FHIRAppointmentResponse = {
   __typename?: 'FHIRAppointmentResponse',
  /** Type of resource */
  resourceType: FHIRAppointmentResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * This records identifiers associated with this appointment response concern
   * that are defined by business processes and/ or used to refer to it when a
   * direct URL reference to the resource itself is not appropriate.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Appointment that this response is replying to. */
  appointment: FHIRAppointmentResponseappointment_appointment_Union,
  /** Date/Time that the appointment is to take place, or requested new start time. */
  start?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * This may be either the same as the appointment request to confirm the details
   * of the appointment, or alternately a new time to request a re-negotiation of the end time.
 */
  end?: Maybe<Scalars['FHIRInstant']>,
  /** Role of participant in the appointment. */
  participantType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A Person, Location, HealthcareService, or Device that is participating in the appointment. */
  actor?: Maybe<FHIRAppointmentResponseactor_actor_Union>,
  /** 
 * Participation status of the participant. When the status is declined or
   * tentative if the start/end times are different to the appointment, then these
   * times should be interpreted as a requested time change. When the status is
   * accepted, the times can either be the time of the appointment (as a
   * confirmation of the time) or can be empty.
 */
  participantStatus: Scalars['FHIRCode'],
  /** Additional comments about the appointment. */
  comment?: Maybe<Scalars['String']>,
};

export enum FHIRAppointmentResponse_Enum_schema {
  AppointmentResponse = 'AppointmentResponse'
}

/** A Person, Location, HealthcareService, or Device that is participating in the appointment. */
export type FHIRAppointmentResponseactor_actor_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRDevice | FHIRHealthcareService | FHIRLocation;

/** Appointment that this response is replying to. */
export type FHIRAppointmentResponseappointment_appointment_Union = FHIRAppointment;

/** The slots from the participants' schedules that will be filled by the appointment. */
export type FHIRAppointmentslot_slot_Union = FHIRSlot;

/** Additional information to support the appointment provided when making the appointment. */
export type FHIRAppointmentsupportingInformation_supportingInformation_Union = FHIRResource;

/** Base StructureDefinition for Attachment Type: For referring to data content defined in other formats. */
export type FHIRAttachment = {
   __typename?: 'FHIRAttachment',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifies the type of the data in the attachment and allows a method to be
   * chosen to interpret or render the data. Includes mime type parameters such as
   * charset where appropriate.
 */
  contentType?: Maybe<Scalars['FHIRCode']>,
  /** The human language of the content. The value can be any valid value according to BCP 47. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** The actual data of the attachment - a sequence of bytes, base64 encoded. */
  data?: Maybe<Scalars['FHIRBase64Binary']>,
  /** A location where the data can be accessed. */
  url?: Maybe<Scalars['FHIRUrl']>,
  /** The number of bytes of data that make up this attachment (before base64 encoding, if that is done). */
  size?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The calculated hash of the data using SHA-1. Represented using base64. */
  hash?: Maybe<Scalars['FHIRBase64Binary']>,
  /** A label or set of text to display in place of the data. */
  title?: Maybe<Scalars['String']>,
  /** The date that the attachment was first created. */
  creation?: Maybe<Scalars['FHIRDateTime']>,
};

/** Base StructureDefinition for Attachment Type: For referring to data content defined in other formats. */
export type FHIRAttachment_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * Identifies the type of the data in the attachment and allows a method to be
   * chosen to interpret or render the data. Includes mime type parameters such as
   * charset where appropriate.
 */
  _contentType?: Maybe<FHIRElement_Input>,
  /** 
 * Identifies the type of the data in the attachment and allows a method to be
   * chosen to interpret or render the data. Includes mime type parameters such as
   * charset where appropriate.
 */
  contentType?: Maybe<Scalars['FHIRCode']>,
  /** The human language of the content. The value can be any valid value according to BCP 47. */
  _language?: Maybe<FHIRElement_Input>,
  /** The human language of the content. The value can be any valid value according to BCP 47. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** The actual data of the attachment - a sequence of bytes, base64 encoded. */
  _data?: Maybe<FHIRElement_Input>,
  /** The actual data of the attachment - a sequence of bytes, base64 encoded. */
  data?: Maybe<Scalars['FHIRBase64Binary']>,
  /** A location where the data can be accessed. */
  _url?: Maybe<FHIRElement_Input>,
  /** A location where the data can be accessed. */
  url?: Maybe<Scalars['FHIRUrl']>,
  /** The number of bytes of data that make up this attachment (before base64 encoding, if that is done). */
  _size?: Maybe<FHIRElement_Input>,
  /** The number of bytes of data that make up this attachment (before base64 encoding, if that is done). */
  size?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The calculated hash of the data using SHA-1. Represented using base64. */
  _hash?: Maybe<FHIRElement_Input>,
  /** The calculated hash of the data using SHA-1. Represented using base64. */
  hash?: Maybe<Scalars['FHIRBase64Binary']>,
  /** A label or set of text to display in place of the data. */
  _title?: Maybe<FHIRElement_Input>,
  /** A label or set of text to display in place of the data. */
  title?: Maybe<Scalars['String']>,
  /** The date that the attachment was first created. */
  _creation?: Maybe<FHIRElement_Input>,
  /** The date that the attachment was first created. */
  creation?: Maybe<Scalars['FHIRDateTime']>,
};

/** 
 * A record of an event made for purposes of maintaining a security log. Typical
 * uses include detection of intrusion attempts and monitoring for inappropriate usage.
 */
export type FHIRAuditEvent = {
   __typename?: 'FHIRAuditEvent',
  /** Type of resource */
  resourceType: FHIRAuditEvent_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifier for a family of the event.  For example, a menu item, program,
   * rule, policy, function code, application name or URL. It identifies the
   * performed function.
 */
  type: FHIRCoding,
  /** Identifier for the category of event. */
  subtype?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** Indicator for type of action performed during the event that generated the audit. */
  action?: Maybe<Scalars['FHIRCode']>,
  /** The period during which the activity occurred. */
  period?: Maybe<FHIRPeriod>,
  /** The time when the event was recorded. */
  recorded: Scalars['FHIRInstant'],
  /** Indicates whether the event succeeded or failed. */
  outcome?: Maybe<Scalars['FHIRCode']>,
  /** A free text description of the outcome of the event. */
  outcomeDesc?: Maybe<Scalars['String']>,
  /** The purposeOfUse (reason) that was used during the event being recorded. */
  purposeOfEvent?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An actor taking an active role in the event or activity that is logged. */
  agent?: Maybe<Array<FHIRAuditEventagent>>,
  /** The system that is reporting the event. */
  source: FHIRAuditEventsource,
  /** Specific instances of data or objects that have been accessed. */
  entity?: Maybe<Array<Maybe<FHIRAuditEvententity>>>,
};

export enum FHIRAuditEvent_Enum_schema {
  AuditEvent = 'AuditEvent'
}

export type FHIRAuditEventagent = {
   __typename?: 'FHIRAuditEventagent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specification of the participation type the user plays when performing the event. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * The security role that the user was acting under, that come from local codes
   * defined by the access control security system (e.g. RBAC, ABAC) used in the local context.
 */
  role?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Reference to who this agent is that was involved in the event. */
  who?: Maybe<FHIRAuditEventagentwho_who_Union>,
  /** 
 * Alternative agent Identifier. For a human, this should be a user identifier
   * text string from authentication system. This identifier would be one known to
   * a common authentication system (e.g. single sign-on), if available.
 */
  altId?: Maybe<Scalars['String']>,
  /** Human-meaningful name for the agent. */
  name?: Maybe<Scalars['String']>,
  /** Indicator that the user is or is not the requestor, or initiator, for the event being audited. */
  requestor: Scalars['Boolean'],
  /** Where the event occurred. */
  location?: Maybe<FHIRAuditEventagentlocation_location_Union>,
  /** 
 * The policy or plan that authorized the activity being recorded. Typically, a
   * single activity may have multiple applicable policies, such as patient
   * consent, guarantor funding, etc. The policy would also indicate the security token used.
 */
  policy?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** Type of media involved. Used when the event is about exporting/importing onto media. */
  media?: Maybe<FHIRCoding>,
  /** Logical network location for application activity, if the activity has a network location. */
  network?: Maybe<FHIRAuditEventagentnetwork>,
  /** The reason (purpose of use), specific to this agent, that was used during the event being recorded. */
  purposeOfUse?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

/** Where the event occurred. */
export type FHIRAuditEventagentlocation_location_Union = FHIRLocation;

export type FHIRAuditEventagentnetwork = {
   __typename?: 'FHIRAuditEventagentnetwork',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An identifier for the network access point of the user device for the audit event. */
  address?: Maybe<Scalars['String']>,
  /** An identifier for the type of network access point that originated the audit event. */
  type?: Maybe<Scalars['FHIRCode']>,
};

/** Reference to who this agent is that was involved in the event. */
export type FHIRAuditEventagentwho_who_Union = FHIRPractitionerRole | FHIRPractitioner | FHIROrganization | FHIRDevice | FHIRPatient | FHIRRelatedPerson;

export type FHIRAuditEvententity = {
   __typename?: 'FHIRAuditEvententity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies a specific instance of the entity. The reference should be version specific. */
  what?: Maybe<FHIRAuditEvententitywhat_what_Union>,
  /** The type of the object that was involved in this audit event. */
  type?: Maybe<FHIRCoding>,
  /** Code representing the role the entity played in the event being audited. */
  role?: Maybe<FHIRCoding>,
  /** Identifier for the data life-cycle stage for the entity. */
  lifecycle?: Maybe<FHIRCoding>,
  /** Security labels for the identified entity. */
  securityLabel?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** A name of the entity in the audit event. */
  name?: Maybe<Scalars['String']>,
  /** Text that describes the entity in more detail. */
  description?: Maybe<Scalars['String']>,
  /** The query parameters for a query-type entities. */
  query?: Maybe<Scalars['FHIRBase64Binary']>,
  /** Tagged value pairs for conveying additional information about the entity. */
  detail?: Maybe<Array<Maybe<FHIRAuditEvententitydetail>>>,
};

export type FHIRAuditEvententitydetail = {
   __typename?: 'FHIRAuditEvententitydetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of extra detail provided in the value. */
  type: Scalars['String'],
  /** The  value of the extra detail. */
  valueString: Scalars['String'],
  /** The  value of the extra detail. */
  valueBase64Binary: Scalars['FHIRBase64Binary'],
};

/** Identifies a specific instance of the entity. The reference should be version specific. */
export type FHIRAuditEvententitywhat_what_Union = FHIRResource;

export type FHIRAuditEventsource = {
   __typename?: 'FHIRAuditEventsource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Logical source location within the healthcare enterprise network.  For
   * example, a hospital or other provider location within a multi-entity provider group.
 */
  site?: Maybe<Scalars['String']>,
  /** Identifier of the source where the event was detected. */
  observer: FHIRAuditEventsourceobserver_observer_Union,
  /** Code specifying the type of source where event originated. */
  type?: Maybe<Array<Maybe<FHIRCoding>>>,
};

/** Identifier of the source where the event was detected. */
export type FHIRAuditEventsourceobserver_observer_Union = FHIRPractitionerRole | FHIRPractitioner | FHIROrganization | FHIRDevice | FHIRPatient | FHIRRelatedPerson;


/** 
 * Basic is used for handling concepts not yet defined in FHIR, narrative-only
 * resources that don't map to an existing resource, and custom resources not
 * appropriate for inclusion in the FHIR specification.
 */
export type FHIRBasic = {
   __typename?: 'FHIRBasic',
  /** Type of resource */
  resourceType: FHIRBasic_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier assigned to the resource for business purposes, outside the context of FHIR. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Identifies the 'type' of resource - equivalent to the resource name for other resources. */
  code: FHIRCodeableConcept,
  /** Identifies the patient, practitioner, device or any other resource that is the 'focus' of this resource. */
  subject?: Maybe<FHIRBasicsubject_subject_Union>,
  /** Identifies when the resource was first created. */
  created?: Maybe<Scalars['FHIRDate']>,
  /** Indicates who was responsible for creating the resource instance. */
  author?: Maybe<FHIRBasicauthor_author_Union>,
};

export enum FHIRBasic_Enum_schema {
  Basic = 'Basic'
}

/** Indicates who was responsible for creating the resource instance. */
export type FHIRBasicauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** Identifies the patient, practitioner, device or any other resource that is the 'focus' of this resource. */
export type FHIRBasicsubject_subject_Union = FHIRResource;

/** 
 * A resource that represents the data of a single raw artifact as digital content
 * accessible in its native format.  A Binary resource can contain any content,
 * whether text, image, pdf, zip archive, etc.
 */
export type FHIRBinary = {
   __typename?: 'FHIRBinary',
  /** Type of resource */
  resourceType: FHIRBinary_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** MimeType of the binary content represented as a standard MimeType (BCP 13). */
  contentType: Scalars['FHIRCode'],
  /** 
 * This element identifies another resource that can be used as a proxy of the
   * security sensitivity to use when deciding and enforcing access control rules
   * for the Binary resource. Given that the Binary resource contains very few
   * elements that can be used to determine the sensitivity of the data and
   * relationships to individuals, the referenced resource stands in as a proxy
   * equivalent for this purpose. This referenced resource may be related to the
   * Binary (e.g. Media, DocumentReference), or may be some non-related Resource
   * purely as a security proxy. E.g. to identify that the binary resource relates
   * to a patient, and access should only be granted to applications that have
   * access to the patient.
 */
  securityContext?: Maybe<FHIRBinarysecurityContext_securityContext_Union>,
  /** The actual content, base64 encoded. */
  data?: Maybe<Scalars['FHIRBase64Binary']>,
};

export enum FHIRBinary_Enum_schema {
  Binary = 'Binary'
}

/** 
 * This element identifies another resource that can be used as a proxy of the
 * security sensitivity to use when deciding and enforcing access control rules for
 * the Binary resource. Given that the Binary resource contains very few elements
 * that can be used to determine the sensitivity of the data and relationships to
 * individuals, the referenced resource stands in as a proxy equivalent for this
 * purpose. This referenced resource may be related to the Binary (e.g. Media,
 * DocumentReference), or may be some non-related Resource purely as a security
 * proxy. E.g. to identify that the binary resource relates to a patient, and
 * access should only be granted to applications that have access to the patient.
 */
export type FHIRBinarysecurityContext_securityContext_Union = FHIRResource;

/** 
 * A material substance originating from a biological entity intended to be
 * transplanted or infused into another (possibly the same) biological entity.
 */
export type FHIRBiologicallyDerivedProduct = {
   __typename?: 'FHIRBiologicallyDerivedProduct',
  /** Type of resource */
  resourceType: FHIRBiologicallyDerivedProduct_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * This records identifiers associated with this biologically derived product
   * instance that are defined by business processes and/or used to refer to it
   * when a direct URL reference to the resource itself is not appropriate (e.g. in
   * CDA documents, or in written / printed documentation).
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Broad category of this product. */
  productCategory?: Maybe<Scalars['FHIRCode']>,
  /** A code that identifies the kind of this biologically derived product (SNOMED Ctcode). */
  productCode?: Maybe<FHIRCodeableConcept>,
  /** Whether the product is currently available. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** Procedure request to obtain this biologically derived product. */
  request?: Maybe<Array<Maybe<FHIRBiologicallyDerivedProductrequest_request_Union>>>,
  /** Number of discrete units within this product. */
  quantity?: Maybe<Scalars['Int']>,
  /** Parent product (if any). */
  parent?: Maybe<Array<Maybe<FHIRBiologicallyDerivedProductparent_parent_Union>>>,
  /** How this product was collected. */
  collection?: Maybe<FHIRBiologicallyDerivedProductcollection>,
  /** 
 * Any processing of the product during collection that does not change the
   * fundamental nature of the product. For example adding anti-coagulants during
   * the collection of Peripheral Blood Stem Cells.
 */
  processing?: Maybe<Array<Maybe<FHIRBiologicallyDerivedProductprocessing>>>,
  /** 
 * Any manipulation of product post-collection that is intended to alter the
   * product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral
   * Blood Stem Cells to make it more suitable for infusion.
 */
  manipulation?: Maybe<FHIRBiologicallyDerivedProductmanipulation>,
  /** Product storage. */
  storage?: Maybe<Array<Maybe<FHIRBiologicallyDerivedProductstorage>>>,
};

export enum FHIRBiologicallyDerivedProduct_Enum_schema {
  BiologicallyDerivedProduct = 'BiologicallyDerivedProduct'
}

export type FHIRBiologicallyDerivedProductcollection = {
   __typename?: 'FHIRBiologicallyDerivedProductcollection',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Healthcare professional who is performing the collection. */
  collector?: Maybe<FHIRBiologicallyDerivedProductcollectioncollector_collector_Union>,
  /** 
 * The patient or entity, such as a hospital or vendor in the case of a
   * processed/manipulated/manufactured product, providing the product.
 */
  source?: Maybe<FHIRBiologicallyDerivedProductcollectionsource_source_Union>,
  /** Time of product collection. */
  collectedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Time of product collection. */
  collectedPeriod?: Maybe<FHIRPeriod>,
};

/** Healthcare professional who is performing the collection. */
export type FHIRBiologicallyDerivedProductcollectioncollector_collector_Union = FHIRPractitioner | FHIRPractitionerRole;

/** 
 * The patient or entity, such as a hospital or vendor in the case of a
 * processed/manipulated/manufactured product, providing the product.
 */
export type FHIRBiologicallyDerivedProductcollectionsource_source_Union = FHIRPatient | FHIROrganization;

export type FHIRBiologicallyDerivedProductmanipulation = {
   __typename?: 'FHIRBiologicallyDerivedProductmanipulation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Description of manipulation. */
  description?: Maybe<Scalars['String']>,
  /** Time of manipulation. */
  timeDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Time of manipulation. */
  timePeriod?: Maybe<FHIRPeriod>,
};

/** Parent product (if any). */
export type FHIRBiologicallyDerivedProductparent_parent_Union = FHIRBiologicallyDerivedProduct;

export type FHIRBiologicallyDerivedProductprocessing = {
   __typename?: 'FHIRBiologicallyDerivedProductprocessing',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Description of of processing. */
  description?: Maybe<Scalars['String']>,
  /** Procesing code. */
  procedure?: Maybe<FHIRCodeableConcept>,
  /** Substance added during processing. */
  additive?: Maybe<FHIRBiologicallyDerivedProductprocessingadditive_additive_Union>,
  /** Time of processing. */
  timeDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Time of processing. */
  timePeriod?: Maybe<FHIRPeriod>,
};

/** Substance added during processing. */
export type FHIRBiologicallyDerivedProductprocessingadditive_additive_Union = FHIRSubstance;

/** Procedure request to obtain this biologically derived product. */
export type FHIRBiologicallyDerivedProductrequest_request_Union = FHIRServiceRequest;

export type FHIRBiologicallyDerivedProductstorage = {
   __typename?: 'FHIRBiologicallyDerivedProductstorage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Description of storage. */
  description?: Maybe<Scalars['String']>,
  /** Storage temperature. */
  temperature?: Maybe<Scalars['Float']>,
  /** Temperature scale used. */
  scale?: Maybe<Scalars['FHIRCode']>,
  /** Storage timeperiod. */
  duration?: Maybe<FHIRPeriod>,
};

/** 
 * Record details about an anatomical structure.  This resource may be used when a
 * coded concept does not provide the necessary detail needed for the use case.
 */
export type FHIRBodyStructure = {
   __typename?: 'FHIRBodyStructure',
  /** Type of resource */
  resourceType: FHIRBodyStructure_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for this instance of the anatomical structure. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this body site is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** 
 * The kind of structure being represented by the body structure at
   * `BodyStructure.location`.  This can define both normal and abnormal morphologies.
 */
  morphology?: Maybe<FHIRCodeableConcept>,
  /** The anatomical location or region of the specimen, lesion, or body structure. */
  location?: Maybe<FHIRCodeableConcept>,
  /** 
 * Qualifier to refine the anatomical location.  These include qualifiers for
   * laterality, relative location, directionality, number, and plane.
 */
  locationQualifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A summary, characterization or explanation of the body structure. */
  description?: Maybe<Scalars['String']>,
  /** Image or images used to identify a location. */
  image?: Maybe<Array<Maybe<FHIRAttachment>>>,
  /** The person to which the body site belongs. */
  patient: FHIRBodyStructurepatient_patient_Union,
};

export enum FHIRBodyStructure_Enum_schema {
  BodyStructure = 'BodyStructure'
}

/** The person to which the body site belongs. */
export type FHIRBodyStructurepatient_patient_Union = FHIRPatient;

/** A container for a collection of resources. */
export type FHIRBundle = {
   __typename?: 'FHIRBundle',
  /** Type of resource */
  resourceType: FHIRBundle_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** A persistent identifier for the bundle that won't change as a bundle is copied from server to server. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Indicates the purpose of this bundle - how it is intended to be used. */
  type: Scalars['FHIRCode'],
  /** The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle. */
  timestamp?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * If a set of search matches, this is the total number of entries of type
   * 'match' across all pages in the search.  It does not include search.mode =
   * 'include' or 'outcome' entries and it does not provide a count of the number
   * of entries in the Bundle.
 */
  total?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** A series of links that provide context to this bundle. */
  link?: Maybe<Array<Maybe<FHIRBundlelink>>>,
  /** 
 * An entry in a bundle resource - will either contain a resource or information
   * about a resource (transactions and history only).
 */
  entry?: Maybe<Array<Maybe<FHIRBundleentry>>>,
  /** Digital Signature - base64 encoded. XML-DSig or a JWT. */
  signature?: Maybe<FHIRSignature>,
};

export enum FHIRBundle_Enum_schema {
  Bundle = 'Bundle'
}

export type FHIRBundleentry = {
   __typename?: 'FHIRBundleentry',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id
   * in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be
   * version-independent URL consistent with the Resource.id. The fullUrl is a
   * version independent reference to the resource. The fullUrl element SHALL have
   * a value except that:  * fullUrl can be empty on a POST (although it does not
   * need to when specifying a temporary id for reference in the bundle) * Results
   * from operations might involve resources that are not identified.
 */
  fullUrl?: Maybe<Scalars['FHIRUri']>,
  /** The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type. */
  resource?: Maybe<FHIRResourceList>,
  /** Information about the search process that lead to the creation of this entry. */
  search?: Maybe<FHIRBundleentrysearch>,
  /** 
 * Additional information about how this entry should be processed as part of a
   * transaction or batch.  For history, it shows how the entry was processed to
   * create the version contained in the entry.
 */
  request?: Maybe<FHIRBundleentryrequest>,
  /** 
 * Indicates the results of processing the corresponding 'request' entry in the
   * batch or transaction being responded to or what the results of an operation
   * where when returning history.
 */
  response?: Maybe<FHIRBundleentryresponse>,
};

export type FHIRBundleentryrequest = {
   __typename?: 'FHIRBundleentryrequest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * In a transaction or batch, this is the HTTP action to be executed for this
   * entry. In a history bundle, this indicates the HTTP action that occurred.
 */
  method: Scalars['FHIRCode'],
  /** The URL for this entry, relative to the root (the address to which the request is posted). */
  url: Scalars['FHIRUri'],
  /** 
 * If the ETag values match, return a 304 Not Modified status. See the API
   * documentation for ['Conditional Read'](http.html#cread).
 */
  ifNoneMatch?: Maybe<Scalars['String']>,
  /** 
 * Only perform the operation if the last updated date matches. See the API
   * documentation for ['Conditional Read'](http.html#cread).
 */
  ifModifiedSince?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Only perform the operation if the Etag value matches. For more information,
   * see the API section ['Managing Resource Contention'](http.html#concurrency).
 */
  ifMatch?: Maybe<Scalars['String']>,
  /** 
 * Instruct the server not to perform the create if a specified resource already
   * exists. For further information, see the API documentation for ['Conditional
   * Create'](http.html#ccreate). This is just the query portion of the URL - what
   * follows the '?' (not including the '?').
 */
  ifNoneExist?: Maybe<Scalars['String']>,
};

export type FHIRBundleentryresponse = {
   __typename?: 'FHIRBundleentryresponse',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The status code returned by processing this entry. The status SHALL start with
   * a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description
   * associated with the status code.
 */
  status: Scalars['String'],
  /** The location header created by processing this operation, populated if the operation returns a location. */
  location?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The Etag for the resource, if the operation for the entry produced a versioned
   * resource (see [Resource Metadata and Versioning](http.html#versioning) and
   * [Managing Resource Contention](http.html#concurrency)).
 */
  etag?: Maybe<Scalars['String']>,
  /** The date/time that the resource was modified on the server. */
  lastModified?: Maybe<Scalars['FHIRInstant']>,
  /** An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction. */
  outcome?: Maybe<FHIRResourceList>,
};

export type FHIRBundleentrysearch = {
   __typename?: 'FHIRBundleentrysearch',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Why this entry is in the result set - whether it's included as a match or
   * because of an _include requirement, or to convey information or warning
   * information about the search process.
 */
  mode?: Maybe<Scalars['FHIRCode']>,
  /** When searching, the server's search ranking score for the entry. */
  score?: Maybe<Scalars['Float']>,
};

export type FHIRBundlelink = {
   __typename?: 'FHIRBundlelink',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1). */
  relation: Scalars['String'],
  /** The reference details for the link. */
  url: Scalars['FHIRUri'],
};


/** 
 * A Capability Statement documents a set of capabilities (behaviors) of a FHIR
 * Server for a particular version of FHIR that may be used as a statement of
 * actual server functionality or a statement of required or desired server
 * implementation.
 */
export type FHIRCapabilityStatement = {
   __typename?: 'FHIRCapabilityStatement',
  /** Type of resource */
  resourceType: FHIRCapabilityStatement_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this capability statement when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this capability
   * statement is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the capability statement is stored on
   * different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The identifier that is used to identify this version of the capability
   * statement when it is referenced in a specification, model, design or instance.
   * This is an arbitrary value managed by the capability statement author and is
   * not expected to be globally unique. For example, it might be a timestamp (e.g.
   * yyyymmdd) if a managed version is not available. There is also no expectation
   * that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the capability statement. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the capability statement. */
  title?: Maybe<Scalars['String']>,
  /** The status of this capability statement. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this capability statement is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the capability statement was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the capability statement changes.
 */
  date: Scalars['FHIRDateTime'],
  /** The name of the organization or individual that published the capability statement. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** 
 * A free text natural language description of the capability statement from a
   * consumer's perspective. Typically, this is used when the capability statement
   * describes a desired rather than an actual solution, for example as a formal
   * expression of requirements as part of an RFP.
 */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate capability
   * statement instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the capability statement is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this capability statement is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the capability statement and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the capability statement.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The way that this statement is intended to be used, to describe an actual
   * running instance of software, a particular product (kind, not instance of
   * software) or a class of implementation (e.g. a desired purchase).
 */
  kind: Scalars['FHIRCode'],
  /** 
 * Reference to a canonical URL of another CapabilityStatement that this software
   * implements. This capability statement is a published API description that
   * corresponds to a business service. The server may actually implement a subset
   * of the capability statement it claims to implement, so the capability
   * statement must specify the full capability details.
 */
  instantiates?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Reference to a canonical URL of another CapabilityStatement that this software
   * adds to. The capability statement automatically includes everything in the
   * other statement, and it is not duplicated, though the server may repeat the
   * same resources, interactions and operations to add additional details to them.
 */
  imports?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Software that is covered by this capability statement.  It is used when the
   * capability statement describes the capabilities of a particular software
   * version, independent of an installation.
 */
  software?: Maybe<FHIRCapabilityStatementsoftware>,
  /** 
 * Identifies a specific implementation instance that is described by the
   * capability statement - i.e. a particular installation, rather than the
   * capabilities of a software program.
 */
  implementation?: Maybe<FHIRCapabilityStatementimplementation>,
  /** 
 * The version of the FHIR specification that this CapabilityStatement describes
   * (which SHALL be the same as the FHIR version of the CapabilityStatement
   * itself). There is no default value.
 */
  fhirVersion: Scalars['FHIRCode'],
  /** A list of the formats supported by this implementation using their content types. */
  format?: Maybe<Array<Scalars['FHIRCode']>>,
  /** A list of the patch formats supported by this implementation using their content types. */
  patchFormat?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** A list of implementation guides that the server does (or should) support in their entirety. */
  implementationGuide?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** A definition of the restful capabilities of the solution, if any. */
  rest?: Maybe<Array<Maybe<FHIRCapabilityStatementrest>>>,
  /** A description of the messaging capabilities of the solution. */
  messaging?: Maybe<Array<Maybe<FHIRCapabilityStatementmessaging>>>,
  /** A document definition. */
  document?: Maybe<Array<Maybe<FHIRCapabilityStatementdocument>>>,
};

export enum FHIRCapabilityStatement_Enum_schema {
  CapabilityStatement = 'CapabilityStatement'
}

export type FHIRCapabilityStatementdocument = {
   __typename?: 'FHIRCapabilityStatementdocument',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Mode of this document declaration - whether an application is a producer or consumer. */
  mode: Scalars['FHIRCode'],
  /** 
 * A description of how the application supports or uses the specified document
   * profile.  For example, when documents are created, what action is taken with
   * consumed documents, etc.
 */
  documentation?: Maybe<Scalars['String']>,
  /** A profile on the document Bundle that constrains which resources are present, and their contents. */
  profile: Scalars['FHIRCanonical'],
};

export type FHIRCapabilityStatementimplementation = {
   __typename?: 'FHIRCapabilityStatementimplementation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Information about the specific installation that this capability statement relates to. */
  description: Scalars['String'],
  /** 
 * An absolute base URL for the implementation.  This forms the base for REST
   * interfaces as well as the mailbox and document interfaces.
 */
  url?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * The organization responsible for the management of the instance and oversight
   * of the data on the server at the specified URL.
 */
  custodian?: Maybe<FHIRCapabilityStatementimplementationcustodian_custodian_Union>,
};

/** 
 * The organization responsible for the management of the instance and oversight of
 * the data on the server at the specified URL.
 */
export type FHIRCapabilityStatementimplementationcustodian_custodian_Union = FHIROrganization;

export type FHIRCapabilityStatementmessaging = {
   __typename?: 'FHIRCapabilityStatementmessaging',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An endpoint (network accessible address) to which messages and/or replies are to be sent. */
  endpoint?: Maybe<Array<Maybe<FHIRCapabilityStatementmessagingendpoint>>>,
  /** 
 * Length if the receiver's reliable messaging cache in minutes (if a receiver)
   * or how long the cache length on the receiver should be (if a sender).
 */
  reliableCache?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Documentation about the system's messaging capabilities for this endpoint not
   * otherwise documented by the capability statement.  For example, the process
   * for becoming an authorized messaging exchange partner.
 */
  documentation?: Maybe<Scalars['String']>,
  /** References to message definitions for messages this system can send or receive. */
  supportedMessage?: Maybe<Array<Maybe<FHIRCapabilityStatementmessagingsupportedMessage>>>,
};

export type FHIRCapabilityStatementmessagingendpoint = {
   __typename?: 'FHIRCapabilityStatementmessagingendpoint',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A list of the messaging transport protocol(s) identifiers, supported by this endpoint. */
  protocol: FHIRCoding,
  /** 
 * The network address of the endpoint. For solutions that do not use network
   * addresses for routing, it can be just an identifier.
 */
  address: Scalars['FHIRUrl'],
};

export type FHIRCapabilityStatementmessagingsupportedMessage = {
   __typename?: 'FHIRCapabilityStatementmessagingsupportedMessage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The mode of this event declaration - whether application is sender or receiver. */
  mode: Scalars['FHIRCode'],
  /** Points to a message definition that identifies the messaging event, message structure, allowed responses, etc. */
  definition: Scalars['FHIRCanonical'],
};

export type FHIRCapabilityStatementrest = {
   __typename?: 'FHIRCapabilityStatementrest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies whether this portion of the statement is describing the ability to initiate or receive restful operations. */
  mode: Scalars['FHIRCode'],
  /** Information about the system's restful capabilities that apply across all applications, such as security. */
  documentation?: Maybe<Scalars['String']>,
  /** Information about security implementation from an interface perspective - what a client needs to know. */
  security?: Maybe<FHIRCapabilityStatementrestsecurity>,
  /** A specification of the restful capabilities of the solution for a specific resource type. */
  resource?: Maybe<Array<Maybe<FHIRCapabilityStatementrestresource>>>,
  /** A specification of restful operations supported by the system. */
  interaction?: Maybe<Array<Maybe<FHIRCapabilityStatementrestinteraction>>>,
  /** 
 * An absolute URI which is a reference to the definition of a compartment that
   * the system supports. The reference is to a CompartmentDefinition resource by
   * its canonical URL .
 */
  compartment?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
};

export type FHIRCapabilityStatementrestinteraction = {
   __typename?: 'FHIRCapabilityStatementrestinteraction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A coded identifier of the operation, supported by the system. */
  code: Scalars['FHIRCode'],
  /** 
 * Guidance specific to the implementation of this operation, such as limitations
   * on the kind of transactions allowed, or information about system wide search
   * is implemented.
 */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRCapabilityStatementrestresource = {
   __typename?: 'FHIRCapabilityStatementrestresource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A type of resource exposed via the restful interface. */
  type: Scalars['FHIRCode'],
  /** 
 * A specification of the profile that describes the solution's overall support
   * for the resource, including any constraints on cardinality, bindings, lengths
   * or other limitations. See further discussion in [Using
   * Profiles](profiling.html#profile-uses).
 */
  profile?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * A list of profiles that represent different use cases supported by the system.
   * For a server, 'supported by the system' means the system hosts/produces a set
   * of resources that are conformant to a particular profile, and allows clients
   * that use its services to search using this profile and to find appropriate
   * data. For a client, it means the system will search by this profile and
   * process data according to the guidance implicit in the profile. See further
   * discussion in [Using Profiles](profiling.html#profile-uses).
 */
  supportedProfile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** Additional information about the resource type used by the system. */
  documentation?: Maybe<Scalars['String']>,
  /** Identifies a restful operation supported by the solution. */
  interaction?: Maybe<Array<Maybe<FHIRCapabilityStatementrestresourceinteraction>>>,
  /** 
 * This field is set to no-version to specify that the system does not support
   * (server) or use (client) versioning for this resource type. If this has some
   * other value, the server must at least correctly track and populate the
   * versionId meta-property on resources. If the value is 'versioned-update', then
   * the server supports all the versioning features, including using e-tags for
   * version integrity in the API.
 */
  versioning?: Maybe<Scalars['FHIRCode']>,
  /** A flag for whether the server is able to return past versions as part of the vRead operation. */
  readHistory?: Maybe<Scalars['Boolean']>,
  /** 
 * A flag to indicate that the server allows or needs to allow the client to
   * create new identities on the server (that is, the client PUTs to a location
   * where there is no existing resource). Allowing this operation means that the
   * server allows the client to create new identities on the server.
 */
  updateCreate?: Maybe<Scalars['Boolean']>,
  /** A flag that indicates that the server supports conditional create. */
  conditionalCreate?: Maybe<Scalars['Boolean']>,
  /** A code that indicates how the server supports conditional read. */
  conditionalRead?: Maybe<Scalars['FHIRCode']>,
  /** A flag that indicates that the server supports conditional update. */
  conditionalUpdate?: Maybe<Scalars['Boolean']>,
  /** A code that indicates how the server supports conditional delete. */
  conditionalDelete?: Maybe<Scalars['FHIRCode']>,
  /** A set of flags that defines how references are supported. */
  referencePolicy?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** A list of _include values supported by the server. */
  searchInclude?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** A list of _revinclude (reverse include) values supported by the server. */
  searchRevInclude?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Search parameters for implementations to support and/or make use of - either
   * references to ones defined in the specification, or additional ones defined
   * for/by the implementation.
 */
  searchParam?: Maybe<Array<Maybe<FHIRCapabilityStatementrestresourcesearchParam>>>,
  /** 
 * Definition of an operation or a named query together with its parameters and
   * their meaning and type. Consult the definition of the operation for details
   * about how to invoke the operation, and the parameters.
 */
  operation?: Maybe<Array<Maybe<FHIRCapabilityStatementrestresourceoperation>>>,
};

export type FHIRCapabilityStatementrestresourceinteraction = {
   __typename?: 'FHIRCapabilityStatementrestresourceinteraction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Coded identifier of the operation, supported by the system resource. */
  code: Scalars['FHIRCode'],
  /** 
 * Guidance specific to the implementation of this operation, such as 'delete is
   * a logical delete' or 'updates are only allowed with version id' or 'creates
   * permitted from pre-authorized certificates only'.
 */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRCapabilityStatementrestresourceoperation = {
   __typename?: 'FHIRCapabilityStatementrestresourceoperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The name of the operation or query. For an operation, this is the name 
   * prefixed with $ and used in the URL. For a query, this is the name used in the
   * _query parameter when the query is called.
 */
  name: Scalars['String'],
  /** 
 * Where the formal definition can be found. If a server references the base
   * definition of an Operation (i.e. from the specification itself such as
   * ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that means it
   * supports the full capabilities of the operation - e.g. both GET and POST
   * invocation.  If it only supports a subset, it must define its own custom
   * [OperationDefinition](operationdefinition.html#) with a 'base' of the original
   * OperationDefinition.  The custom definition would describe the specific subset
   * of functionality supported.
 */
  definition: Scalars['FHIRCanonical'],
  /** 
 * Documentation that describes anything special about the operation behavior,
   * possibly detailing different behavior for system, type and instance-level
   * invocation of the operation.
 */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRCapabilityStatementrestresourcesearchParam = {
   __typename?: 'FHIRCapabilityStatementrestresourcesearchParam',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the search parameter used in the interface. */
  name: Scalars['String'],
  /** 
 * An absolute URI that is a formal reference to where this parameter was first
   * defined, so that a client can be confident of the meaning of the search
   * parameter (a reference to
   * [SearchParameter.url](searchparameter-definitions.html#SearchParameter.url)).
   * This element SHALL be populated if the search parameter refers to a
   * SearchParameter defined by the FHIR core specification or externally defined IGs.
 */
  definition?: Maybe<Scalars['FHIRCanonical']>,
  /** The type of value a search parameter refers to, and how the content is interpreted. */
  type: Scalars['FHIRCode'],
  /** 
 * This allows documentation of any distinct behaviors about how the search
   * parameter is used.  For example, text matching algorithms.
 */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRCapabilityStatementrestsecurity = {
   __typename?: 'FHIRCapabilityStatementrestsecurity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Server adds CORS headers when responding to requests - this enables Javascript applications to use the server. */
  cors?: Maybe<Scalars['Boolean']>,
  /** Types of security services that are supported/required by the system. */
  service?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** General description of how security works. */
  description?: Maybe<Scalars['String']>,
};

export type FHIRCapabilityStatementsoftware = {
   __typename?: 'FHIRCapabilityStatementsoftware',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name the software is known by. */
  name: Scalars['String'],
  /** The version identifier for the software covered by this statement. */
  version?: Maybe<Scalars['String']>,
  /** Date this version of the software was released. */
  releaseDate?: Maybe<Scalars['FHIRDateTime']>,
};

/** 
 * Describes the intention of how one or more practitioners intend to deliver care
 * for a particular patient, group or community for a period of time, possibly
 * limited to care for a specific condition or set of conditions.
 */
export type FHIRCarePlan = {
   __typename?: 'FHIRCarePlan',
  /** Type of resource */
  resourceType: FHIRCarePlan_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this care plan by the performer or other
   * systems which remain constant as the resource is updated and propagates from
   * server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other
   * definition that is adhered to in whole or in part by this CarePlan.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline,
   * questionnaire or other definition that is adhered to in whole or in part by this CarePlan.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A care plan that is fulfilled in whole or in part by this care plan. */
  basedOn?: Maybe<Array<Maybe<FHIRCarePlanbasedOn_basedOn_Union>>>,
  /** Completed or terminated care plan whose function is taken by this new care plan. */
  replaces?: Maybe<Array<Maybe<FHIRCarePlanreplaces_replaces_Union>>>,
  /** A larger care plan of which this particular care plan is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRCarePlanpartOf_partOf_Union>>>,
  /** Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record. */
  status: Scalars['FHIRCode'],
  /** 
 * Indicates the level of authority/intentionality associated with the care plan
   * and where the care plan fits into the workflow chain.
 */
  intent: Scalars['FHIRCode'],
  /** 
 * Identifies what 'kind' of plan this is to support differentiation between
   * multiple co-existing plans; e.g. 'Home health', 'psychiatric', 'asthma',
   * 'disease management', 'wellness plan', etc.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Human-friendly name for the care plan. */
  title?: Maybe<Scalars['String']>,
  /** A description of the scope and nature of the plan. */
  description?: Maybe<Scalars['String']>,
  /** Identifies the patient or group whose intended care is described by the plan. */
  subject: FHIRCarePlansubject_subject_Union,
  /** The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRCarePlanencounter_encounter_Union>,
  /** Indicates when the plan did (or is intended to) come into effect and end. */
  period?: Maybe<FHIRPeriod>,
  /** Represents when this particular CarePlan record was created in the system, which is often a system-generated date. */
  created?: Maybe<Scalars['FHIRDateTime']>,
  /** When populated, the author is responsible for the care plan.  The care plan is attributed to the author. */
  author?: Maybe<FHIRCarePlanauthor_author_Union>,
  /** Identifies the individual(s) or organization who provided the contents of the care plan. */
  contributor?: Maybe<Array<Maybe<FHIRCarePlancontributor_contributor_Union>>>,
  /** Identifies all people and organizations who are expected to be involved in the care envisioned by this plan. */
  careTeam?: Maybe<Array<Maybe<FHIRCarePlancareTeam_careTeam_Union>>>,
  /** Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan. */
  addresses?: Maybe<Array<Maybe<FHIRCarePlanaddresses_addresses_Union>>>,
  /** 
 * Identifies portions of the patient's record that specifically influenced the
   * formation of the plan.  These might include comorbidities, recent procedures,
   * limitations, recent assessments, etc.
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRCarePlansupportingInfo_supportingInfo_Union>>>,
  /** Describes the intended objective(s) of carrying out the care plan. */
  goal?: Maybe<Array<Maybe<FHIRCarePlangoal_goal_Union>>>,
  /** 
 * Identifies a planned action to occur as part of the plan.  For example, a
   * medication to be used, lab tests to perform, self-monitoring, education, etc.
 */
  activity?: Maybe<Array<Maybe<FHIRCarePlanactivity>>>,
  /** General notes about the care plan not covered elsewhere. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRCarePlan_Enum_schema {
  CarePlan = 'CarePlan'
}

export type FHIRCarePlanactivity = {
   __typename?: 'FHIRCarePlanactivity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifies the outcome at the point when the status of the activity is
   * assessed.  For example, the outcome of an education activity could be patient
   * understands (or not).
 */
  outcomeCodeableConcept?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Details of the outcome or action resulting from the activity.  The reference
   * to an 'event' resource, such as Procedure or Encounter or Observation, is the
   * result/outcome of the activity itself.  The activity can be conveyed using
   * CarePlan.activity.detail OR using the CarePlan.activity.reference (a reference
   * to a “request” resource).
 */
  outcomeReference?: Maybe<Array<Maybe<FHIRCarePlanactivityoutcomeReference_outcomeReference_Union>>>,
  /** Notes about the adherence/status/progress of the activity. */
  progress?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** The details of the proposed activity represented in a specific resource. */
  reference?: Maybe<FHIRCarePlanactivityreference_reference_Union>,
  /** 
 * A simple summary of a planned activity suitable for a general care plan system
   * (e.g. form driven) that doesn't know about specific resources such as procedure etc.
 */
  detail?: Maybe<FHIRCarePlanactivitydetail>,
};

export type FHIRCarePlanactivitydetail = {
   __typename?: 'FHIRCarePlanactivitydetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A description of the kind of resource the in-line definition of a care plan
   * activity is representing.  The CarePlan.activity.detail is an in-line
   * definition when a resource is not referenced using
   * CarePlan.activity.reference.  For example, a MedicationRequest, a
   * ServiceRequest, or a CommunicationRequest.
 */
  kind?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other
   * definition that is adhered to in whole or in part by this CarePlan activity.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline,
   * questionnaire or other definition that is adhered to in whole or in part by
   * this CarePlan activity.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** Detailed description of the type of planned activity; e.g. what lab test, what procedure, what kind of encounter. */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * Provides the rationale that drove the inclusion of this particular activity as
   * part of the plan or the reason why the activity was prohibited.
 */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates another resource, such as the health condition(s), whose existence
   * justifies this request and drove the inclusion of this particular activity as
   * part of the plan.
 */
  reasonReference?: Maybe<Array<Maybe<FHIRCarePlanactivitydetailreasonReference_reasonReference_Union>>>,
  /** Internal reference that identifies the goals that this activity is intended to contribute towards meeting. */
  goal?: Maybe<Array<Maybe<FHIRCarePlanactivitydetailgoal_goal_Union>>>,
  /** Identifies what progress is being made for the specific activity. */
  status: Scalars['FHIRCode'],
  /** Provides reason why the activity isn't yet started, is on hold, was cancelled, etc. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** 
 * If true, indicates that the described activity is one that must NOT be engaged
   * in when following the plan.  If false, or missing, indicates that the
   * described activity is one that should be engaged in when following the plan.
 */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  scheduledTiming?: Maybe<FHIRTiming>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  scheduledPeriod?: Maybe<FHIRPeriod>,
  /** The period, timing or frequency upon which the described activity is to occur. */
  scheduledString?: Maybe<Scalars['String']>,
  /** Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. */
  location?: Maybe<FHIRCarePlanactivitydetaillocation_location_Union>,
  /** Identifies who's expected to be involved in the activity. */
  performer?: Maybe<Array<Maybe<FHIRCarePlanactivitydetailperformer_performer_Union>>>,
  /** Identifies the food, drug or other product to be consumed or supplied in the activity. */
  productCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Identifies the food, drug or other product to be consumed or supplied in the activity. */
  productReference?: Maybe<FHIRCarePlanactivitydetailproductReference_productReference_Union>,
  /** Identifies the quantity expected to be consumed in a given day. */
  dailyAmount?: Maybe<FHIRQuantity>,
  /** Identifies the quantity expected to be supplied, administered or consumed by the subject. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * This provides a textual description of constraints on the intended activity
   * occurrence, including relation to other activities.  It may also include
   * objectives, pre-conditions and end-conditions.  Finally, it may convey
   * specifics about the activity such as body site, method, route, etc.
 */
  description?: Maybe<Scalars['String']>,
};

/** Internal reference that identifies the goals that this activity is intended to contribute towards meeting. */
export type FHIRCarePlanactivitydetailgoal_goal_Union = FHIRGoal;

/** Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. */
export type FHIRCarePlanactivitydetaillocation_location_Union = FHIRLocation;

/** Identifies who's expected to be involved in the activity. */
export type FHIRCarePlanactivitydetailperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRRelatedPerson | FHIRPatient | FHIRCareTeam | FHIRHealthcareService | FHIRDevice;

/** Identifies the food, drug or other product to be consumed or supplied in the activity. */
export type FHIRCarePlanactivitydetailproductReference_productReference_Union = FHIRMedication | FHIRSubstance;

/** 
 * Indicates another resource, such as the health condition(s), whose existence
 * justifies this request and drove the inclusion of this particular activity as
 * part of the plan.
 */
export type FHIRCarePlanactivitydetailreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** 
 * Details of the outcome or action resulting from the activity.  The reference to
 * an 'event' resource, such as Procedure or Encounter or Observation, is the
 * result/outcome of the activity itself.  The activity can be conveyed using
 * CarePlan.activity.detail OR using the CarePlan.activity.reference (a reference
 * to a “request” resource).
 */
export type FHIRCarePlanactivityoutcomeReference_outcomeReference_Union = FHIRResource;

/** The details of the proposed activity represented in a specific resource. */
export type FHIRCarePlanactivityreference_reference_Union = FHIRAppointment | FHIRCommunicationRequest | FHIRDeviceRequest | FHIRMedicationRequest | FHIRNutritionOrder | FHIRTask | FHIRServiceRequest | FHIRVisionPrescription | FHIRRequestGroup;

/** Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan. */
export type FHIRCarePlanaddresses_addresses_Union = FHIRCondition;

/** When populated, the author is responsible for the care plan.  The care plan is attributed to the author. */
export type FHIRCarePlanauthor_author_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRRelatedPerson | FHIROrganization | FHIRCareTeam;

/** A care plan that is fulfilled in whole or in part by this care plan. */
export type FHIRCarePlanbasedOn_basedOn_Union = FHIRCarePlan;

/** Identifies all people and organizations who are expected to be involved in the care envisioned by this plan. */
export type FHIRCarePlancareTeam_careTeam_Union = FHIRCareTeam;

/** Identifies the individual(s) or organization who provided the contents of the care plan. */
export type FHIRCarePlancontributor_contributor_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRRelatedPerson | FHIROrganization | FHIRCareTeam;

/** The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated. */
export type FHIRCarePlanencounter_encounter_Union = FHIREncounter;

/** Describes the intended objective(s) of carrying out the care plan. */
export type FHIRCarePlangoal_goal_Union = FHIRGoal;

/** A larger care plan of which this particular care plan is a component or step. */
export type FHIRCarePlanpartOf_partOf_Union = FHIRCarePlan;

/** Completed or terminated care plan whose function is taken by this new care plan. */
export type FHIRCarePlanreplaces_replaces_Union = FHIRCarePlan;

/** Identifies the patient or group whose intended care is described by the plan. */
export type FHIRCarePlansubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * Identifies portions of the patient's record that specifically influenced the
 * formation of the plan.  These might include comorbidities, recent procedures,
 * limitations, recent assessments, etc.
 */
export type FHIRCarePlansupportingInfo_supportingInfo_Union = FHIRResource;

/** 
 * The Care Team includes all the people and organizations who plan to participate
 * in the coordination and delivery of care for a patient.
 */
export type FHIRCareTeam = {
   __typename?: 'FHIRCareTeam',
  /** Type of resource */
  resourceType: FHIRCareTeam_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this care team by the performer or other
   * systems which remain constant as the resource is updated and propagates from
   * server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the current state of the care team. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Identifies what kind of team.  This is to support differentiation between
   * multiple co-existing teams, such as care plan team, episode of care team,
   * longitudinal care team.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A label for human use intended to distinguish like teams.  E.g. the 'red' vs. 'green' trauma teams. */
  name?: Maybe<Scalars['String']>,
  /** Identifies the patient or group whose intended care is handled by the team. */
  subject?: Maybe<FHIRCareTeamsubject_subject_Union>,
  /** The Encounter during which this CareTeam was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRCareTeamencounter_encounter_Union>,
  /** Indicates when the team did (or is intended to) come into effect and end. */
  period?: Maybe<FHIRPeriod>,
  /** Identifies all people and organizations who are expected to be involved in the care team. */
  participant?: Maybe<Array<Maybe<FHIRCareTeamparticipant>>>,
  /** Describes why the care team exists. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Condition(s) that this care team addresses. */
  reasonReference?: Maybe<Array<Maybe<FHIRCareTeamreasonReference_reasonReference_Union>>>,
  /** The organization responsible for the care team. */
  managingOrganization?: Maybe<Array<Maybe<FHIRCareTeammanagingOrganization_managingOrganization_Union>>>,
  /** A central contact detail for the care team (that applies to all members). */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Comments made about the CareTeam. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRCareTeam_Enum_schema {
  CareTeam = 'CareTeam'
}

/** The Encounter during which this CareTeam was created or to which the creation of this record is tightly associated. */
export type FHIRCareTeamencounter_encounter_Union = FHIREncounter;

/** The organization responsible for the care team. */
export type FHIRCareTeammanagingOrganization_managingOrganization_Union = FHIROrganization;

export type FHIRCareTeamparticipant = {
   __typename?: 'FHIRCareTeamparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates specific responsibility of an individual within the care team, such
   * as 'Primary care physician', 'Trained social worker counselor', 'Caregiver', etc.
 */
  role?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specific person or organization who is participating/expected to participate in the care team. */
  member?: Maybe<FHIRCareTeamparticipantmember_member_Union>,
  /** The organization of the practitioner. */
  onBehalfOf?: Maybe<FHIRCareTeamparticipantonBehalfOf_onBehalfOf_Union>,
  /** Indicates when the specific member or organization did (or is intended to) come into effect and end. */
  period?: Maybe<FHIRPeriod>,
};

/** The specific person or organization who is participating/expected to participate in the care team. */
export type FHIRCareTeamparticipantmember_member_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRPatient | FHIROrganization | FHIRCareTeam;

/** The organization of the practitioner. */
export type FHIRCareTeamparticipantonBehalfOf_onBehalfOf_Union = FHIROrganization;

/** Condition(s) that this care team addresses. */
export type FHIRCareTeamreasonReference_reasonReference_Union = FHIRCondition;

/** Identifies the patient or group whose intended care is handled by the team. */
export type FHIRCareTeamsubject_subject_Union = FHIRPatient | FHIRGroup;

/** Catalog entries are wrappers that contextualize items included in a catalog. */
export type FHIRCatalogEntry = {
   __typename?: 'FHIRCatalogEntry',
  /** Type of resource */
  resourceType: FHIRCatalogEntry_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Used in supporting different identifiers for the same product, e.g. manufacturer code and retailer code. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The type of item - medication, device, service, protocol or other. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Whether the entry represents an orderable item. */
  orderable: Scalars['Boolean'],
  /** The item in a catalog or definition. */
  referencedItem: FHIRCatalogEntryreferencedItem_referencedItem_Union,
  /** Used in supporting related concepts, e.g. NDC to RxNorm. */
  additionalIdentifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Classes of devices, or ATC for medication. */
  classification?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Used to support catalog exchange even for unsupported products, e.g. getting list of medications even if not prescribable. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** The time period in which this catalog entry is expected to be active. */
  validityPeriod?: Maybe<FHIRPeriod>,
  /** The date until which this catalog entry is expected to be active. */
  validTo?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Typically date of issue is different from the beginning of the validity. This
   * can be used to see when an item was last updated.
 */
  lastUpdated?: Maybe<Scalars['FHIRDateTime']>,
  /** Used for examplefor Out of Formulary, or any specifics. */
  additionalCharacteristic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** User for example for ATC classification, or. */
  additionalClassification?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Used for example, to point to a substance, or to a device used to administer a medication. */
  relatedEntry?: Maybe<Array<Maybe<FHIRCatalogEntryrelatedEntry>>>,
};

export enum FHIRCatalogEntry_Enum_schema {
  CatalogEntry = 'CatalogEntry'
}

/** The item in a catalog or definition. */
export type FHIRCatalogEntryreferencedItem_referencedItem_Union = FHIRMedication | FHIRDevice | FHIROrganization | FHIRPractitioner | FHIRPractitionerRole | FHIRHealthcareService | FHIRActivityDefinition | FHIRPlanDefinition | FHIRSpecimenDefinition | FHIRObservationDefinition | FHIRBinary;

export type FHIRCatalogEntryrelatedEntry = {
   __typename?: 'FHIRCatalogEntryrelatedEntry',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relation to the related item: child, parent, packageContent, containerPackage, usedIn, uses, requires, etc. */
  relationtype: Scalars['FHIRCode'],
  /** The reference to the related item. */
  item: FHIRCatalogEntryrelatedEntryitem_item_Union,
};

/** The reference to the related item. */
export type FHIRCatalogEntryrelatedEntryitem_item_Union = FHIRCatalogEntry;

/** 
 * The resource ChargeItem describes the provision of healthcare provider products
 * for a certain patient, therefore referring not only to the product, but
 * containing in addition details of the provision, like date, time, amounts and
 * participating organizations and persons. Main Usage of the ChargeItem is to
 * enable the billing process and internal cost allocation.
 */
export type FHIRChargeItem = {
   __typename?: 'FHIRChargeItem',
  /** Type of resource */
  resourceType: FHIRChargeItem_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this event performer or other systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** References the (external) source of pricing information, rules of application for the code this ChargeItem uses. */
  definitionUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** References the source of pricing information, rules of application for the code this ChargeItem uses. */
  definitionCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The current state of the ChargeItem. */
  status: Scalars['FHIRCode'],
  /** ChargeItems can be grouped to larger ChargeItems covering the whole set. */
  partOf?: Maybe<Array<Maybe<FHIRChargeItempartOf_partOf_Union>>>,
  /** A code that identifies the charge, like a billing code. */
  code: FHIRCodeableConcept,
  /** The individual or set of individuals the action is being or was performed on. */
  subject: FHIRChargeItemsubject_subject_Union,
  /** The encounter or episode of care that establishes the context for this event. */
  context?: Maybe<FHIRChargeItemcontext_context_Union>,
  /** Date/time(s) or duration when the charged service was applied. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Date/time(s) or duration when the charged service was applied. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** Date/time(s) or duration when the charged service was applied. */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** Indicates who or what performed or participated in the charged service. */
  performer?: Maybe<Array<Maybe<FHIRChargeItemperformer>>>,
  /** The organization requesting the service. */
  performingOrganization?: Maybe<FHIRChargeItemperformingOrganization_performingOrganization_Union>,
  /** The organization performing the service. */
  requestingOrganization?: Maybe<FHIRChargeItemrequestingOrganization_requestingOrganization_Union>,
  /** The financial cost center permits the tracking of charge attribution. */
  costCenter?: Maybe<FHIRChargeItemcostCenter_costCenter_Union>,
  /** Quantity of which the charge item has been serviced. */
  quantity?: Maybe<FHIRQuantity>,
  /** The anatomical location where the related service has been applied. */
  bodysite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Factor overriding the factor determined by the rules associated with the code. */
  factorOverride?: Maybe<Scalars['Float']>,
  /** Total price of the charge overriding the list price associated with the code. */
  priceOverride?: Maybe<FHIRMoney>,
  /** 
 * If the list price or the rule-based factor associated with the code is
   * overridden, this attribute can capture a text to indicate the  reason for this action.
 */
  overrideReason?: Maybe<Scalars['String']>,
  /** The device, practitioner, etc. who entered the charge item. */
  enterer?: Maybe<FHIRChargeItementerer_enterer_Union>,
  /** Date the charge item was entered. */
  enteredDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Describes why the event occurred in coded or textual form. */
  reason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicated the rendered service that caused this charge. */
  service?: Maybe<Array<Maybe<FHIRChargeItemservice_service_Union>>>,
  /** Identifies the device, food, drug or other product being charged either by type code or reference to an instance. */
  productReference?: Maybe<FHIRChargeItemproductReference_productReference_Union>,
  /** Identifies the device, food, drug or other product being charged either by type code or reference to an instance. */
  productCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Account into which this ChargeItems belongs. */
  account?: Maybe<Array<Maybe<FHIRChargeItemaccount_account_Union>>>,
  /** Comments made about the event by the performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Further information supporting this charge. */
  supportingInformation?: Maybe<Array<Maybe<FHIRChargeItemsupportingInformation_supportingInformation_Union>>>,
};

export enum FHIRChargeItem_Enum_schema {
  ChargeItem = 'ChargeItem'
}

/** Account into which this ChargeItems belongs. */
export type FHIRChargeItemaccount_account_Union = FHIRAccount;

/** The encounter or episode of care that establishes the context for this event. */
export type FHIRChargeItemcontext_context_Union = FHIREncounter | FHIREpisodeOfCare;

/** The financial cost center permits the tracking of charge attribution. */
export type FHIRChargeItemcostCenter_costCenter_Union = FHIROrganization;

/** 
 * The ChargeItemDefinition resource provides the properties that apply to the
 * (billing) codes necessary to calculate costs and prices. The properties may
 * differ largely depending on type and realm, therefore this resource gives only a
 * rough structure and requires profiling for each type of billing code system.
 */
export type FHIRChargeItemDefinition = {
   __typename?: 'FHIRChargeItemDefinition',
  /** Type of resource */
  resourceType: FHIRChargeItemDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this charge item definition when it
   * is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this charge
   * item definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the charge item definition
   * is stored on different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * A formal identifier that is used to identify this charge item definition when
   * it is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the charge item
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the charge item definition
   * author and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence. To
   * provide a version consistent with the Decision Support Service specification,
   * use the format Major.Minor.Revision (e.g. 1.0.0). For more information on
   * versioning knowledge assets, refer to the Decision Support Service
   * specification. Note that a version is required for non-experimental active assets.
 */
  version?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the charge item definition. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The URL pointing to an externally-defined charge item definition that is
   * adhered to in whole or in part by this definition.
 */
  derivedFromUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A larger definition of which this particular definition is a component or step. */
  partOf?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * As new versions of a protocol or guideline are defined, allows identification
   * of what versions are replaced by a new instance.
 */
  replaces?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The current state of the ChargeItemDefinition. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this charge item definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the charge item definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the charge item definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the charge item definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the charge item definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate charge item
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the charge item definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the charge item definition and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the charge item definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the charge item definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** The defined billing details in this resource pertain to the given billing code. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The defined billing details in this resource pertain to the given product instance(s). */
  instance?: Maybe<Array<Maybe<FHIRChargeItemDefinitioninstance_instance_Union>>>,
  /** Expressions that describe applicability criteria for the billing code. */
  applicability?: Maybe<Array<Maybe<FHIRChargeItemDefinitionapplicability>>>,
  /** 
 * Group of properties which are applicable under the same conditions. If no
   * applicability rules are established for the group, then all properties always apply.
 */
  propertyGroup?: Maybe<Array<Maybe<FHIRChargeItemDefinitionpropertyGroup>>>,
};

export enum FHIRChargeItemDefinition_Enum_schema {
  ChargeItemDefinition = 'ChargeItemDefinition'
}

export type FHIRChargeItemDefinitionapplicability = {
   __typename?: 'FHIRChargeItemDefinitionapplicability',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A brief, natural language description of the condition that effectively communicates the intended semantics. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The media type of the language for the expression, e.g. 'text/cql' for
   * Clinical Query Language expressions or 'text/fhirpath' for FHIRPath expressions.
 */
  language?: Maybe<Scalars['String']>,
  /** 
 * An expression that returns true or false, indicating whether the condition is
   * satisfied. When using FHIRPath expressions, the %context environment variable
   * must be replaced at runtime with the ChargeItem resource to which this
   * definition is applied.
 */
  expression?: Maybe<Scalars['String']>,
};

/** The defined billing details in this resource pertain to the given product instance(s). */
export type FHIRChargeItemDefinitioninstance_instance_Union = FHIRMedication | FHIRSubstance | FHIRDevice;

export type FHIRChargeItemDefinitionpropertyGroup = {
   __typename?: 'FHIRChargeItemDefinitionpropertyGroup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The price for a ChargeItem may be calculated as a base price with
   * surcharges/deductions that apply in certain conditions. A ChargeItemDefinition
   * resource that defines the prices, factors and conditions that apply to a
   * billing code is currently under development. The priceComponent element can be
   * used to offer transparency to the recipient of the Invoice of how the prices
   * have been calculated.
 */
  priceComponent?: Maybe<Array<Maybe<FHIRChargeItemDefinitionpropertyGrouppriceComponent>>>,
};

export type FHIRChargeItemDefinitionpropertyGrouppriceComponent = {
   __typename?: 'FHIRChargeItemDefinitionpropertyGrouppriceComponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** This code identifies the type of the component. */
  type: Scalars['FHIRCode'],
  /** 
 * A code that identifies the component. Codes may be used to differentiate
   * between kinds of taxes, surcharges, discounts etc.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The factor that has been applied on the base price for calculating this component. */
  factor?: Maybe<Scalars['Float']>,
  /** The amount calculated for this component. */
  amount?: Maybe<FHIRMoney>,
};

/** The device, practitioner, etc. who entered the charge item. */
export type FHIRChargeItementerer_enterer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** ChargeItems can be grouped to larger ChargeItems covering the whole set. */
export type FHIRChargeItempartOf_partOf_Union = FHIRChargeItem;

export type FHIRChargeItemperformer = {
   __typename?: 'FHIRChargeItemperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.). */
  function?: Maybe<FHIRCodeableConcept>,
  /** The device, practitioner, etc. who performed or participated in the service. */
  actor: FHIRChargeItemperformeractor_actor_Union,
};

/** The device, practitioner, etc. who performed or participated in the service. */
export type FHIRChargeItemperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** The organization requesting the service. */
export type FHIRChargeItemperformingOrganization_performingOrganization_Union = FHIROrganization;

/** Identifies the device, food, drug or other product being charged either by type code or reference to an instance. */
export type FHIRChargeItemproductReference_productReference_Union = FHIRDevice | FHIRMedication | FHIRSubstance;

/** The organization performing the service. */
export type FHIRChargeItemrequestingOrganization_requestingOrganization_Union = FHIROrganization;

/** Indicated the rendered service that caused this charge. */
export type FHIRChargeItemservice_service_Union = FHIRDiagnosticReport | FHIRImagingStudy | FHIRImmunization | FHIRMedicationAdministration | FHIRMedicationDispense | FHIRObservation | FHIRProcedure | FHIRSupplyDelivery;

/** The individual or set of individuals the action is being or was performed on. */
export type FHIRChargeItemsubject_subject_Union = FHIRPatient | FHIRGroup;

/** Further information supporting this charge. */
export type FHIRChargeItemsupportingInformation_supportingInformation_Union = FHIRResource;

/** 
 * A provider issued list of professional services and products which have been
 * provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.
 */
export type FHIRClaim = {
   __typename?: 'FHIRClaim',
  /** Type of resource */
  resourceType: FHIRClaim_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this claim. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** The category of claim, e.g. oral, pharmacy, vision, institutional, professional. */
  type: FHIRCodeableConcept,
  /** 
 * A finer grained suite of claim type codes which may convey additional
   * information such as Inpatient vs Outpatient and/or a specialty service.
 */
  subType?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code to indicate whether the nature of the request is: to request
   * adjudication of products and services previously rendered; or requesting
   * authorization and adjudication for provision in the future; or requesting the
   * non-binding adjudication of the listed products and services which could be
   * provided in the future.
 */
  use: Scalars['FHIRCode'],
  /** 
 * The party to whom the professional services and/or products have been supplied
   * or are being considered and for whom actual or forecast reimbursement is sought.
 */
  patient: FHIRClaimpatient_patient_Union,
  /** The period for which charges are being submitted. */
  billablePeriod?: Maybe<FHIRPeriod>,
  /** The date this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** Individual who created the claim, predetermination or preauthorization. */
  enterer?: Maybe<FHIRClaimenterer_enterer_Union>,
  /** The Insurer who is target of the request. */
  insurer?: Maybe<FHIRClaiminsurer_insurer_Union>,
  /** The provider which is responsible for the claim, predetermination or preauthorization. */
  provider: FHIRClaimprovider_provider_Union,
  /** The provider-required urgency of processing the request. Typical values include: stat, routine deferred. */
  priority: FHIRCodeableConcept,
  /** A code to indicate whether and for whom funds are to be reserved for future claims. */
  fundsReserve?: Maybe<FHIRCodeableConcept>,
  /** 
 * Other claims which are related to this claim such as prior submissions or
   * claims for related services or for the same event.
 */
  related?: Maybe<Array<Maybe<FHIRClaimrelated>>>,
  /** Prescription to support the dispensing of pharmacy, device or vision products. */
  prescription?: Maybe<FHIRClaimprescription_prescription_Union>,
  /** 
 * Original prescription which has been superseded by this prescription to
   * support the dispensing of pharmacy services, medications or products.
 */
  originalPrescription?: Maybe<FHIRClaimoriginalPrescription_originalPrescription_Union>,
  /** The party to be reimbursed for cost of the products and services according to the terms of the policy. */
  payee?: Maybe<FHIRClaimpayee>,
  /** A reference to a referral resource. */
  referral?: Maybe<FHIRClaimreferral_referral_Union>,
  /** Facility where the services were provided. */
  facility?: Maybe<FHIRClaimfacility_facility_Union>,
  /** The members of the team who provided the products and services. */
  careTeam?: Maybe<Array<Maybe<FHIRClaimcareTeam>>>,
  /** 
 * Additional information codes regarding exceptions, special considerations, the
   * condition, situation, prior or concurrent issues.
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRClaimsupportingInfo>>>,
  /** Information about diagnoses relevant to the claim items. */
  diagnosis?: Maybe<Array<Maybe<FHIRClaimdiagnosis>>>,
  /** Procedures performed on the patient relevant to the billing items with the claim. */
  procedure?: Maybe<Array<Maybe<FHIRClaimprocedure>>>,
  /** Financial instruments for reimbursement for the health care products and services specified on the claim. */
  insurance?: Maybe<Array<FHIRClaiminsurance>>,
  /** Details of an accident which resulted in injuries which required the products and services listed in the claim. */
  accident?: Maybe<FHIRClaimaccident>,
  /** 
 * A claim line. Either a simple  product or service or a 'group' of details
   * which can each be a simple items or groups of sub-details.
 */
  item?: Maybe<Array<Maybe<FHIRClaimitem>>>,
  /** The total value of the all the items in the claim. */
  total?: Maybe<FHIRMoney>,
};

export enum FHIRClaim_Enum_schema {
  Claim = 'Claim'
}

export type FHIRClaimaccident = {
   __typename?: 'FHIRClaimaccident',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Date of an accident event  related to the products and services contained in the claim. */
  date: Scalars['FHIRDate'],
  /** 
 * The type or context of the accident event for the purposes of selection of
   * potential insurance coverages and determination of coordination between insurers.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The physical location of the accident event. */
  locationAddress?: Maybe<FHIRAddress>,
  /** The physical location of the accident event. */
  locationReference?: Maybe<FHIRClaimaccidentlocationReference_locationReference_Union>,
};

/** The physical location of the accident event. */
export type FHIRClaimaccidentlocationReference_locationReference_Union = FHIRLocation;

export type FHIRClaimcareTeam = {
   __typename?: 'FHIRClaimcareTeam',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify care team entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** Member of the team who provided the product or service. */
  provider: FHIRClaimcareTeamprovider_provider_Union,
  /** The party who is billing and/or responsible for the claimed products or services. */
  responsible?: Maybe<Scalars['Boolean']>,
  /** The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. */
  role?: Maybe<FHIRCodeableConcept>,
  /** The qualification of the practitioner which is applicable for this service. */
  qualification?: Maybe<FHIRCodeableConcept>,
};

/** Member of the team who provided the product or service. */
export type FHIRClaimcareTeamprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRClaimdiagnosis = {
   __typename?: 'FHIRClaimdiagnosis',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify diagnosis entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisCodeableConcept: FHIRCodeableConcept,
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisReference: FHIRClaimdiagnosisdiagnosisReference_diagnosisReference_Union,
  /** When the condition was observed or the relative ranking. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indication of whether the diagnosis was present on admission to a facility. */
  onAdmission?: Maybe<FHIRCodeableConcept>,
  /** 
 * A package billing code or bundle code used to group products and services to a
   * particular health condition (such as heart attack) which is based on a
   * predetermined grouping code system.
 */
  packageCode?: Maybe<FHIRCodeableConcept>,
};

/** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
export type FHIRClaimdiagnosisdiagnosisReference_diagnosisReference_Union = FHIRCondition;

/** Individual who created the claim, predetermination or preauthorization. */
export type FHIRClaimenterer_enterer_Union = FHIRPractitioner | FHIRPractitionerRole;

/** Facility where the services were provided. */
export type FHIRClaimfacility_facility_Union = FHIRLocation;

export type FHIRClaiminsurance = {
   __typename?: 'FHIRClaiminsurance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A number to uniquely identify insurance entries and provide a sequence of
   * coverages to convey coordination of benefit order.
 */
  sequence: Scalars['FHIRPositiveInt'],
  /** A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true. */
  focal: Scalars['Boolean'],
  /** The business identifier to be used when the claim is sent for adjudication against this insurance policy. */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * Reference to the insurance card level information contained in the Coverage
   * resource. The coverage issuing insurer will use these details to locate the
   * patient's actual coverage within the insurer's information system.
 */
  coverage: FHIRClaiminsurancecoverage_coverage_Union,
  /** A business agreement number established between the provider and the insurer for special business processing purposes. */
  businessArrangement?: Maybe<Scalars['String']>,
  /** 
 * Reference numbers previously provided by the insurer to the provider to be
   * quoted on subsequent claims containing services or products related to the
   * prior authorization.
 */
  preAuthRef?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The result of the adjudication of the line items for the Coverage specified in this insurance. */
  claimResponse?: Maybe<FHIRClaiminsuranceclaimResponse_claimResponse_Union>,
};

/** The result of the adjudication of the line items for the Coverage specified in this insurance. */
export type FHIRClaiminsuranceclaimResponse_claimResponse_Union = FHIRClaimResponse;

/** 
 * Reference to the insurance card level information contained in the Coverage
 * resource. The coverage issuing insurer will use these details to locate the
 * patient's actual coverage within the insurer's information system.
 */
export type FHIRClaiminsurancecoverage_coverage_Union = FHIRCoverage;

/** The Insurer who is target of the request. */
export type FHIRClaiminsurer_insurer_Union = FHIROrganization;

export type FHIRClaimitem = {
   __typename?: 'FHIRClaimitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify item entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** CareTeam members related to this service or product. */
  careTeamSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Diagnosis applicable for this service or product. */
  diagnosisSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Procedures applicable for this service or product. */
  procedureSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Exceptions, special conditions and supporting information applicable for this service or product. */
  informationSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** Where the product or service was provided. */
  locationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Where the product or service was provided. */
  locationAddress?: Maybe<FHIRAddress>,
  /** Where the product or service was provided. */
  locationReference?: Maybe<FHIRClaimitemlocationReference_locationReference_Union>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRClaimitemudi_udi_Union>>>,
  /** Physical service site on the patient (limb, tooth, etc.). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** A region or surface of the bodySite, e.g. limb region or tooth surface(s). */
  subSite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The Encounters during which this Claim was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<Array<Maybe<FHIRClaimitemencounter_encounter_Union>>>,
  /** A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items. */
  detail?: Maybe<Array<Maybe<FHIRClaimitemdetail>>>,
};

export type FHIRClaimitemdetail = {
   __typename?: 'FHIRClaimitemdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify item entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRClaimitemdetailudi_udi_Union>>>,
  /** A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items. */
  subDetail?: Maybe<Array<Maybe<FHIRClaimitemdetailsubDetail>>>,
};

export type FHIRClaimitemdetailsubDetail = {
   __typename?: 'FHIRClaimitemdetailsubDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify item entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRClaimitemdetailsubDetailudi_udi_Union>>>,
};

/** Unique Device Identifiers associated with this line item. */
export type FHIRClaimitemdetailsubDetailudi_udi_Union = FHIRDevice;

/** Unique Device Identifiers associated with this line item. */
export type FHIRClaimitemdetailudi_udi_Union = FHIRDevice;

/** The Encounters during which this Claim was created or to which the creation of this record is tightly associated. */
export type FHIRClaimitemencounter_encounter_Union = FHIREncounter;

/** Where the product or service was provided. */
export type FHIRClaimitemlocationReference_locationReference_Union = FHIRLocation;

/** Unique Device Identifiers associated with this line item. */
export type FHIRClaimitemudi_udi_Union = FHIRDevice;

/** 
 * Original prescription which has been superseded by this prescription to support
 * the dispensing of pharmacy services, medications or products.
 */
export type FHIRClaimoriginalPrescription_originalPrescription_Union = FHIRDeviceRequest | FHIRMedicationRequest | FHIRVisionPrescription;

/** 
 * The party to whom the professional services and/or products have been supplied
 * or are being considered and for whom actual or forecast reimbursement is sought.
 */
export type FHIRClaimpatient_patient_Union = FHIRPatient;

export type FHIRClaimpayee = {
   __typename?: 'FHIRClaimpayee',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of Party to be reimbursed: subscriber, provider, other. */
  type: FHIRCodeableConcept,
  /** Reference to the individual or organization to whom any payment will be made. */
  party?: Maybe<FHIRClaimpayeeparty_party_Union>,
};

/** Reference to the individual or organization to whom any payment will be made. */
export type FHIRClaimpayeeparty_party_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson;

/** Prescription to support the dispensing of pharmacy, device or vision products. */
export type FHIRClaimprescription_prescription_Union = FHIRDeviceRequest | FHIRMedicationRequest | FHIRVisionPrescription;

export type FHIRClaimprocedure = {
   __typename?: 'FHIRClaimprocedure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify procedure entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** When the condition was observed or the relative ranking. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Date and optionally time the procedure was performed. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
  procedureCodeableConcept: FHIRCodeableConcept,
  /** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
  procedureReference: FHIRClaimprocedureprocedureReference_procedureReference_Union,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRClaimprocedureudi_udi_Union>>>,
};

/** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
export type FHIRClaimprocedureprocedureReference_procedureReference_Union = FHIRProcedure;

/** Unique Device Identifiers associated with this line item. */
export type FHIRClaimprocedureudi_udi_Union = FHIRDevice;

/** The provider which is responsible for the claim, predetermination or preauthorization. */
export type FHIRClaimprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** A reference to a referral resource. */
export type FHIRClaimreferral_referral_Union = FHIRServiceRequest;

export type FHIRClaimrelated = {
   __typename?: 'FHIRClaimrelated',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Reference to a related claim. */
  claim?: Maybe<FHIRClaimrelatedclaim_claim_Union>,
  /** A code to convey how the claims are related. */
  relationship?: Maybe<FHIRCodeableConcept>,
  /** An alternate organizational reference to the case or file to which this particular claim pertains. */
  reference?: Maybe<FHIRIdentifier>,
};

/** Reference to a related claim. */
export type FHIRClaimrelatedclaim_claim_Union = FHIRClaim;

/** This resource provides the adjudication details from the processing of a Claim resource. */
export type FHIRClaimResponse = {
   __typename?: 'FHIRClaimResponse',
  /** Type of resource */
  resourceType: FHIRClaimResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this claim response. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** 
 * A finer grained suite of claim type codes which may convey additional
   * information such as Inpatient vs Outpatient and/or a specialty service.
 */
  type: FHIRCodeableConcept,
  /** 
 * A finer grained suite of claim type codes which may convey additional
   * information such as Inpatient vs Outpatient and/or a specialty service.
 */
  subType?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code to indicate whether the nature of the request is: to request
   * adjudication of products and services previously rendered; or requesting
   * authorization and adjudication for provision in the future; or requesting the
   * non-binding adjudication of the listed products and services which could be
   * provided in the future.
 */
  use: Scalars['FHIRCode'],
  /** 
 * The party to whom the professional services and/or products have been supplied
   * or are being considered and for whom actual for facast reimbursement is sought.
 */
  patient: FHIRClaimResponsepatient_patient_Union,
  /** The date this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** The party responsible for authorization, adjudication and reimbursement. */
  insurer: FHIRClaimResponseinsurer_insurer_Union,
  /** The provider which is responsible for the claim, predetermination or preauthorization. */
  requestor?: Maybe<FHIRClaimResponserequestor_requestor_Union>,
  /** Original request resource reference. */
  request?: Maybe<FHIRClaimResponserequest_request_Union>,
  /** The outcome of the claim, predetermination, or preauthorization processing. */
  outcome: Scalars['FHIRCode'],
  /** A human readable description of the status of the adjudication. */
  disposition?: Maybe<Scalars['String']>,
  /** Reference from the Insurer which is used in later communications which refers to this adjudication. */
  preAuthRef?: Maybe<Scalars['String']>,
  /** The time frame during which this authorization is effective. */
  preAuthPeriod?: Maybe<FHIRPeriod>,
  /** Type of Party to be reimbursed: subscriber, provider, other. */
  payeeType?: Maybe<FHIRCodeableConcept>,
  /** 
 * A claim line. Either a simple (a product or service) or a 'group' of details
   * which can also be a simple items or groups of sub-details.
 */
  item?: Maybe<Array<Maybe<FHIRClaimResponseitem>>>,
  /** The first-tier service adjudications for payor added product or service lines. */
  addItem?: Maybe<Array<Maybe<FHIRClaimResponseaddItem>>>,
  /** Categorized monetary totals for the adjudication. */
  total?: Maybe<Array<Maybe<FHIRClaimResponsetotal>>>,
  /** Payment details for the adjudication of the claim. */
  payment?: Maybe<FHIRClaimResponsepayment>,
  /** 
 * A code, used only on a response to a preauthorization, to indicate whether the
   * benefits payable have been reserved and for whom.
 */
  fundsReserve?: Maybe<FHIRCodeableConcept>,
  /** A code for the form to be used for printing the content. */
  formCode?: Maybe<FHIRCodeableConcept>,
  /** The actual form, by reference or inclusion, for printing the content or an EOB. */
  form?: Maybe<FHIRAttachment>,
  /** A note that describes or explains adjudication results in a human readable form. */
  processNote?: Maybe<Array<Maybe<FHIRClaimResponseprocessNote>>>,
  /** Request for additional supporting or authorizing information. */
  communicationRequest?: Maybe<Array<Maybe<FHIRClaimResponsecommunicationRequest_communicationRequest_Union>>>,
  /** Financial instruments for reimbursement for the health care products and services specified on the claim. */
  insurance?: Maybe<Array<Maybe<FHIRClaimResponseinsurance>>>,
  /** Errors encountered during the processing of the adjudication. */
  error?: Maybe<Array<Maybe<FHIRClaimResponseerror>>>,
};

export enum FHIRClaimResponse_Enum_schema {
  ClaimResponse = 'ClaimResponse'
}

export type FHIRClaimResponseaddItem = {
   __typename?: 'FHIRClaimResponseaddItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Claim items which this service line is intended to replace. */
  itemSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The sequence number of the details within the claim item which this line is intended to replace. */
  detailSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The sequence number of the sub-details within the details within the claim item which this line is intended to replace. */
  subdetailSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The providers who are authorized for the services rendered to the patient. */
  provider?: Maybe<Array<Maybe<FHIRClaimResponseaddItemprovider_provider_Union>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** Where the product or service was provided. */
  locationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Where the product or service was provided. */
  locationAddress?: Maybe<FHIRAddress>,
  /** Where the product or service was provided. */
  locationReference?: Maybe<FHIRClaimResponseaddItemlocationReference_locationReference_Union>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Physical service site on the patient (limb, tooth, etc.). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** A region or surface of the bodySite, e.g. limb region or tooth surface(s). */
  subSite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The second-tier service adjudications for payor added services. */
  detail?: Maybe<Array<Maybe<FHIRClaimResponseaddItemdetail>>>,
};

export type FHIRClaimResponseaddItemdetail = {
   __typename?: 'FHIRClaimResponseaddItemdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The third-tier service adjudications for payor added services. */
  subDetail?: Maybe<Array<Maybe<FHIRClaimResponseaddItemdetailsubDetail>>>,
};

export type FHIRClaimResponseaddItemdetailsubDetail = {
   __typename?: 'FHIRClaimResponseaddItemdetailsubDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
};

/** Where the product or service was provided. */
export type FHIRClaimResponseaddItemlocationReference_locationReference_Union = FHIRLocation;

/** The providers who are authorized for the services rendered to the patient. */
export type FHIRClaimResponseaddItemprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Request for additional supporting or authorizing information. */
export type FHIRClaimResponsecommunicationRequest_communicationRequest_Union = FHIRCommunicationRequest;

export type FHIRClaimResponseerror = {
   __typename?: 'FHIRClaimResponseerror',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The sequence number of the line item submitted which contains the error. This
   * value is omitted when the error occurs outside of the item structure.
 */
  itemSequence?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The sequence number of the detail within the line item submitted which
   * contains the error. This value is omitted when the error occurs outside of the
   * item structure.
 */
  detailSequence?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The sequence number of the sub-detail within the detail within the line item
   * submitted which contains the error. This value is omitted when the error
   * occurs outside of the item structure.
 */
  subDetailSequence?: Maybe<Scalars['FHIRPositiveInt']>,
  /** An error code, from a specified code system, which details why the claim could not be adjudicated. */
  code: FHIRCodeableConcept,
};

export type FHIRClaimResponseinsurance = {
   __typename?: 'FHIRClaimResponseinsurance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A number to uniquely identify insurance entries and provide a sequence of
   * coverages to convey coordination of benefit order.
 */
  sequence: Scalars['FHIRPositiveInt'],
  /** A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true. */
  focal: Scalars['Boolean'],
  /** 
 * Reference to the insurance card level information contained in the Coverage
   * resource. The coverage issuing insurer will use these details to locate the
   * patient's actual coverage within the insurer's information system.
 */
  coverage: FHIRClaimResponseinsurancecoverage_coverage_Union,
  /** A business agreement number established between the provider and the insurer for special business processing purposes. */
  businessArrangement?: Maybe<Scalars['String']>,
  /** The result of the adjudication of the line items for the Coverage specified in this insurance. */
  claimResponse?: Maybe<FHIRClaimResponseinsuranceclaimResponse_claimResponse_Union>,
};

/** The result of the adjudication of the line items for the Coverage specified in this insurance. */
export type FHIRClaimResponseinsuranceclaimResponse_claimResponse_Union = FHIRClaimResponse;

/** 
 * Reference to the insurance card level information contained in the Coverage
 * resource. The coverage issuing insurer will use these details to locate the
 * patient's actual coverage within the insurer's information system.
 */
export type FHIRClaimResponseinsurancecoverage_coverage_Union = FHIRCoverage;

/** The party responsible for authorization, adjudication and reimbursement. */
export type FHIRClaimResponseinsurer_insurer_Union = FHIROrganization;

export type FHIRClaimResponseitem = {
   __typename?: 'FHIRClaimResponseitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely reference the claim item entries. */
  itemSequence: Scalars['FHIRPositiveInt'],
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** 
 * If this item is a group then the values here are a summary of the adjudication
   * of the detail items. If this item is a simple product or service then this is
   * the result of the adjudication of this item.
 */
  adjudication?: Maybe<Array<FHIRClaimResponseitemadjudication>>,
  /** A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items. */
  detail?: Maybe<Array<Maybe<FHIRClaimResponseitemdetail>>>,
};

export type FHIRClaimResponseitemadjudication = {
   __typename?: 'FHIRClaimResponseitemadjudication',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code to indicate the information type of this adjudication record.
   * Information types may include the value submitted, maximum values or
   * percentages allowed or payable under the plan, amounts that: the patient is
   * responsible for in aggregate or pertaining to this item; amounts paid by other
   * coverages; and, the benefit payable for this item.
 */
  category: FHIRCodeableConcept,
  /** A code supporting the understanding of the adjudication result and explaining variance from expected amount. */
  reason?: Maybe<FHIRCodeableConcept>,
  /** Monetary amount associated with the category. */
  amount?: Maybe<FHIRMoney>,
  /** A non-monetary value associated with the category. Mutually exclusive to the amount element above. */
  value?: Maybe<Scalars['Float']>,
};

export type FHIRClaimResponseitemdetail = {
   __typename?: 'FHIRClaimResponseitemdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely reference the claim detail entry. */
  detailSequence: Scalars['FHIRPositiveInt'],
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** A sub-detail adjudication of a simple product or service. */
  subDetail?: Maybe<Array<Maybe<FHIRClaimResponseitemdetailsubDetail>>>,
};

export type FHIRClaimResponseitemdetailsubDetail = {
   __typename?: 'FHIRClaimResponseitemdetailsubDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely reference the claim sub-detail entry. */
  subDetailSequence: Scalars['FHIRPositiveInt'],
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
};

/** 
 * The party to whom the professional services and/or products have been supplied
 * or are being considered and for whom actual for facast reimbursement is sought.
 */
export type FHIRClaimResponsepatient_patient_Union = FHIRPatient;

export type FHIRClaimResponsepayment = {
   __typename?: 'FHIRClaimResponsepayment',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Whether this represents partial or complete payment of the benefits payable. */
  type: FHIRCodeableConcept,
  /** 
 * Total amount of all adjustments to this payment included in this transaction
   * which are not related to this claim's adjudication.
 */
  adjustment?: Maybe<FHIRMoney>,
  /** Reason for the payment adjustment. */
  adjustmentReason?: Maybe<FHIRCodeableConcept>,
  /** Estimated date the payment will be issued or the actual issue date of payment. */
  date?: Maybe<Scalars['FHIRDate']>,
  /** Benefits payable less any payment adjustment. */
  amount: FHIRMoney,
  /** Issuer's unique identifier for the payment instrument. */
  identifier?: Maybe<FHIRIdentifier>,
};

export type FHIRClaimResponseprocessNote = {
   __typename?: 'FHIRClaimResponseprocessNote',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify a note entry. */
  number?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The business purpose of the note text. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** The explanation or description associated with the processing. */
  text: Scalars['String'],
  /** A code to define the language used in the text of the note. */
  language?: Maybe<FHIRCodeableConcept>,
};

/** Original request resource reference. */
export type FHIRClaimResponserequest_request_Union = FHIRClaim;

/** The provider which is responsible for the claim, predetermination or preauthorization. */
export type FHIRClaimResponserequestor_requestor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRClaimResponsetotal = {
   __typename?: 'FHIRClaimResponsetotal',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code to indicate the information type of this adjudication record.
   * Information types may include: the value submitted, maximum values or
   * percentages allowed or payable under the plan, amounts that the patient is
   * responsible for in aggregate or pertaining to this item, amounts paid by other
   * coverages, and the benefit payable for this item.
 */
  category: FHIRCodeableConcept,
  /** Monetary total amount associated with the category. */
  amount: FHIRMoney,
};

export type FHIRClaimsupportingInfo = {
   __typename?: 'FHIRClaimsupportingInfo',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify supporting information entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The general class of the information supplied: information; exception; accident, employment; onset, etc. */
  category: FHIRCodeableConcept,
  /** 
 * System and code pertaining to the specific information regarding special
   * conditions relating to the setting, treatment or patient  for which care is sought.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The date when or period to which this information refers. */
  timingDate?: Maybe<Scalars['FHIRDate']>,
  /** The date when or period to which this information refers. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueString?: Maybe<Scalars['String']>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueReference?: Maybe<FHIRClaimsupportingInfovalueReference_valueReference_Union>,
  /** Provides the reason in the situation where a reason code is required in addition to the content. */
  reason?: Maybe<FHIRCodeableConcept>,
};

/** 
 * Additional data or information such as resources, documents, images etc.
 * including references to the data or the actual inclusion of the data.
 */
export type FHIRClaimsupportingInfovalueReference_valueReference_Union = FHIRResource;

/** 
 * A record of a clinical assessment performed to determine what problem(s) may
 * affect the patient and before planning the treatments or management strategies
 * that are best to manage a patient's condition. Assessments are often 1:1 with a
 * clinical consultation / encounter,  but this varies greatly depending on the
 * clinical workflow. This resource is called 'ClinicalImpression' rather than
 * 'ClinicalAssessment' to avoid confusion with the recording of assessment tools
 * such as Apgar score.
 */
export type FHIRClinicalImpression = {
   __typename?: 'FHIRClinicalImpression',
  /** Type of resource */
  resourceType: FHIRClinicalImpression_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this clinical impression by the performer or
   * other systems which remain constant as the resource is updated and propagates
   * from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Identifies the workflow status of the assessment. */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the ClinicalImpression. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** Categorizes the type of clinical assessment performed. */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * A summary of the context and/or cause of the assessment - why / where it was
   * performed, and what patient events/status prompted it.
 */
  description?: Maybe<Scalars['String']>,
  /** The patient or group of individuals assessed as part of this record. */
  subject: FHIRClinicalImpressionsubject_subject_Union,
  /** 
 * The Encounter during which this ClinicalImpression was created or to which the
   * creation of this record is tightly associated.
 */
  encounter?: Maybe<FHIRClinicalImpressionencounter_encounter_Union>,
  /** The point in time or period over which the subject was assessed. */
  effectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The point in time or period over which the subject was assessed. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** Indicates when the documentation of the assessment was complete. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The clinician performing the assessment. */
  assessor?: Maybe<FHIRClinicalImpressionassessor_assessor_Union>,
  /** 
 * A reference to the last assessment that was conducted on this patient.
   * Assessments are often/usually ongoing in nature; a care provider (practitioner
   * or team) will make new assessments on an ongoing basis as new data arises or
   * the patient's conditions changes.
 */
  previous?: Maybe<FHIRClinicalImpressionprevious_previous_Union>,
  /** A list of the relevant problems/conditions for a patient. */
  problem?: Maybe<Array<Maybe<FHIRClinicalImpressionproblem_problem_Union>>>,
  /** 
 * One or more sets of investigations (signs, symptoms, etc.). The actual
   * grouping of investigations varies greatly depending on the type and context of
   * the assessment. These investigations may include data generated during the
   * assessment process, or data previously generated and recorded that is
   * pertinent to the outcomes.
 */
  investigation?: Maybe<Array<Maybe<FHIRClinicalImpressioninvestigation>>>,
  /** 
 * Reference to a specific published clinical protocol that was followed during
   * this assessment, and/or that provides evidence in support of the diagnosis.
 */
  protocol?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A text summary of the investigations and the diagnosis. */
  summary?: Maybe<Scalars['String']>,
  /** Specific findings or diagnoses that were considered likely or relevant to ongoing treatment. */
  finding?: Maybe<Array<Maybe<FHIRClinicalImpressionfinding>>>,
  /** Estimate of likely outcome. */
  prognosisCodeableConcept?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** RiskAssessment expressing likely outcome. */
  prognosisReference?: Maybe<Array<Maybe<FHIRClinicalImpressionprognosisReference_prognosisReference_Union>>>,
  /** Information supporting the clinical impression. */
  supportingInfo?: Maybe<Array<Maybe<FHIRClinicalImpressionsupportingInfo_supportingInfo_Union>>>,
  /** 
 * Commentary about the impression, typically recorded after the impression
   * itself was made, though supplemental notes by the original author could also appear.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRClinicalImpression_Enum_schema {
  ClinicalImpression = 'ClinicalImpression'
}

/** The clinician performing the assessment. */
export type FHIRClinicalImpressionassessor_assessor_Union = FHIRPractitioner | FHIRPractitionerRole;

/** 
 * The Encounter during which this ClinicalImpression was created or to which the
 * creation of this record is tightly associated.
 */
export type FHIRClinicalImpressionencounter_encounter_Union = FHIREncounter;

export type FHIRClinicalImpressionfinding = {
   __typename?: 'FHIRClinicalImpressionfinding',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specific text or code for finding or diagnosis, which may include ruled-out or resolved conditions. */
  itemCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Specific reference for finding or diagnosis, which may include ruled-out or resolved conditions. */
  itemReference?: Maybe<FHIRClinicalImpressionfindingitemReference_itemReference_Union>,
  /** Which investigations support finding or diagnosis. */
  basis?: Maybe<Scalars['String']>,
};

/** Specific reference for finding or diagnosis, which may include ruled-out or resolved conditions. */
export type FHIRClinicalImpressionfindingitemReference_itemReference_Union = FHIRCondition | FHIRObservation | FHIRMedia;

export type FHIRClinicalImpressioninvestigation = {
   __typename?: 'FHIRClinicalImpressioninvestigation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A name/code for the group ('set') of investigations. Typically, this will be
   * something like 'signs', 'symptoms', 'clinical', 'diagnostic', but the list is
   * not constrained, and others such groups such as
   * (exposure|family|travel|nutritional) history may be used.
 */
  code: FHIRCodeableConcept,
  /** A record of a specific investigation that was undertaken. */
  item?: Maybe<Array<Maybe<FHIRClinicalImpressioninvestigationitem_item_Union>>>,
};

/** A record of a specific investigation that was undertaken. */
export type FHIRClinicalImpressioninvestigationitem_item_Union = FHIRObservation | FHIRQuestionnaireResponse | FHIRFamilyMemberHistory | FHIRDiagnosticReport | FHIRRiskAssessment | FHIRImagingStudy | FHIRMedia;

/** 
 * A reference to the last assessment that was conducted on this patient.
 * Assessments are often/usually ongoing in nature; a care provider (practitioner
 * or team) will make new assessments on an ongoing basis as new data arises or the
 * patient's conditions changes.
 */
export type FHIRClinicalImpressionprevious_previous_Union = FHIRClinicalImpression;

/** A list of the relevant problems/conditions for a patient. */
export type FHIRClinicalImpressionproblem_problem_Union = FHIRCondition | FHIRAllergyIntolerance;

/** RiskAssessment expressing likely outcome. */
export type FHIRClinicalImpressionprognosisReference_prognosisReference_Union = FHIRRiskAssessment;

/** The patient or group of individuals assessed as part of this record. */
export type FHIRClinicalImpressionsubject_subject_Union = FHIRPatient | FHIRGroup;

/** Information supporting the clinical impression. */
export type FHIRClinicalImpressionsupportingInfo_supportingInfo_Union = FHIRResource;


/** 
 * Base StructureDefinition for CodeableConcept Type: A concept that may be defined
 * by a formal reference to a terminology or ontology or may be provided by text.
 */
export type FHIRCodeableConcept = {
   __typename?: 'FHIRCodeableConcept',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A reference to a code defined by a terminology system. */
  coding?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * A human language representation of the concept as seen/selected/uttered by the
   * user who entered the data and/or which represents the intended meaning of the user.
 */
  text?: Maybe<Scalars['String']>,
};

/** 
 * Base StructureDefinition for CodeableConcept Type: A concept that may be defined
 * by a formal reference to a terminology or ontology or may be provided by text.
 */
export type FHIRCodeableConcept_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** A reference to a code defined by a terminology system. */
  coding?: Maybe<Array<Maybe<FHIRCoding_Input>>>,
  /** 
 * A human language representation of the concept as seen/selected/uttered by the
   * user who entered the data and/or which represents the intended meaning of the user.
 */
  _text?: Maybe<FHIRElement_Input>,
  /** 
 * A human language representation of the concept as seen/selected/uttered by the
   * user who entered the data and/or which represents the intended meaning of the user.
 */
  text?: Maybe<Scalars['String']>,
};

/** 
 * The CodeSystem resource is used to declare the existence of and describe a code
 * system or code system supplement and its key properties, and optionally define a
 * part or all of its content.
 */
export type FHIRCodeSystem = {
   __typename?: 'FHIRCodeSystem',
  /** Type of resource */
  resourceType: FHIRCodeSystem_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this code system when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this code system is (or
   * will be) published. This URL can be the target of a canonical reference. It
   * SHALL remain the same when the code system is stored on different servers.
   * This is used in [Coding](datatypes.html#Coding).system.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this code system when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the code system when
   * it is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the code system author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence. This is used in
   * [Coding](datatypes.html#Coding).version.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the code system. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the code system. */
  title?: Maybe<Scalars['String']>,
  /** The date (and optionally time) when the code system resource was created or revised. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this code system is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the code system was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the code system changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the code system. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the code system from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate code system instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the code system is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this code system is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the code system and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the code system.
 */
  copyright?: Maybe<Scalars['String']>,
  /** If code comparison is case sensitive when codes within this system are compared to each other. */
  caseSensitive?: Maybe<Scalars['Boolean']>,
  /** Canonical reference to the value set that contains the entire code system. */
  valueSet?: Maybe<Scalars['FHIRCanonical']>,
  /** The meaning of the hierarchy of concepts as represented in this resource. */
  hierarchyMeaning?: Maybe<Scalars['FHIRCode']>,
  /** The code system defines a compositional (post-coordination) grammar. */
  compositional?: Maybe<Scalars['Boolean']>,
  /** 
 * This flag is used to signify that the code system does not commit to concept
   * permanence across versions. If true, a version must be specified when
   * referencing this code system.
 */
  versionNeeded?: Maybe<Scalars['Boolean']>,
  /** 
 * The extent of the content of the code system (the concepts and codes it
   * defines) are represented in this resource instance.
 */
  content: Scalars['FHIRCode'],
  /** The canonical URL of the code system that this code system supplement is adding designations and properties to. */
  supplements?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * The total number of concepts defined by the code system. Where the code system
   * has a compositional grammar, the basis of this count is defined by the system steward.
 */
  count?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** A filter that can be used in a value set compose statement when selecting concepts using a filter. */
  filter?: Maybe<Array<Maybe<FHIRCodeSystemfilter>>>,
  /** A property defines an additional slot through which additional information can be provided about a concept. */
  property?: Maybe<Array<Maybe<FHIRCodeSystemproperty>>>,
  /** 
 * Concepts that are in the code system. The concept definitions are inherently
   * hierarchical, but the definitions must be consulted to determine what the
   * meanings of the hierarchical relationships are.
 */
  concept?: Maybe<Array<Maybe<FHIRCodeSystemconcept>>>,
};

export enum FHIRCodeSystem_Enum_schema {
  CodeSystem = 'CodeSystem'
}

export type FHIRCodeSystemconcept = {
   __typename?: 'FHIRCodeSystemconcept',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code - a text symbol - that uniquely identifies the concept within the code system. */
  code: Scalars['FHIRCode'],
  /** A human readable string that is the recommended default way to present this concept to a user. */
  display?: Maybe<Scalars['String']>,
  /** 
 * The formal definition of the concept. The code system resource does not make
   * formal definitions required, because of the prevalence of legacy systems.
   * However, they are highly recommended, as without them there is no formal
   * meaning associated with the concept.
 */
  definition?: Maybe<Scalars['String']>,
  /** 
 * Additional representations for the concept - other languages, aliases,
   * specialized purposes, used for particular purposes, etc.
 */
  designation?: Maybe<Array<Maybe<FHIRCodeSystemconceptdesignation>>>,
  /** A property value for this concept. */
  property?: Maybe<Array<Maybe<FHIRCodeSystemconceptproperty>>>,
};

export type FHIRCodeSystemconceptdesignation = {
   __typename?: 'FHIRCodeSystemconceptdesignation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The language this designation is defined for. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** A code that details how this designation would be used. */
  use?: Maybe<FHIRCoding>,
  /** The text value for this designation. */
  value: Scalars['String'],
};

export type FHIRCodeSystemconceptproperty = {
   __typename?: 'FHIRCodeSystemconceptproperty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code that is a reference to CodeSystem.property.code. */
  code: Scalars['FHIRCode'],
  /** The value of this property. */
  valueCode: Scalars['FHIRCode'],
  /** The value of this property. */
  valueCoding: FHIRCoding,
  /** The value of this property. */
  valueString: Scalars['String'],
  /** The value of this property. */
  valueInteger: Scalars['Int'],
  /** The value of this property. */
  valueBoolean: Scalars['Boolean'],
  /** The value of this property. */
  valueDateTime: Scalars['FHIRDateTime'],
  /** The value of this property. */
  valueDecimal: Scalars['Float'],
};

export type FHIRCodeSystemfilter = {
   __typename?: 'FHIRCodeSystemfilter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The code that identifies this filter when it is used as a filter in [ValueSet](valueset.html#).compose.include.filter. */
  code: Scalars['FHIRCode'],
  /** A description of how or why the filter is used. */
  description?: Maybe<Scalars['String']>,
  /** A list of operators that can be used with the filter. */
  operator?: Maybe<Array<Scalars['FHIRCode']>>,
  /** A description of what the value for the filter should be. */
  value: Scalars['String'],
};

export type FHIRCodeSystemproperty = {
   __typename?: 'FHIRCodeSystemproperty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code that is used to identify the property. The code is used internally (in
   * CodeSystem.concept.property.code) and also externally, such as in property filters.
 */
  code: Scalars['FHIRCode'],
  /** 
 * Reference to the formal meaning of the property. One possible source of
   * meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
 */
  uri?: Maybe<Scalars['FHIRUri']>,
  /** A description of the property- why it is defined, and how its value might be used. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The type of the property value. Properties of type 'code' contain a code
   * defined by the code system (e.g. a reference to another defined concept).
 */
  type: Scalars['FHIRCode'],
};

/** Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system. */
export type FHIRCoding = {
   __typename?: 'FHIRCoding',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The identification of the code system that defines the meaning of the symbol in the code. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The version of the code system which was used when choosing this code. Note
   * that a well-maintained code system does not need the version reported, because
   * the meaning of codes is consistent across versions. However this cannot
   * consistently be assured, and when the meaning is not guaranteed to be
   * consistent, the version SHOULD be exchanged.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A symbol in syntax defined by the system. The symbol may be a predefined code
   * or an expression in a syntax defined by the coding system (e.g.
   * post-coordination).
 */
  code?: Maybe<Scalars['FHIRCode']>,
  /** A representation of the meaning of the code in the system, following the rules of the system. */
  display?: Maybe<Scalars['String']>,
  /** Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays). */
  userSelected?: Maybe<Scalars['Boolean']>,
};

/** Base StructureDefinition for Coding Type: A reference to a code defined by a terminology system. */
export type FHIRCoding_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The identification of the code system that defines the meaning of the symbol in the code. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the code system that defines the meaning of the symbol in the code. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The version of the code system which was used when choosing this code. Note
   * that a well-maintained code system does not need the version reported, because
   * the meaning of codes is consistent across versions. However this cannot
   * consistently be assured, and when the meaning is not guaranteed to be
   * consistent, the version SHOULD be exchanged.
 */
  _version?: Maybe<FHIRElement_Input>,
  /** 
 * The version of the code system which was used when choosing this code. Note
   * that a well-maintained code system does not need the version reported, because
   * the meaning of codes is consistent across versions. However this cannot
   * consistently be assured, and when the meaning is not guaranteed to be
   * consistent, the version SHOULD be exchanged.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A symbol in syntax defined by the system. The symbol may be a predefined code
   * or an expression in a syntax defined by the coding system (e.g.
   * post-coordination).
 */
  _code?: Maybe<FHIRElement_Input>,
  /** 
 * A symbol in syntax defined by the system. The symbol may be a predefined code
   * or an expression in a syntax defined by the coding system (e.g.
   * post-coordination).
 */
  code?: Maybe<Scalars['FHIRCode']>,
  /** A representation of the meaning of the code in the system, following the rules of the system. */
  _display?: Maybe<FHIRElement_Input>,
  /** A representation of the meaning of the code in the system, following the rules of the system. */
  display?: Maybe<Scalars['String']>,
  /** Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays). */
  _userSelected?: Maybe<FHIRElement_Input>,
  /** Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays). */
  userSelected?: Maybe<Scalars['Boolean']>,
};

/** 
 * An occurrence of information being transmitted; e.g. an alert that was sent to a
 * responsible provider, a public health agency that was notified about a
 * reportable condition.
 */
export type FHIRCommunication = {
   __typename?: 'FHIRCommunication',
  /** Type of resource */
  resourceType: FHIRCommunication_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this communication by the performer or other
   * systems which remain constant as the resource is updated and propagates from
   * server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this Communication.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this Communication.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** An order, proposal or plan fulfilled in whole or in part by this Communication. */
  basedOn?: Maybe<Array<Maybe<FHIRCommunicationbasedOn_basedOn_Union>>>,
  /** Part of this action. */
  partOf?: Maybe<Array<Maybe<FHIRCommunicationpartOf_partOf_Union>>>,
  /** Prior communication that this communication is in response to. */
  inResponseTo?: Maybe<Array<Maybe<FHIRCommunicationinResponseTo_inResponseTo_Union>>>,
  /** The status of the transmission. */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the Communication. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** The type of message conveyed such as alert, notification, reminder, instruction, etc. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Characterizes how quickly the planned or in progress communication must be
   * addressed. Includes concepts such as stat, urgent, routine.
 */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** A channel that was used for this communication (e.g. email, fax). */
  medium?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The patient or group that was the focus of this communication. */
  subject?: Maybe<FHIRCommunicationsubject_subject_Union>,
  /** Description of the purpose/content, similar to a subject line in an email. */
  topic?: Maybe<FHIRCodeableConcept>,
  /** Other resources that pertain to this communication and to which this communication should be associated. */
  about?: Maybe<Array<Maybe<FHIRCommunicationabout_about_Union>>>,
  /** The Encounter during which this Communication was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRCommunicationencounter_encounter_Union>,
  /** The time when this communication was sent. */
  sent?: Maybe<Scalars['FHIRDateTime']>,
  /** The time when this communication arrived at the destination. */
  received?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The entity (e.g. person, organization, clinical information system, care team
   * or device) which was the target of the communication. If receipts need to be
   * tracked by an individual, a separate resource instance will need to be created
   * for each recipient.  Multiple recipient communications are intended where
   * either receipts are not tracked (e.g. a mass mail-out) or a receipt is
   * captured in aggregate (all emails confirmed received by a particular time).
 */
  recipient?: Maybe<Array<Maybe<FHIRCommunicationrecipient_recipient_Union>>>,
  /** The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication. */
  sender?: Maybe<FHIRCommunicationsender_sender_Union>,
  /** The reason or justification for the communication. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies this communication. */
  reasonReference?: Maybe<Array<Maybe<FHIRCommunicationreasonReference_reasonReference_Union>>>,
  /** Text, attachment(s), or resource(s) that was communicated to the recipient. */
  payload?: Maybe<Array<Maybe<FHIRCommunicationpayload>>>,
  /** Additional notes or commentary about the communication by the sender, receiver or other interested parties. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRCommunication_Enum_schema {
  Communication = 'Communication'
}

/** Other resources that pertain to this communication and to which this communication should be associated. */
export type FHIRCommunicationabout_about_Union = FHIRResource;

/** An order, proposal or plan fulfilled in whole or in part by this Communication. */
export type FHIRCommunicationbasedOn_basedOn_Union = FHIRResource;

/** The Encounter during which this Communication was created or to which the creation of this record is tightly associated. */
export type FHIRCommunicationencounter_encounter_Union = FHIREncounter;

/** Prior communication that this communication is in response to. */
export type FHIRCommunicationinResponseTo_inResponseTo_Union = FHIRCommunication;

/** Part of this action. */
export type FHIRCommunicationpartOf_partOf_Union = FHIRResource;

export type FHIRCommunicationpayload = {
   __typename?: 'FHIRCommunicationpayload',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A communicated content (or for multi-part communications, one portion of the communication). */
  contentString: Scalars['String'],
  /** A communicated content (or for multi-part communications, one portion of the communication). */
  contentAttachment: FHIRAttachment,
  /** A communicated content (or for multi-part communications, one portion of the communication). */
  contentReference: FHIRCommunicationpayloadcontentReference_contentReference_Union,
};

/** A communicated content (or for multi-part communications, one portion of the communication). */
export type FHIRCommunicationpayloadcontentReference_contentReference_Union = FHIRResource;

/** Indicates another resource whose existence justifies this communication. */
export type FHIRCommunicationreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** 
 * The entity (e.g. person, organization, clinical information system, care team or
 * device) which was the target of the communication. If receipts need to be
 * tracked by an individual, a separate resource instance will need to be created
 * for each recipient.  Multiple recipient communications are intended where either
 * receipts are not tracked (e.g. a mass mail-out) or a receipt is captured in
 * aggregate (all emails confirmed received by a particular time).
 */
export type FHIRCommunicationrecipient_recipient_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRGroup | FHIRCareTeam | FHIRHealthcareService;

/** 
 * A request to convey information; e.g. the CDS system proposes that an alert be
 * sent to a responsible provider, the CDS system proposes that the public health
 * agency be notified about a reportable condition.
 */
export type FHIRCommunicationRequest = {
   __typename?: 'FHIRCommunicationRequest',
  /** Type of resource */
  resourceType: FHIRCommunicationRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this communication request by the performer
   * or other systems which remain constant as the resource is updated and
   * propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A plan or proposal that is fulfilled in whole or in part by this request. */
  basedOn?: Maybe<Array<Maybe<FHIRCommunicationRequestbasedOn_basedOn_Union>>>,
  /** Completed or terminated request(s) whose function is taken by this new request. */
  replaces?: Maybe<Array<Maybe<FHIRCommunicationRequestreplaces_replaces_Union>>>,
  /** 
 * A shared identifier common to all requests that were authorized more or less
   * simultaneously by a single author, representing the identifier of the
   * requisition, prescription or similar form.
 */
  groupIdentifier?: Maybe<FHIRIdentifier>,
  /** The status of the proposal or order. */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the CommunicationRequest. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** The type of message to be sent such as alert, notification, reminder, instruction, etc. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** If true indicates that the CommunicationRequest is asking for the specified action to *not* occur. */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** A channel that was used for this communication (e.g. email, fax). */
  medium?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The patient or group that is the focus of this communication request. */
  subject?: Maybe<FHIRCommunicationRequestsubject_subject_Union>,
  /** Other resources that pertain to this communication request and to which this communication request should be associated. */
  about?: Maybe<Array<Maybe<FHIRCommunicationRequestabout_about_Union>>>,
  /** 
 * The Encounter during which this CommunicationRequest was created or to which
   * the creation of this record is tightly associated.
 */
  encounter?: Maybe<FHIRCommunicationRequestencounter_encounter_Union>,
  /** Text, attachment(s), or resource(s) to be communicated to the recipient. */
  payload?: Maybe<Array<Maybe<FHIRCommunicationRequestpayload>>>,
  /** The time when this communication is to occur. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The time when this communication is to occur. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** 
 * For draft requests, indicates the date of initial creation.  For requests with
   * other statuses, indicates the date of activation.
 */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The device, individual, or organization who initiated the request and has responsibility for its activation. */
  requester?: Maybe<FHIRCommunicationRequestrequester_requester_Union>,
  /** 
 * The entity (e.g. person, organization, clinical information system, device,
   * group, or care team) which is the intended target of the communication.
 */
  recipient?: Maybe<Array<Maybe<FHIRCommunicationRequestrecipient_recipient_Union>>>,
  /** 
 * The entity (e.g. person, organization, clinical information system, or device)
   * which is to be the source of the communication.
 */
  sender?: Maybe<FHIRCommunicationRequestsender_sender_Union>,
  /** Describes why the request is being made in coded or textual form. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies this request. */
  reasonReference?: Maybe<Array<Maybe<FHIRCommunicationRequestreasonReference_reasonReference_Union>>>,
  /** Comments made about the request by the requester, sender, recipient, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRCommunicationRequest_Enum_schema {
  CommunicationRequest = 'CommunicationRequest'
}

/** Other resources that pertain to this communication request and to which this communication request should be associated. */
export type FHIRCommunicationRequestabout_about_Union = FHIRResource;

/** A plan or proposal that is fulfilled in whole or in part by this request. */
export type FHIRCommunicationRequestbasedOn_basedOn_Union = FHIRResource;

/** 
 * The Encounter during which this CommunicationRequest was created or to which the
 * creation of this record is tightly associated.
 */
export type FHIRCommunicationRequestencounter_encounter_Union = FHIREncounter;

export type FHIRCommunicationRequestpayload = {
   __typename?: 'FHIRCommunicationRequestpayload',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The communicated content (or for multi-part communications, one portion of the communication). */
  contentString: Scalars['String'],
  /** The communicated content (or for multi-part communications, one portion of the communication). */
  contentAttachment: FHIRAttachment,
  /** The communicated content (or for multi-part communications, one portion of the communication). */
  contentReference: FHIRCommunicationRequestpayloadcontentReference_contentReference_Union,
};

/** The communicated content (or for multi-part communications, one portion of the communication). */
export type FHIRCommunicationRequestpayloadcontentReference_contentReference_Union = FHIRResource;

/** Indicates another resource whose existence justifies this request. */
export type FHIRCommunicationRequestreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** 
 * The entity (e.g. person, organization, clinical information system, device,
 * group, or care team) which is the intended target of the communication.
 */
export type FHIRCommunicationRequestrecipient_recipient_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRGroup | FHIRCareTeam | FHIRHealthcareService;

/** Completed or terminated request(s) whose function is taken by this new request. */
export type FHIRCommunicationRequestreplaces_replaces_Union = FHIRCommunicationRequest;

/** The device, individual, or organization who initiated the request and has responsibility for its activation. */
export type FHIRCommunicationRequestrequester_requester_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** 
 * The entity (e.g. person, organization, clinical information system, or device)
 * which is to be the source of the communication.
 */
export type FHIRCommunicationRequestsender_sender_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRHealthcareService;

/** The patient or group that is the focus of this communication request. */
export type FHIRCommunicationRequestsubject_subject_Union = FHIRPatient | FHIRGroup;

/** The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication. */
export type FHIRCommunicationsender_sender_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRHealthcareService;

/** The patient or group that was the focus of this communication. */
export type FHIRCommunicationsubject_subject_Union = FHIRPatient | FHIRGroup;

/** A compartment definition that defines how resources are accessed on a server. */
export type FHIRCompartmentDefinition = {
   __typename?: 'FHIRCompartmentDefinition',
  /** Type of resource */
  resourceType: FHIRCompartmentDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this compartment definition when it
   * is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this
   * compartment definition is (or will be) published. This URL can be the target
   * of a canonical reference. It SHALL remain the same when the compartment
   * definition is stored on different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * The identifier that is used to identify this version of the compartment
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the compartment definition
   * author and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the compartment definition. This name
   * should be usable as an identifier for the module by machine processing
   * applications such as code generation.
 */
  name: Scalars['String'],
  /** The status of this compartment definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this compartment definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the compartment definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the compartment definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the compartment definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the compartment definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate compartment
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** Explanation of why this compartment definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** Which compartment this definition describes. */
  code: Scalars['FHIRCode'],
  /** Whether the search syntax is supported,. */
  search: Scalars['Boolean'],
  /** Information about how a resource is related to the compartment. */
  resource?: Maybe<Array<Maybe<FHIRCompartmentDefinitionresource>>>,
};

export enum FHIRCompartmentDefinition_Enum_schema {
  CompartmentDefinition = 'CompartmentDefinition'
}

export type FHIRCompartmentDefinitionresource = {
   __typename?: 'FHIRCompartmentDefinitionresource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of a resource supported by the server. */
  code: Scalars['FHIRCode'],
  /** 
 * The name of a search parameter that represents the link to the compartment.
   * More than one may be listed because a resource may be linked to a compartment
   * in more than one way,.
 */
  param?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Additional documentation about the resource and compartment. */
  documentation?: Maybe<Scalars['String']>,
};

/** 
 * A set of healthcare-related information that is assembled together into a single
 * logical package that provides a single coherent statement of meaning,
 * establishes its own context and that has clinical attestation with regard to who
 * is making the statement. A Composition defines the structure and narrative
 * content necessary for a document. However, a Composition alone does not
 * constitute a document. Rather, the Composition must be the first entry in a
 * Bundle where Bundle.type=document, and any other resources referenced from
 * Composition must be included as subsequent entries in the Bundle (for example
 * Patient, Practitioner, Encounter, etc.).
 */
export type FHIRComposition = {
   __typename?: 'FHIRComposition',
  /** Type of resource */
  resourceType: FHIRComposition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A version-independent identifier for the Composition. This identifier stays
   * constant as the composition is changed over time.
 */
  identifier?: Maybe<FHIRIdentifier>,
  /** The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document. */
  status: Scalars['FHIRCode'],
  /** 
 * Specifies the particular kind of composition (e.g. History and Physical,
   * Discharge Summary, Progress Note). This usually equates to the purpose of
   * making the composition.
 */
  type: FHIRCodeableConcept,
  /** 
 * A categorization for the type of the composition - helps for indexing and
   * searching. This may be implied by or derived from the code specified in the
   * Composition Type.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Who or what the composition is about. The composition can be about a person,
   * (patient or healthcare practitioner), a device (e.g. a machine) or even a
   * group of subjects (such as a document about a herd of livestock, or a set of
   * patients that share a common exposure).
 */
  subject?: Maybe<FHIRCompositionsubject_subject_Union>,
  /** Describes the clinical encounter or type of care this documentation is associated with. */
  encounter?: Maybe<FHIRCompositionencounter_encounter_Union>,
  /** The composition editing time, when the composition was last logically changed by the author. */
  date: Scalars['FHIRDateTime'],
  /** Identifies who is responsible for the information in the composition, not necessarily who typed it in. */
  author?: Maybe<Array<FHIRCompositionauthor_author_Union>>,
  /** Official human-readable label for the composition. */
  title: Scalars['String'],
  /** The code specifying the level of confidentiality of the Composition. */
  confidentiality?: Maybe<Scalars['FHIRCode']>,
  /** A participant who has attested to the accuracy of the composition/document. */
  attester?: Maybe<Array<Maybe<FHIRCompositionattester>>>,
  /** 
 * Identifies the organization or group who is responsible for ongoing
   * maintenance of and access to the composition/document information.
 */
  custodian?: Maybe<FHIRCompositioncustodian_custodian_Union>,
  /** Relationships that this composition has with other compositions or documents that already exist. */
  relatesTo?: Maybe<Array<Maybe<FHIRCompositionrelatesTo>>>,
  /** The clinical service, such as a colonoscopy or an appendectomy, being documented. */
  event?: Maybe<Array<Maybe<FHIRCompositionevent>>>,
  /** The root of the sections that make up the composition. */
  section?: Maybe<Array<Maybe<FHIRCompositionsection>>>,
};

export enum FHIRComposition_Enum_schema {
  Composition = 'Composition'
}

export type FHIRCompositionattester = {
   __typename?: 'FHIRCompositionattester',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of attestation the authenticator offers. */
  mode: Scalars['FHIRCode'],
  /** When the composition was attested by the party. */
  time?: Maybe<Scalars['FHIRDateTime']>,
  /** Who attested the composition in the specified way. */
  party?: Maybe<FHIRCompositionattesterparty_party_Union>,
};

/** Who attested the composition in the specified way. */
export type FHIRCompositionattesterparty_party_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Identifies who is responsible for the information in the composition, not necessarily who typed it in. */
export type FHIRCompositionauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** 
 * Identifies the organization or group who is responsible for ongoing maintenance
 * of and access to the composition/document information.
 */
export type FHIRCompositioncustodian_custodian_Union = FHIROrganization;

/** Describes the clinical encounter or type of care this documentation is associated with. */
export type FHIRCompositionencounter_encounter_Union = FHIREncounter;

export type FHIRCompositionevent = {
   __typename?: 'FHIRCompositionevent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * This list of codes represents the main clinical acts, such as a colonoscopy or
   * an appendectomy, being documented. In some cases, the event is inherent in the
   * typeCode, such as a 'History and Physical Report' in which the procedure being
   * documented is necessarily a 'History and Physical' act.
 */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The period of time covered by the documentation. There is no assertion that
   * the documentation is a complete representation for this period, only that it
   * documents events during this time.
 */
  period?: Maybe<FHIRPeriod>,
  /** 
 * The description and/or reference of the event(s) being documented. For
   * example, this could be used to document such a colonoscopy or an appendectomy.
 */
  detail?: Maybe<Array<Maybe<FHIRCompositioneventdetail_detail_Union>>>,
};

/** 
 * The description and/or reference of the event(s) being documented. For example,
 * this could be used to document such a colonoscopy or an appendectomy.
 */
export type FHIRCompositioneventdetail_detail_Union = FHIRResource;

export type FHIRCompositionrelatesTo = {
   __typename?: 'FHIRCompositionrelatesTo',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relationship that this composition has with anther composition or document. */
  code: Scalars['FHIRCode'],
  /** The target composition/document of this relationship. */
  targetIdentifier: FHIRIdentifier,
  /** The target composition/document of this relationship. */
  targetReference: FHIRCompositionrelatesTotargetReference_targetReference_Union,
};

/** The target composition/document of this relationship. */
export type FHIRCompositionrelatesTotargetReference_targetReference_Union = FHIRComposition;

export type FHIRCompositionsection = {
   __typename?: 'FHIRCompositionsection',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The label for this particular section.  This will be part of the rendered
   * content for the document, and is often used to build a table of contents.
 */
  title?: Maybe<Scalars['String']>,
  /** A code identifying the kind of content contained within the section. This must be consistent with the section title. */
  code?: Maybe<FHIRCodeableConcept>,
  /** Identifies who is responsible for the information in this section, not necessarily who typed it in. */
  author?: Maybe<Array<Maybe<FHIRCompositionsectionauthor_author_Union>>>,
  /** 
 * The actual focus of the section when it is not the subject of the composition,
   * but instead represents something or someone associated with the subject such
   * as (for a patient subject) a spouse, parent, fetus, or donor. If not focus is
   * specified, the focus is assumed to be focus of the parent section, or, for a
   * section in the Composition itself, the subject of the composition. Sections
   * with a focus SHALL only include resources where the logical subject (patient,
   * subject, focus, etc.) matches the section focus, or the resources have no
   * logical subject (few resources).
 */
  focus?: Maybe<FHIRCompositionsectionfocus_focus_Union>,
  /** 
 * A human-readable narrative that contains the attested content of the section,
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * How the entry list was prepared - whether it is a working list that is
   * suitable for being maintained on an ongoing basis, or if it represents a
   * snapshot of a list of items from another source, or whether it is a prepared
   * list where items may be marked as added, modified or deleted.
 */
  mode?: Maybe<Scalars['FHIRCode']>,
  /** Specifies the order applied to the items in the section entries. */
  orderedBy?: Maybe<FHIRCodeableConcept>,
  /** A reference to the actual resource from which the narrative in the section is derived. */
  entry?: Maybe<Array<Maybe<FHIRCompositionsectionentry_entry_Union>>>,
  /** If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. */
  emptyReason?: Maybe<FHIRCodeableConcept>,
};

/** Identifies who is responsible for the information in this section, not necessarily who typed it in. */
export type FHIRCompositionsectionauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** A reference to the actual resource from which the narrative in the section is derived. */
export type FHIRCompositionsectionentry_entry_Union = FHIRResource;

/** 
 * The actual focus of the section when it is not the subject of the composition,
 * but instead represents something or someone associated with the subject such as
 * (for a patient subject) a spouse, parent, fetus, or donor. If not focus is
 * specified, the focus is assumed to be focus of the parent section, or, for a
 * section in the Composition itself, the subject of the composition. Sections with
 * a focus SHALL only include resources where the logical subject (patient,
 * subject, focus, etc.) matches the section focus, or the resources have no
 * logical subject (few resources).
 */
export type FHIRCompositionsectionfocus_focus_Union = FHIRResource;

/** 
 * Who or what the composition is about. The composition can be about a person,
 * (patient or healthcare practitioner), a device (e.g. a machine) or even a group
 * of subjects (such as a document about a herd of livestock, or a set of patients
 * that share a common exposure).
 */
export type FHIRCompositionsubject_subject_Union = FHIRResource;

/** 
 * A statement of relationships from one set of concepts to one or more other
 * concepts - either concepts in code systems, or data element/data element
 * concepts, or classes in class models.
 */
export type FHIRConceptMap = {
   __typename?: 'FHIRConceptMap',
  /** Type of resource */
  resourceType: FHIRConceptMap_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this concept map when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this concept map is (or
   * will be) published. This URL can be the target of a canonical reference. It
   * SHALL remain the same when the concept map is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this concept map when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * The identifier that is used to identify this version of the concept map when
   * it is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the concept map author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the concept map. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the concept map. */
  title?: Maybe<Scalars['String']>,
  /** The status of this concept map. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this concept map is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the concept map was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the concept map changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the concept map. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the concept map from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate concept map instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the concept map is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this concept map is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the concept map and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the concept map.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * Identifier for the source value set that contains the concepts that are being
   * mapped and provides context for the mappings.
 */
  sourceUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Identifier for the source value set that contains the concepts that are being
   * mapped and provides context for the mappings.
 */
  sourceCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * The target value set provides context for the mappings. Note that the mapping
   * is made between concepts, not between value sets, but the value set provides
   * important context about how the concept mapping choices are made.
 */
  targetUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The target value set provides context for the mappings. Note that the mapping
   * is made between concepts, not between value sets, but the value set provides
   * important context about how the concept mapping choices are made.
 */
  targetCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** A group of mappings that all have the same source and target system. */
  group?: Maybe<Array<Maybe<FHIRConceptMapgroup>>>,
};

export enum FHIRConceptMap_Enum_schema {
  ConceptMap = 'ConceptMap'
}

export type FHIRConceptMapgroup = {
   __typename?: 'FHIRConceptMapgroup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An absolute URI that identifies the source system where the concepts to be mapped are defined. */
  source?: Maybe<Scalars['FHIRUri']>,
  /** The specific version of the code system, as determined by the code system authority. */
  sourceVersion?: Maybe<Scalars['String']>,
  /** An absolute URI that identifies the target system that the concepts will be mapped to. */
  target?: Maybe<Scalars['FHIRUri']>,
  /** The specific version of the code system, as determined by the code system authority. */
  targetVersion?: Maybe<Scalars['String']>,
  /** Mappings for an individual concept in the source to one or more concepts in the target. */
  element?: Maybe<Array<FHIRConceptMapgroupelement>>,
  /** 
 * What to do when there is no mapping for the source concept. 'Unmapped' does
   * not include codes that are unmatched, and the unmapped element is ignored in a
   * code is specified to have equivalence = unmatched.
 */
  unmapped?: Maybe<FHIRConceptMapgroupunmapped>,
};

export type FHIRConceptMapgroupelement = {
   __typename?: 'FHIRConceptMapgroupelement',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identity (code or path) or the element/item being mapped. */
  code?: Maybe<Scalars['FHIRCode']>,
  /** The display for the code. The display is only provided to help editors when editing the concept map. */
  display?: Maybe<Scalars['String']>,
  /** A concept from the target value set that this concept maps to. */
  target?: Maybe<Array<Maybe<FHIRConceptMapgroupelementtarget>>>,
};

export type FHIRConceptMapgroupelementtarget = {
   __typename?: 'FHIRConceptMapgroupelementtarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identity (code or path) or the element/item that the map refers to. */
  code?: Maybe<Scalars['FHIRCode']>,
  /** The display for the code. The display is only provided to help editors when editing the concept map. */
  display?: Maybe<Scalars['String']>,
  /** 
 * The equivalence between the source and target concepts (counting for the
   * dependencies and products). The equivalence is read from target to source
   * (e.g. the target is 'wider' than the source).
 */
  equivalence: Scalars['FHIRCode'],
  /** A description of status/issues in mapping that conveys additional information not represented in  the structured data. */
  comment?: Maybe<Scalars['String']>,
  /** 
 * A set of additional dependencies for this mapping to hold. This mapping is
   * only applicable if the specified element can be resolved, and it has the
   * specified value.
 */
  dependsOn?: Maybe<Array<Maybe<FHIRConceptMapgroupelementtargetdependsOn>>>,
};

export type FHIRConceptMapgroupelementtargetdependsOn = {
   __typename?: 'FHIRConceptMapgroupelementtargetdependsOn',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A reference to an element that holds a coded value that corresponds to a code
   * system property. The idea is that the information model carries an element
   * somewhere that is labeled to correspond with a code system property.
 */
  property: Scalars['FHIRUri'],
  /** 
 * An absolute URI that identifies the code system of the dependency code (if the
   * source/dependency is a value set that crosses code systems).
 */
  system?: Maybe<Scalars['FHIRCanonical']>,
  /** Identity (code or path) or the element/item/ValueSet/text that the map depends on / refers to. */
  value: Scalars['String'],
  /** The display for the code. The display is only provided to help editors when editing the concept map. */
  display?: Maybe<Scalars['String']>,
};

export type FHIRConceptMapgroupunmapped = {
   __typename?: 'FHIRConceptMapgroupunmapped',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Defines which action to take if there is no match for the source concept in
   * the target system designated for the group. One of 3 actions are possible: use
   * the unmapped code (this is useful when doing a mapping between versions, and
   * only a few codes have changed), use a fixed code (a default code), or
   * alternatively, a reference to a different concept map can be provided (by
   * canonical URL).
 */
  mode: Scalars['FHIRCode'],
  /** The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code. */
  code?: Maybe<Scalars['FHIRCode']>,
  /** The display for the code. The display is only provided to help editors when editing the concept map. */
  display?: Maybe<Scalars['String']>,
  /** 
 * The canonical reference to an additional ConceptMap resource instance to use
   * for mapping if this ConceptMap resource contains no matching mapping for the
   * source concept.
 */
  url?: Maybe<Scalars['FHIRCanonical']>,
};

/** 
 * A clinical condition, problem, diagnosis, or other event, situation, issue, or
 * clinical concept that has risen to a level of concern.
 */
export type FHIRCondition = {
   __typename?: 'FHIRCondition',
  /** Type of resource */
  resourceType: FHIRCondition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this condition by the performer or other
   * systems which remain constant as the resource is updated and propagates from
   * server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The clinical status of the condition. */
  clinicalStatus?: Maybe<FHIRCodeableConcept>,
  /** The verification status to support the clinical status of the condition. */
  verificationStatus?: Maybe<FHIRCodeableConcept>,
  /** A category assigned to the condition. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A subjective assessment of the severity of the condition as evaluated by the clinician. */
  severity?: Maybe<FHIRCodeableConcept>,
  /** Identification of the condition, problem or diagnosis. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The anatomical location where this condition manifests itself. */
  bodySite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates the patient or group who the condition record is associated with. */
  subject: FHIRConditionsubject_subject_Union,
  /** The Encounter during which this Condition was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRConditionencounter_encounter_Union>,
  /** Estimated or actual date or date-time  the condition began, in the opinion of the clinician. */
  onsetDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Estimated or actual date or date-time  the condition began, in the opinion of the clinician. */
  onsetAge?: Maybe<FHIRAge>,
  /** Estimated or actual date or date-time  the condition began, in the opinion of the clinician. */
  onsetPeriod?: Maybe<FHIRPeriod>,
  /** Estimated or actual date or date-time  the condition began, in the opinion of the clinician. */
  onsetRange?: Maybe<FHIRRange>,
  /** Estimated or actual date or date-time  the condition began, in the opinion of the clinician. */
  onsetString?: Maybe<Scalars['String']>,
  /** 
 * The date or estimated date that the condition resolved or went into remission.
   * This is called 'abatement' because of the many overloaded connotations
   * associated with 'remission' or 'resolution' - Conditions are never really
   * resolved, but they can abate.
 */
  abatementDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The date or estimated date that the condition resolved or went into remission.
   * This is called 'abatement' because of the many overloaded connotations
   * associated with 'remission' or 'resolution' - Conditions are never really
   * resolved, but they can abate.
 */
  abatementAge?: Maybe<FHIRAge>,
  /** 
 * The date or estimated date that the condition resolved or went into remission.
   * This is called 'abatement' because of the many overloaded connotations
   * associated with 'remission' or 'resolution' - Conditions are never really
   * resolved, but they can abate.
 */
  abatementPeriod?: Maybe<FHIRPeriod>,
  /** 
 * The date or estimated date that the condition resolved or went into remission.
   * This is called 'abatement' because of the many overloaded connotations
   * associated with 'remission' or 'resolution' - Conditions are never really
   * resolved, but they can abate.
 */
  abatementRange?: Maybe<FHIRRange>,
  /** 
 * The date or estimated date that the condition resolved or went into remission.
   * This is called 'abatement' because of the many overloaded connotations
   * associated with 'remission' or 'resolution' - Conditions are never really
   * resolved, but they can abate.
 */
  abatementString?: Maybe<Scalars['String']>,
  /** 
 * The recordedDate represents when this particular Condition record was created
   * in the system, which is often a system-generated date.
 */
  recordedDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Individual who recorded the record and takes responsibility for its content. */
  recorder?: Maybe<FHIRConditionrecorder_recorder_Union>,
  /** Individual who is making the condition statement. */
  asserter?: Maybe<FHIRConditionasserter_asserter_Union>,
  /** Clinical stage or grade of a condition. May include formal severity assessments. */
  stage?: Maybe<Array<Maybe<FHIRConditionstage>>>,
  /** 
 * Supporting evidence / manifestations that are the basis of the Condition's
   * verification status, such as evidence that confirmed or refuted the condition.
 */
  evidence?: Maybe<Array<Maybe<FHIRConditionevidence>>>,
  /** 
 * Additional information about the Condition. This is a general notes/comments
   * entry  for description of the Condition, its diagnosis and prognosis.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRCondition_Enum_schema {
  Condition = 'Condition'
}

/** Individual who is making the condition statement. */
export type FHIRConditionasserter_asserter_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson;

/** The Encounter during which this Condition was created or to which the creation of this record is tightly associated. */
export type FHIRConditionencounter_encounter_Union = FHIREncounter;

export type FHIRConditionevidence = {
   __typename?: 'FHIRConditionevidence',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A manifestation or symptom that led to the recording of this condition. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Links to other relevant information, including pathology reports. */
  detail?: Maybe<Array<Maybe<FHIRConditionevidencedetail_detail_Union>>>,
};

/** Links to other relevant information, including pathology reports. */
export type FHIRConditionevidencedetail_detail_Union = FHIRResource;

/** Individual who recorded the record and takes responsibility for its content. */
export type FHIRConditionrecorder_recorder_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson;

export type FHIRConditionstage = {
   __typename?: 'FHIRConditionstage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A simple summary of the stage such as 'Stage 3'. The determination of the stage is disease-specific. */
  summary?: Maybe<FHIRCodeableConcept>,
  /** Reference to a formal record of the evidence on which the staging assessment is based. */
  assessment?: Maybe<Array<Maybe<FHIRConditionstageassessment_assessment_Union>>>,
  /** The kind of staging, such as pathological or clinical staging. */
  type?: Maybe<FHIRCodeableConcept>,
};

/** Reference to a formal record of the evidence on which the staging assessment is based. */
export type FHIRConditionstageassessment_assessment_Union = FHIRClinicalImpression | FHIRDiagnosticReport | FHIRObservation;

/** Indicates the patient or group who the condition record is associated with. */
export type FHIRConditionsubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * A record of a healthcare consumer’s  choices, which permits or denies identified
 * recipient(s) or recipient role(s) to perform one or more actions within a given
 * policy context, for specific purposes and periods of time.
 */
export type FHIRConsent = {
   __typename?: 'FHIRConsent',
  /** Type of resource */
  resourceType: FHIRConsent_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for this copy of the Consent Statement. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the current state of this consent. */
  status: Scalars['FHIRCode'],
  /** A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible. */
  scope: FHIRCodeableConcept,
  /** 
 * A classification of the type of consents found in the statement. This element
   * supports indexing and retrieval of consent statements.
 */
  category?: Maybe<Array<FHIRCodeableConcept>>,
  /** The patient/healthcare consumer to whom this consent applies. */
  patient?: Maybe<FHIRConsentpatient_patient_Union>,
  /** When this  Consent was issued / created / indexed. */
  dateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Either the Grantor, which is the entity responsible for granting the rights
   * listed in a Consent Directive or the Grantee, which is the entity responsible
   * for complying with the Consent Directive, including any obligations or
   * limitations on authorizations and enforcement of prohibitions.
 */
  performer?: Maybe<Array<Maybe<FHIRConsentperformer_performer_Union>>>,
  /** The organization that manages the consent, and the framework within which it is executed. */
  organization?: Maybe<Array<Maybe<FHIRConsentorganization_organization_Union>>>,
  /** 
 * The source on which this consent statement is based. The source might be a
   * scanned original paper form, or a reference to a consent that links back to
   * such a source, a reference to a document repository (e.g. XDS) that stores the
   * original consent document.
 */
  sourceAttachment?: Maybe<FHIRAttachment>,
  /** 
 * The source on which this consent statement is based. The source might be a
   * scanned original paper form, or a reference to a consent that links back to
   * such a source, a reference to a document repository (e.g. XDS) that stores the
   * original consent document.
 */
  sourceReference?: Maybe<FHIRConsentsourceReference_sourceReference_Union>,
  /** 
 * The references to the policies that are included in this consent scope.
   * Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
  policy?: Maybe<Array<Maybe<FHIRConsentpolicy>>>,
  /** A reference to the specific base computable regulation or policy. */
  policyRule?: Maybe<FHIRCodeableConcept>,
  /** 
 * Whether a treatment instruction (e.g. artificial respiration yes or no) was
   * verified with the patient, his/her family or another authorized person.
 */
  verification?: Maybe<Array<Maybe<FHIRConsentverification>>>,
  /** An exception to the base policy of this consent. An exception can be an addition or removal of access permissions. */
  provision?: Maybe<FHIRConsentprovision>,
};

export enum FHIRConsent_Enum_schema {
  Consent = 'Consent'
}

/** The organization that manages the consent, and the framework within which it is executed. */
export type FHIRConsentorganization_organization_Union = FHIROrganization;

/** The patient/healthcare consumer to whom this consent applies. */
export type FHIRConsentpatient_patient_Union = FHIRPatient;

/** 
 * Either the Grantor, which is the entity responsible for granting the rights
 * listed in a Consent Directive or the Grantee, which is the entity responsible
 * for complying with the Consent Directive, including any obligations or
 * limitations on authorizations and enforcement of prohibitions.
 */
export type FHIRConsentperformer_performer_Union = FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRRelatedPerson | FHIRPractitionerRole;

export type FHIRConsentpolicy = {
   __typename?: 'FHIRConsentpolicy',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Entity or Organization having regulatory jurisdiction or accountability for 
   * enforcing policies pertaining to Consent Directives.
 */
  authority?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The references to the policies that are included in this consent scope.
   * Policies may be organizational, but are often defined jurisdictionally, or in law.
 */
  uri?: Maybe<Scalars['FHIRUri']>,
};

export type FHIRConsentprovision = {
   __typename?: 'FHIRConsentprovision',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Action  to take - permit or deny - when the rule conditions are met.  Not
   * permitted in root rule, required in all nested rules.
 */
  type?: Maybe<Scalars['FHIRCode']>,
  /** The timeframe in this rule is valid. */
  period?: Maybe<FHIRPeriod>,
  /** 
 * Who or what is controlled by this rule. Use group to identify a set of actors
   * by some property they share (e.g. 'admitting officers').
 */
  actor?: Maybe<Array<Maybe<FHIRConsentprovisionactor>>>,
  /** Actions controlled by this Rule. */
  action?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A security label, comprised of 0..* security label fields (Privacy tags),
   * which define which resources are controlled by this exception.
 */
  securityLabel?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** The context of the activities a user is taking - why the user is accessing the data - that are controlled by this rule. */
  purpose?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * The class of information covered by this rule. The type can be a FHIR resource
   * type, a profile on a type, or a CDA document, or some other type that
   * indicates what sort of information the consent relates to.
 */
  class?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** If this code is found in an instance, then the rule applies. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Clinical or Operational Relevant period of time that bounds the data controlled by this rule. */
  dataPeriod?: Maybe<FHIRPeriod>,
  /** The resources controlled by this rule if specific resources are referenced. */
  data?: Maybe<Array<Maybe<FHIRConsentprovisiondata>>>,
};

export type FHIRConsentprovisionactor = {
   __typename?: 'FHIRConsentprovisionactor',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** How the individual is involved in the resources content that is described in the exception. */
  role: FHIRCodeableConcept,
  /** 
 * The resource that identifies the actor. To identify actors by type, use group
   * to identify a set of actors by some property they share (e.g. 'admitting officers').
 */
  reference: FHIRConsentprovisionactorreference_reference_Union,
};

/** 
 * The resource that identifies the actor. To identify actors by type, use group to
 * identify a set of actors by some property they share (e.g. 'admitting officers').
 */
export type FHIRConsentprovisionactorreference_reference_Union = FHIRDevice | FHIRGroup | FHIRCareTeam | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRRelatedPerson | FHIRPractitionerRole;

export type FHIRConsentprovisiondata = {
   __typename?: 'FHIRConsentprovisiondata',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** How the resource reference is interpreted when testing consent restrictions. */
  meaning: Scalars['FHIRCode'],
  /** A reference to a specific resource that defines which resources are covered by this consent. */
  reference: FHIRConsentprovisiondatareference_reference_Union,
};

/** A reference to a specific resource that defines which resources are covered by this consent. */
export type FHIRConsentprovisiondatareference_reference_Union = FHIRResource;

/** 
 * The source on which this consent statement is based. The source might be a
 * scanned original paper form, or a reference to a consent that links back to such
 * a source, a reference to a document repository (e.g. XDS) that stores the
 * original consent document.
 */
export type FHIRConsentsourceReference_sourceReference_Union = FHIRConsent | FHIRDocumentReference | FHIRContract | FHIRQuestionnaireResponse;

export type FHIRConsentverification = {
   __typename?: 'FHIRConsentverification',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Has the instruction been verified. */
  verified: Scalars['Boolean'],
  /** Who verified the instruction (Patient, Relative or other Authorized Person). */
  verifiedWith?: Maybe<FHIRConsentverificationverifiedWith_verifiedWith_Union>,
  /** Date verification was collected. */
  verificationDate?: Maybe<Scalars['FHIRDateTime']>,
};

/** Who verified the instruction (Patient, Relative or other Authorized Person). */
export type FHIRConsentverificationverifiedWith_verifiedWith_Union = FHIRPatient | FHIRRelatedPerson;

/** Base StructureDefinition for ContactDetail Type: Specifies contact information for a person or organization. */
export type FHIRContactDetail = {
   __typename?: 'FHIRContactDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of an individual to contact. */
  name?: Maybe<Scalars['String']>,
  /** The contact details for the individual (if a name was provided) or the organization. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
};

/** Base StructureDefinition for ContactDetail Type: Specifies contact information for a person or organization. */
export type FHIRContactDetail_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The name of an individual to contact. */
  _name?: Maybe<FHIRElement_Input>,
  /** The name of an individual to contact. */
  name?: Maybe<Scalars['String']>,
  /** The contact details for the individual (if a name was provided) or the organization. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint_Input>>>,
};

/** 
 * Base StructureDefinition for ContactPoint Type: Details for all kinds of
 * technology mediated contact points for a person or organization, including
 * telephone, email, etc.
 */
export type FHIRContactPoint = {
   __typename?: 'FHIRContactPoint',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Telecommunications form for contact point - what communications system is required to make use of the contact. */
  system?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The actual contact point details, in a form that is meaningful to the
   * designated communication system (i.e. phone number or email address).
 */
  value?: Maybe<Scalars['String']>,
  /** Identifies the purpose for the contact point. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies a preferred order in which to use a set of contacts. ContactPoints
   * with lower rank values are more preferred than those with higher rank values.
 */
  rank?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Time period when the contact point was/is in use. */
  period?: Maybe<FHIRPeriod>,
};

/** 
 * Base StructureDefinition for ContactPoint Type: Details for all kinds of
 * technology mediated contact points for a person or organization, including
 * telephone, email, etc.
 */
export type FHIRContactPoint_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Telecommunications form for contact point - what communications system is required to make use of the contact. */
  _system?: Maybe<FHIRElement_Input>,
  /** Telecommunications form for contact point - what communications system is required to make use of the contact. */
  system?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The actual contact point details, in a form that is meaningful to the
   * designated communication system (i.e. phone number or email address).
 */
  _value?: Maybe<FHIRElement_Input>,
  /** 
 * The actual contact point details, in a form that is meaningful to the
   * designated communication system (i.e. phone number or email address).
 */
  value?: Maybe<Scalars['String']>,
  /** Identifies the purpose for the contact point. */
  _use?: Maybe<FHIRElement_Input>,
  /** Identifies the purpose for the contact point. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies a preferred order in which to use a set of contacts. ContactPoints
   * with lower rank values are more preferred than those with higher rank values.
 */
  _rank?: Maybe<FHIRElement_Input>,
  /** 
 * Specifies a preferred order in which to use a set of contacts. ContactPoints
   * with lower rank values are more preferred than those with higher rank values.
 */
  rank?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Time period when the contact point was/is in use. */
  period?: Maybe<FHIRPeriod_Input>,
};

/** Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement. */
export type FHIRContract = {
   __typename?: 'FHIRContract',
  /** Type of resource */
  resourceType: FHIRContract_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for this Contract or a derivative that references a Source Contract. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Canonical identifier for this contract, represented as a URI (globally unique). */
  url?: Maybe<Scalars['FHIRUri']>,
  /** An edition identifier used for business purposes to label business significant variants. */
  version?: Maybe<Scalars['String']>,
  /** The status of the resource instance. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Legal states of the formation of a legal instrument, which is a formally
   * executed written document that can be formally attributed to its author,
   * records and formally expresses a legally enforceable act, process, or
   * contractual duty, obligation, or right, and therefore evidences that act,
   * process, or agreement.
 */
  legalState?: Maybe<FHIRCodeableConcept>,
  /** The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract. */
  instantiatesCanonical?: Maybe<FHIRContractinstantiatesCanonical_instantiatesCanonical_Union>,
  /** The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract. */
  instantiatesUri?: Maybe<Scalars['FHIRUri']>,
  /** The minimal content derived from the basal information source at a specific stage in its lifecycle. */
  contentDerivative?: Maybe<FHIRCodeableConcept>,
  /** When this  Contract was issued. */
  issued?: Maybe<Scalars['FHIRDateTime']>,
  /** Relevant time or time-period when this Contract is applicable. */
  applies?: Maybe<FHIRPeriod>,
  /** Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract. */
  expirationType?: Maybe<FHIRCodeableConcept>,
  /** The target entity impacted by or of interest to parties to the agreement. */
  subject?: Maybe<Array<Maybe<FHIRContractsubject_subject_Union>>>,
  /** 
 * A formally or informally recognized grouping of people, principals,
   * organizations, or jurisdictions formed for the purpose of achieving some form
   * of collective action such as the promulgation, administration and enforcement
   * of contracts and policies.
 */
  authority?: Maybe<Array<Maybe<FHIRContractauthority_authority_Union>>>,
  /** 
 * Recognized governance framework or system operating with a circumscribed scope
   * in accordance with specified principles, policies, processes or procedures for
   * managing rights, actions, or behaviors of parties or principals relative to resources.
 */
  domain?: Maybe<Array<Maybe<FHIRContractdomain_domain_Union>>>,
  /** Sites in which the contract is complied with,  exercised, or in force. */
  site?: Maybe<Array<Maybe<FHIRContractsite_site_Union>>>,
  /** 
 * A natural language name identifying this Contract definition, derivative, or
   * instance in any legal state. Provides additional information about its
   * content. This name should be usable as an identifier for the module by machine
   * processing applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** 
 * A short, descriptive, user-friendly title for this Contract definition,
   * derivative, or instance in any legal state.t giving additional information
   * about its content.
 */
  title?: Maybe<Scalars['String']>,
  /** 
 * An explanatory or alternate user-friendly title for this Contract definition,
   * derivative, or instance in any legal state.t giving additional information
   * about its content.
 */
  subtitle?: Maybe<Scalars['String']>,
  /** 
 * Alternative representation of the title for this Contract definition,
   * derivative, or instance in any legal state., e.g., a domain specific contract
   * number related to legislation.
 */
  alias?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The individual or organization that authored the Contract definition, derivative, or instance in any legal state. */
  author?: Maybe<FHIRContractauthor_author_Union>,
  /** A selector of legal concerns for this Contract definition, derivative, or instance in any legal state. */
  scope?: Maybe<FHIRCodeableConcept>,
  /** Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. */
  topicCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. */
  topicReference?: Maybe<FHIRContracttopicReference_topicReference_Union>,
  /** 
 * A high-level category for the legal instrument, whether constructed as a
   * Contract definition, derivative, or instance in any legal state.  Provides
   * additional information about its content within the context of the Contract's
   * scope to distinguish the kinds of systems that would be interested in the contract.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Sub-category for the Contract that distinguishes the kinds of systems that
   * would be interested in the Contract within the context of the Contract's scope.
 */
  subType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Precusory content developed with a focus and intent of supporting the
   * formation a Contract instance, which may be associated with and transformable
   * into a Contract.
 */
  contentDefinition?: Maybe<FHIRContractcontentDefinition>,
  /** One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups. */
  term?: Maybe<Array<Maybe<FHIRContractterm>>>,
  /** Information that may be needed by/relevant to the performer in their execution of this term action. */
  supportingInfo?: Maybe<Array<Maybe<FHIRContractsupportingInfo_supportingInfo_Union>>>,
  /** 
 * Links to Provenance records for past versions of this Contract definition,
   * derivative, or instance, which identify key state transitions or updates that
   * are likely to be relevant to a user looking at the current version of the
   * Contract.  The Provence.entity indicates the target that was changed in the
   * update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
 */
  relevantHistory?: Maybe<Array<Maybe<FHIRContractrelevantHistory_relevantHistory_Union>>>,
  /** 
 * Parties with legal standing in the Contract, including the principal parties,
   * the grantor(s) and grantee(s), which are any person or organization bound by
   * the contract, and any ancillary parties, which facilitate the execution of the
   * contract such as a notary or witness.
 */
  signer?: Maybe<Array<Maybe<FHIRContractsigner>>>,
  /** 
 * The 'patient friendly language' versionof the Contract in whole or in parts.
   * 'Patient friendly language' means the representation of the Contract and
   * Contract Provisions in a manner that is readily accessible and understandable
   * by a layperson in accordance with best practices for communication styles that
   * ensure that those agreeing to or signing the Contract understand the roles,
   * actions, obligations, responsibilities, and implication of the agreement.
 */
  friendly?: Maybe<Array<Maybe<FHIRContractfriendly>>>,
  /** List of Legal expressions or representations of this Contract. */
  legal?: Maybe<Array<Maybe<FHIRContractlegal>>>,
  /** List of Computable Policy Rule Language Representations of this Contract. */
  rule?: Maybe<Array<Maybe<FHIRContractrule>>>,
  /** 
 * Legally binding Contract: This is the signed and legally recognized
   * representation of the Contract, which is considered the 'source of truth' and
   * which would be the basis for legal action related to enforcement of this Contract.
 */
  legallyBindingAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Legally binding Contract: This is the signed and legally recognized
   * representation of the Contract, which is considered the 'source of truth' and
   * which would be the basis for legal action related to enforcement of this Contract.
 */
  legallyBindingReference?: Maybe<FHIRContractlegallyBindingReference_legallyBindingReference_Union>,
};

export enum FHIRContract_Enum_schema {
  Contract = 'Contract'
}

/** The individual or organization that authored the Contract definition, derivative, or instance in any legal state. */
export type FHIRContractauthor_author_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** 
 * A formally or informally recognized grouping of people, principals,
 * organizations, or jurisdictions formed for the purpose of achieving some form of
 * collective action such as the promulgation, administration and enforcement of
 * contracts and policies.
 */
export type FHIRContractauthority_authority_Union = FHIROrganization;

export type FHIRContractcontentDefinition = {
   __typename?: 'FHIRContractcontentDefinition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Precusory content structure and use, i.e., a boilerplate, template,
   * application for a contract such as an insurance policy or benefits under a
   * program, e.g., workers compensation.
 */
  type: FHIRCodeableConcept,
  /** Detailed Precusory content type. */
  subType?: Maybe<FHIRCodeableConcept>,
  /** The  individual or organization that published the Contract precursor content. */
  publisher?: Maybe<FHIRContractcontentDefinitionpublisher_publisher_Union>,
  /** 
 * The date (and optionally time) when the contract was published. The date must
   * change when the business version changes and it must change if the status code
   * changes. In addition, it should change when the substantive content of the
   * contract changes.
 */
  publicationDate?: Maybe<Scalars['FHIRDateTime']>,
  /** draft | active | retired | unknown. */
  publicationStatus: Scalars['FHIRCode'],
  /** 
 * A copyright statement relating to Contract precursor content. Copyright
   * statements are generally legal restrictions on the use and publishing of the
   * Contract precursor content.
 */
  copyright?: Maybe<Scalars['String']>,
};

/** The  individual or organization that published the Contract precursor content. */
export type FHIRContractcontentDefinitionpublisher_publisher_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** 
 * Recognized governance framework or system operating with a circumscribed scope
 * in accordance with specified principles, policies, processes or procedures for
 * managing rights, actions, or behaviors of parties or principals relative to resources.
 */
export type FHIRContractdomain_domain_Union = FHIRLocation;

export type FHIRContractfriendly = {
   __typename?: 'FHIRContractfriendly',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Human readable rendering of this Contract in a format and representation
   * intended to enhance comprehension and ensure understandability.
 */
  contentAttachment: FHIRAttachment,
  /** 
 * Human readable rendering of this Contract in a format and representation
   * intended to enhance comprehension and ensure understandability.
 */
  contentReference: FHIRContractfriendlycontentReference_contentReference_Union,
};

/** 
 * Human readable rendering of this Contract in a format and representation
 * intended to enhance comprehension and ensure understandability.
 */
export type FHIRContractfriendlycontentReference_contentReference_Union = FHIRComposition | FHIRDocumentReference | FHIRQuestionnaireResponse;

/** The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract. */
export type FHIRContractinstantiatesCanonical_instantiatesCanonical_Union = FHIRContract;

export type FHIRContractlegal = {
   __typename?: 'FHIRContractlegal',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Contract legal text in human renderable form. */
  contentAttachment: FHIRAttachment,
  /** Contract legal text in human renderable form. */
  contentReference: FHIRContractlegalcontentReference_contentReference_Union,
};

/** Contract legal text in human renderable form. */
export type FHIRContractlegalcontentReference_contentReference_Union = FHIRComposition | FHIRDocumentReference | FHIRQuestionnaireResponse;

/** 
 * Legally binding Contract: This is the signed and legally recognized
 * representation of the Contract, which is considered the 'source of truth' and
 * which would be the basis for legal action related to enforcement of this Contract.
 */
export type FHIRContractlegallyBindingReference_legallyBindingReference_Union = FHIRComposition | FHIRDocumentReference | FHIRQuestionnaireResponse | FHIRContract;

/** 
 * Links to Provenance records for past versions of this Contract definition,
 * derivative, or instance, which identify key state transitions or updates that
 * are likely to be relevant to a user looking at the current version of the
 * Contract.  The Provence.entity indicates the target that was changed in the
 * update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
 */
export type FHIRContractrelevantHistory_relevantHistory_Union = FHIRProvenance;

export type FHIRContractrule = {
   __typename?: 'FHIRContractrule',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). */
  contentAttachment: FHIRAttachment,
  /** Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). */
  contentReference: FHIRContractrulecontentReference_contentReference_Union,
};

/** Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). */
export type FHIRContractrulecontentReference_contentReference_Union = FHIRDocumentReference;

export type FHIRContractsigner = {
   __typename?: 'FHIRContractsigner',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Role of this Contract signer, e.g. notary, grantee. */
  type: FHIRCoding,
  /** Party which is a signator to this Contract. */
  party: FHIRContractsignerparty_party_Union,
  /** Legally binding Contract DSIG signature contents in Base64. */
  signature?: Maybe<Array<FHIRSignature>>,
};

/** Party which is a signator to this Contract. */
export type FHIRContractsignerparty_party_Union = FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** Sites in which the contract is complied with,  exercised, or in force. */
export type FHIRContractsite_site_Union = FHIRLocation;

/** The target entity impacted by or of interest to parties to the agreement. */
export type FHIRContractsubject_subject_Union = FHIRResource;

/** Information that may be needed by/relevant to the performer in their execution of this term action. */
export type FHIRContractsupportingInfo_supportingInfo_Union = FHIRResource;

export type FHIRContractterm = {
   __typename?: 'FHIRContractterm',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for this particular Contract Provision. */
  identifier?: Maybe<FHIRIdentifier>,
  /** When this Contract Provision was issued. */
  issued?: Maybe<Scalars['FHIRDateTime']>,
  /** Relevant time or time-period when this Contract Provision is applicable. */
  applies?: Maybe<FHIRPeriod>,
  /** The entity that the term applies to. */
  topicCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The entity that the term applies to. */
  topicReference?: Maybe<FHIRContracttermtopicReference_topicReference_Union>,
  /** 
 * A legal clause or condition contained within a contract that requires one or
   * both parties to perform a particular requirement by some specified time or
   * prevents one or both parties from performing a particular requirement by some
   * specified time.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** A specialized legal clause or condition based on overarching contract type. */
  subType?: Maybe<FHIRCodeableConcept>,
  /** Statement of a provision in a policy or a contract. */
  text?: Maybe<Scalars['String']>,
  /** 
 * Security labels that protect the handling of information about the term and
   * its elements, which may be specifically identified..
 */
  securityLabel?: Maybe<Array<Maybe<FHIRContracttermsecurityLabel>>>,
  /** The matter of concern in the context of this provision of the agrement. */
  offer: FHIRContracttermoffer,
  /** Contract Term Asset List. */
  asset?: Maybe<Array<Maybe<FHIRContracttermasset>>>,
  /** 
 * An actor taking a role in an activity for which it can be assigned some degree
   * of responsibility for the activity taking place.
 */
  action?: Maybe<Array<Maybe<FHIRContracttermaction>>>,
};

export type FHIRContracttermaction = {
   __typename?: 'FHIRContracttermaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** True if the term prohibits the  action. */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** 
 * Activity or service obligation to be done or not done, performed or not
   * performed, effectuated or not by this Contract term.
 */
  type: FHIRCodeableConcept,
  /** Entity of the action. */
  subject?: Maybe<Array<Maybe<FHIRContracttermactionsubject>>>,
  /** Reason or purpose for the action stipulated by this Contract Provision. */
  intent: FHIRCodeableConcept,
  /** Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse. */
  linkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Current state of the term action. */
  status: FHIRCodeableConcept,
  /** Encounter or Episode with primary association to specified term activity. */
  context?: Maybe<FHIRContracttermactioncontext_context_Union>,
  /** 
 * Id [identifier??] of the clause or question text related to the requester of
   * this action in the referenced form or QuestionnaireResponse.
 */
  contextLinkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** When action happens. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** When action happens. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** When action happens. */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** Who or what initiated the action and has responsibility for its activation. */
  requester?: Maybe<Array<Maybe<FHIRContracttermactionrequester_requester_Union>>>,
  /** 
 * Id [identifier??] of the clause or question text related to the requester of
   * this action in the referenced form or QuestionnaireResponse.
 */
  requesterLinkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The type of individual that is desired or required to perform or not perform the action. */
  performerType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The type of role or competency of an individual desired or required to perform or not perform the action. */
  performerRole?: Maybe<FHIRCodeableConcept>,
  /** Indicates who or what is being asked to perform (or not perform) the ction. */
  performer?: Maybe<FHIRContracttermactionperformer_performer_Union>,
  /** 
 * Id [identifier??] of the clause or question text related to the reason type or
   * reference of this  action in the referenced form or QuestionnaireResponse.
 */
  performerLinkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies permitting or not permitting this action. */
  reasonReference?: Maybe<Array<Maybe<FHIRContracttermactionreasonReference_reasonReference_Union>>>,
  /** Describes why the action is to be performed or not performed in textual form. */
  reason?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Id [identifier??] of the clause or question text related to the reason type or
   * reference of this  action in the referenced form or QuestionnaireResponse.
 */
  reasonLinkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Comments made about the term action made by the requester, performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Security labels that protects the action. */
  securityLabelNumber?: Maybe<Array<Maybe<Scalars['FHIRUnsignedInt']>>>,
};

/** Encounter or Episode with primary association to specified term activity. */
export type FHIRContracttermactioncontext_context_Union = FHIREncounter | FHIREpisodeOfCare;

/** Indicates who or what is being asked to perform (or not perform) the ction. */
export type FHIRContracttermactionperformer_performer_Union = FHIRRelatedPerson | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRCareTeam | FHIRDevice | FHIRSubstance | FHIROrganization | FHIRLocation;

/** Indicates another resource whose existence justifies permitting or not permitting this action. */
export type FHIRContracttermactionreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference | FHIRQuestionnaire | FHIRQuestionnaireResponse;

/** Who or what initiated the action and has responsibility for its activation. */
export type FHIRContracttermactionrequester_requester_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRGroup | FHIROrganization;

export type FHIRContracttermactionsubject = {
   __typename?: 'FHIRContracttermactionsubject',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The entity the action is performed or not performed on or for. */
  reference?: Maybe<Array<FHIRContracttermactionsubjectreference_reference_Union>>,
  /** Role type of agent assigned roles in this Contract. */
  role?: Maybe<FHIRCodeableConcept>,
};

/** The entity the action is performed or not performed on or for. */
export type FHIRContracttermactionsubjectreference_reference_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRGroup | FHIROrganization;

export type FHIRContracttermasset = {
   __typename?: 'FHIRContracttermasset',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Differentiates the kind of the asset . */
  scope?: Maybe<FHIRCodeableConcept>,
  /** Target entity type about which the term may be concerned. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Associated entities. */
  typeReference?: Maybe<Array<Maybe<FHIRContracttermassettypeReference_typeReference_Union>>>,
  /** May be a subtype or part of an offered asset. */
  subtype?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Specifies the applicability of the term to an asset resource instance, and
   * instances it refers to orinstances that refer to it, and/or are owned by the offeree.
 */
  relationship?: Maybe<FHIRCoding>,
  /** Circumstance of the asset. */
  context?: Maybe<Array<Maybe<FHIRContracttermassetcontext>>>,
  /** Description of the quality and completeness of the asset that imay be a factor in its valuation. */
  condition?: Maybe<Scalars['String']>,
  /** Type of Asset availability for use or ownership. */
  periodType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Asset relevant contractual time period. */
  period?: Maybe<Array<Maybe<FHIRPeriod>>>,
  /** Time period of asset use. */
  usePeriod?: Maybe<Array<Maybe<FHIRPeriod>>>,
  /** 
 * Clause or question text (Prose Object) concerning the asset in a linked form,
   * such as a QuestionnaireResponse used in the formation of the contract.
 */
  text?: Maybe<Scalars['String']>,
  /** Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse. */
  linkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Security labels that protects the asset. */
  securityLabelNumber?: Maybe<Array<Maybe<Scalars['FHIRUnsignedInt']>>>,
  /** Contract Valued Item List. */
  valuedItem?: Maybe<Array<Maybe<FHIRContracttermassetvaluedItem>>>,
};

export type FHIRContracttermassetcontext = {
   __typename?: 'FHIRContracttermassetcontext',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Asset context reference may include the creator, custodian, or owning Person
   * or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
 */
  reference?: Maybe<FHIRContracttermassetcontextreference_reference_Union>,
  /** Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Context description. */
  text?: Maybe<Scalars['String']>,
};

/** 
 * Asset context reference may include the creator, custodian, or owning Person or
 * Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
 */
export type FHIRContracttermassetcontextreference_reference_Union = FHIRResource;

/** Associated entities. */
export type FHIRContracttermassettypeReference_typeReference_Union = FHIRResource;

export type FHIRContracttermassetvaluedItem = {
   __typename?: 'FHIRContracttermassetvaluedItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specific type of Contract Valued Item that may be priced. */
  entityCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Specific type of Contract Valued Item that may be priced. */
  entityReference?: Maybe<FHIRContracttermassetvaluedItementityReference_entityReference_Union>,
  /** Identifies a Contract Valued Item instance. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Indicates the time during which this Contract ValuedItem information is effective. */
  effectiveTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Specifies the units by which the Contract Valued Item is measured or counted,
   * and quantifies the countable or measurable Contract Valued Item instances.
 */
  quantity?: Maybe<FHIRQuantity>,
  /** A Contract Valued Item unit valuation measure. */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of the Contract Valued Item delivered. The concept of a Factor allows
   * for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** 
 * An amount that expresses the weighting (based on difficulty, cost and/or
   * resource intensiveness) associated with the Contract Valued Item delivered.
   * The concept of Points allows for assignment of point values for a Contract
   * Valued Item, such that a monetary amount can be assigned to each point.
 */
  points?: Maybe<Scalars['Float']>,
  /** 
 * Expresses the product of the Contract Valued Item unitQuantity and the
   * unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per
   * Point) * factor Number  * points = net Amount. Quantity, factor and points are
   * assumed to be 1 if not supplied.
 */
  net?: Maybe<FHIRMoney>,
  /** Terms of valuation. */
  payment?: Maybe<Scalars['String']>,
  /** When payment is due. */
  paymentDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Who will make payment. */
  responsible?: Maybe<FHIRContracttermassetvaluedItemresponsible_responsible_Union>,
  /** Who will receive payment. */
  recipient?: Maybe<FHIRContracttermassetvaluedItemrecipient_recipient_Union>,
  /** 
 * Id  of the clause or question text related to the context of this valuedItem
   * in the referenced form or QuestionnaireResponse.
 */
  linkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** A set of security labels that define which terms are controlled by this condition. */
  securityLabelNumber?: Maybe<Array<Maybe<Scalars['FHIRUnsignedInt']>>>,
};

/** Specific type of Contract Valued Item that may be priced. */
export type FHIRContracttermassetvaluedItementityReference_entityReference_Union = FHIRResource;

/** Who will receive payment. */
export type FHIRContracttermassetvaluedItemrecipient_recipient_Union = FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** Who will make payment. */
export type FHIRContracttermassetvaluedItemresponsible_responsible_Union = FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

export type FHIRContracttermoffer = {
   __typename?: 'FHIRContracttermoffer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for this particular Contract Provision. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Offer Recipient. */
  party?: Maybe<Array<Maybe<FHIRContracttermofferparty>>>,
  /** 
 * The owner of an asset has the residual control rights over the asset: the
   * right to decide all usages of the asset in any way not inconsistent with a
   * prior contract, custom, or law (Hart, 1995, p. 30).
 */
  topic?: Maybe<FHIRContracttermoffertopic_topic_Union>,
  /** 
 * Type of Contract Provision such as specific requirements, purposes for
   * actions, obligations, prohibitions, e.g. life time maximum benefit.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** Type of choice made by accepting party with respect to an offer made by an offeror/ grantee. */
  decision?: Maybe<FHIRCodeableConcept>,
  /** How the decision about a Contract was conveyed. */
  decisionMode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Response to offer text. */
  answer?: Maybe<Array<Maybe<FHIRContracttermofferanswer>>>,
  /** Human readable form of this Contract Offer. */
  text?: Maybe<Scalars['String']>,
  /** The id of the clause or question text of the offer in the referenced questionnaire/response. */
  linkId?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Security labels that protects the offer. */
  securityLabelNumber?: Maybe<Array<Maybe<Scalars['FHIRUnsignedInt']>>>,
};

export type FHIRContracttermofferanswer = {
   __typename?: 'FHIRContracttermofferanswer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueBoolean: Scalars['Boolean'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueDecimal: Scalars['Float'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueInteger: Scalars['Int'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueDate: Scalars['FHIRDate'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueDateTime: Scalars['FHIRDateTime'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueTime: Scalars['FHIRTime'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueString: Scalars['String'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueUri: Scalars['FHIRUri'],
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueAttachment: FHIRAttachment,
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueCoding: FHIRCoding,
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueQuantity: FHIRQuantity,
  /** 
 * Response to an offer clause or question text,  which enables selection of
   * values to be agreed to, e.g., the period of participation, the date of
   * occupancy of a rental, warrently duration, or whether biospecimen may be used
   * for further research.
 */
  valueReference: FHIRContracttermofferanswervalueReference_valueReference_Union,
};

/** 
 * Response to an offer clause or question text,  which enables selection of values
 * to be agreed to, e.g., the period of participation, the date of occupancy of a
 * rental, warrently duration, or whether biospecimen may be used for further research.
 */
export type FHIRContracttermofferanswervalueReference_valueReference_Union = FHIRResource;

export type FHIRContracttermofferparty = {
   __typename?: 'FHIRContracttermofferparty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Participant in the offer. */
  reference?: Maybe<Array<FHIRContracttermofferpartyreference_reference_Union>>,
  /** How the party participates in the offer. */
  role: FHIRCodeableConcept,
};

/** Participant in the offer. */
export type FHIRContracttermofferpartyreference_reference_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRGroup | FHIROrganization;

/** 
 * The owner of an asset has the residual control rights over the asset: the right
 * to decide all usages of the asset in any way not inconsistent with a prior
 * contract, custom, or law (Hart, 1995, p. 30).
 */
export type FHIRContracttermoffertopic_topic_Union = FHIRResource;

export type FHIRContracttermsecurityLabel = {
   __typename?: 'FHIRContracttermsecurityLabel',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Number used to link this term or term element to the applicable Security Label. */
  number?: Maybe<Array<Maybe<Scalars['FHIRUnsignedInt']>>>,
  /** 
 * Security label privacy tag that species the level of confidentiality
   * protection required for this term and/or term elements.
 */
  classification: FHIRCoding,
  /** 
 * Security label privacy tag that species the applicable privacy and security
   * policies governing this term and/or term elements.
 */
  category?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** Security label privacy tag that species the manner in which term and/or term elements are to be protected. */
  control?: Maybe<Array<Maybe<FHIRCoding>>>,
};

/** The entity that the term applies to. */
export type FHIRContracttermtopicReference_topicReference_Union = FHIRResource;

/** Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. */
export type FHIRContracttopicReference_topicReference_Union = FHIRResource;

/** 
 * Base StructureDefinition for Contributor Type: A contributor to the content of a
 * knowledge asset, including authors, editors, reviewers, and endorsers.
 */
export type FHIRContributor = {
   __typename?: 'FHIRContributor',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of contributor. */
  type: Scalars['FHIRCode'],
  /** The name of the individual or organization responsible for the contribution. */
  name: Scalars['String'],
  /** Contact details to assist a user in finding and communicating with the contributor. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
};

/** 
 * Base StructureDefinition for Contributor Type: A contributor to the content of a
 * knowledge asset, including authors, editors, reviewers, and endorsers.
 */
export type FHIRContributor_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The type of contributor. */
  _type?: Maybe<FHIRElement_Input>,
  /** The type of contributor. */
  type: Scalars['FHIRCode'],
  /** The name of the individual or organization responsible for the contribution. */
  _name?: Maybe<FHIRElement_Input>,
  /** The name of the individual or organization responsible for the contribution. */
  name: Scalars['String'],
  /** Contact details to assist a user in finding and communicating with the contributor. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail_Input>>>,
};

/** 
 * Base StructureDefinition for Count Type: A measured amount (or an amount that
 * can potentially be measured). Note that measured amounts include amounts that
 * are not precisely quantified, including amounts involving arbitrary units and
 * floating currencies.
 */
export type FHIRCount = {
   __typename?: 'FHIRCount',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * Base StructureDefinition for Count Type: A measured amount (or an amount that
 * can potentially be measured). Note that measured amounts include amounts that
 * are not precisely quantified, including amounts involving arbitrary units and
 * floating currencies.
 */
export type FHIRCount_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  _value?: Maybe<FHIRElement_Input>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  _comparator?: Maybe<FHIRElement_Input>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  _unit?: Maybe<FHIRElement_Input>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  _code?: Maybe<FHIRElement_Input>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * Financial instrument which may be used to reimburse or pay for health care
 * products and services. Includes both insurance and self-payment.
 */
export type FHIRCoverage = {
   __typename?: 'FHIRCoverage',
  /** Type of resource */
  resourceType: FHIRCoverage_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this coverage. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** 
 * The type of coverage: social program, medical plan, accident coverage (workers
   * compensation, auto), group health or payment by an individual or organization.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The party who 'owns' the insurance policy. */
  policyHolder?: Maybe<FHIRCoveragepolicyHolder_policyHolder_Union>,
  /** 
 * The party who has signed-up for or 'owns' the contractual relationship to the
   * policy or to whom the benefit of the policy for services rendered to them or
   * their family is due.
 */
  subscriber?: Maybe<FHIRCoveragesubscriber_subscriber_Union>,
  /** The insurer assigned ID for the Subscriber. */
  subscriberId?: Maybe<Scalars['String']>,
  /** The party who benefits from the insurance coverage; the patient when products and/or services are provided. */
  beneficiary: FHIRCoveragebeneficiary_beneficiary_Union,
  /** A unique identifier for a dependent under the coverage. */
  dependent?: Maybe<Scalars['String']>,
  /** The relationship of beneficiary (patient) to the subscriber. */
  relationship?: Maybe<FHIRCodeableConcept>,
  /** 
 * Time period during which the coverage is in force. A missing start date
   * indicates the start date isn't known, a missing end date means the coverage is
   * continuing to be in force.
 */
  period?: Maybe<FHIRPeriod>,
  /** 
 * The program or plan underwriter or payor including both insurance and
   * non-insurance agreements, such as patient-pay agreements.
 */
  payor?: Maybe<Array<FHIRCoveragepayor_payor_Union>>,
  /** A suite of underwriter specific classifiers. */
  class?: Maybe<Array<Maybe<FHIRCoverageclass>>>,
  /** 
 * The order of applicability of this coverage relative to other coverages which
   * are currently in force. Note, there may be gaps in the numbering and this does
   * not imply primary, secondary etc. as the specific positioning of coverages
   * depends upon the episode of care.
 */
  order?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The insurer-specific identifier for the insurer-defined network of providers
   * to which the beneficiary may seek treatment which will be covered at the
   * 'in-network' rate, otherwise 'out of network' terms and conditions apply.
 */
  network?: Maybe<Scalars['String']>,
  /** 
 * A suite of codes indicating the cost category and associated amount which have
   * been detailed in the policy and may have been  included on the health card.
 */
  costToBeneficiary?: Maybe<Array<Maybe<FHIRCoveragecostToBeneficiary>>>,
  /** 
 * When 'subrogation=true' this insurance instance has been included not for
   * adjudication but to provide insurers with the details to recover costs.
 */
  subrogation?: Maybe<Scalars['Boolean']>,
  /** The policy(s) which constitute this insurance coverage. */
  contract?: Maybe<Array<Maybe<FHIRCoveragecontract_contract_Union>>>,
};

export enum FHIRCoverage_Enum_schema {
  Coverage = 'Coverage'
}

/** The party who benefits from the insurance coverage; the patient when products and/or services are provided. */
export type FHIRCoveragebeneficiary_beneficiary_Union = FHIRPatient;

export type FHIRCoverageclass = {
   __typename?: 'FHIRCoverageclass',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The type of classification for which an insurer-specific class label or number
   * and optional name is provided, for example may be used to identify a class of
   * coverage or employer group, Policy, Plan.
 */
  type: FHIRCodeableConcept,
  /** The alphanumeric string value associated with the insurer issued label. */
  value: Scalars['String'],
  /** A short description for the class. */
  name?: Maybe<Scalars['String']>,
};

/** The policy(s) which constitute this insurance coverage. */
export type FHIRCoveragecontract_contract_Union = FHIRContract;

export type FHIRCoveragecostToBeneficiary = {
   __typename?: 'FHIRCoveragecostToBeneficiary',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The category of patient centric costs associated with treatment. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The amount due from the patient for the cost category. */
  valueQuantity: FHIRQuantity,
  /** The amount due from the patient for the cost category. */
  valueMoney: FHIRMoney,
  /** A suite of codes indicating exceptions or reductions to patient costs and their effective periods. */
  exception?: Maybe<Array<Maybe<FHIRCoveragecostToBeneficiaryexception>>>,
};

export type FHIRCoveragecostToBeneficiaryexception = {
   __typename?: 'FHIRCoveragecostToBeneficiaryexception',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The code for the specific exception. */
  type: FHIRCodeableConcept,
  /** The timeframe during when the exception is in force. */
  period?: Maybe<FHIRPeriod>,
};

/** 
 * The CoverageEligibilityRequest provides patient and insurance coverage
 * information to an insurer for them to respond, in the form of an
 * CoverageEligibilityResponse, with information regarding whether the stated
 * coverage is valid and in-force and optionally to provide the insurance details of the policy.
 */
export type FHIRCoverageEligibilityRequest = {
   __typename?: 'FHIRCoverageEligibilityRequest',
  /** Type of resource */
  resourceType: FHIRCoverageEligibilityRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this coverage eligiblity request. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** When the requestor expects the processor to complete processing. */
  priority?: Maybe<FHIRCodeableConcept>,
  /** 
 * Code to specify whether requesting: prior authorization requirements for some
   * service categories or billing codes; benefits for coverages specified or
   * discovered; discovery and return of coverages for the patient; and/or
   * validation that the specified coverage is in-force at the date/period
   * specified or 'now' if not specified.
 */
  purpose?: Maybe<Array<Scalars['FHIRCode']>>,
  /** The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. */
  patient: FHIRCoverageEligibilityRequestpatient_patient_Union,
  /** The date or dates when the enclosed suite of services were performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the enclosed suite of services were performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** The date when this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** Person who created the request. */
  enterer?: Maybe<FHIRCoverageEligibilityRequestenterer_enterer_Union>,
  /** The provider which is responsible for the request. */
  provider?: Maybe<FHIRCoverageEligibilityRequestprovider_provider_Union>,
  /** The Insurer who issued the coverage in question and is the recipient of the request. */
  insurer: FHIRCoverageEligibilityRequestinsurer_insurer_Union,
  /** Facility where the services are intended to be provided. */
  facility?: Maybe<FHIRCoverageEligibilityRequestfacility_facility_Union>,
  /** 
 * Additional information codes regarding exceptions, special considerations, the
   * condition, situation, prior or concurrent issues.
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRCoverageEligibilityRequestsupportingInfo>>>,
  /** Financial instruments for reimbursement for the health care products and services. */
  insurance?: Maybe<Array<Maybe<FHIRCoverageEligibilityRequestinsurance>>>,
  /** 
 * Service categories or billable services for which benefit details and/or an
   * authorization prior to service delivery may be required by the payor.
 */
  item?: Maybe<Array<Maybe<FHIRCoverageEligibilityRequestitem>>>,
};

export enum FHIRCoverageEligibilityRequest_Enum_schema {
  CoverageEligibilityRequest = 'CoverageEligibilityRequest'
}

/** Person who created the request. */
export type FHIRCoverageEligibilityRequestenterer_enterer_Union = FHIRPractitioner | FHIRPractitionerRole;

/** Facility where the services are intended to be provided. */
export type FHIRCoverageEligibilityRequestfacility_facility_Union = FHIRLocation;

export type FHIRCoverageEligibilityRequestinsurance = {
   __typename?: 'FHIRCoverageEligibilityRequestinsurance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A flag to indicate that this Coverage is to be used for evaluation of this request when set to true. */
  focal?: Maybe<Scalars['Boolean']>,
  /** 
 * Reference to the insurance card level information contained in the Coverage
   * resource. The coverage issuing insurer will use these details to locate the
   * patient's actual coverage within the insurer's information system.
 */
  coverage: FHIRCoverageEligibilityRequestinsurancecoverage_coverage_Union,
  /** A business agreement number established between the provider and the insurer for special business processing purposes. */
  businessArrangement?: Maybe<Scalars['String']>,
};

/** 
 * Reference to the insurance card level information contained in the Coverage
 * resource. The coverage issuing insurer will use these details to locate the
 * patient's actual coverage within the insurer's information system.
 */
export type FHIRCoverageEligibilityRequestinsurancecoverage_coverage_Union = FHIRCoverage;

/** The Insurer who issued the coverage in question and is the recipient of the request. */
export type FHIRCoverageEligibilityRequestinsurer_insurer_Union = FHIROrganization;

export type FHIRCoverageEligibilityRequestitem = {
   __typename?: 'FHIRCoverageEligibilityRequestitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Exceptions, special conditions and supporting information applicable for this service or product line. */
  supportingInfoSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** This contains the product, service, drug or other billing code for the item. */
  productOrService?: Maybe<FHIRCodeableConcept>,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The practitioner who is responsible for the product or service to be rendered to the patient. */
  provider?: Maybe<FHIRCoverageEligibilityRequestitemprovider_provider_Union>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** The amount charged to the patient by the provider for a single unit. */
  unitPrice?: Maybe<FHIRMoney>,
  /** Facility where the services will be provided. */
  facility?: Maybe<FHIRCoverageEligibilityRequestitemfacility_facility_Union>,
  /** Patient diagnosis for which care is sought. */
  diagnosis?: Maybe<Array<Maybe<FHIRCoverageEligibilityRequestitemdiagnosis>>>,
  /** The plan/proposal/order describing the proposed service in detail. */
  detail?: Maybe<Array<Maybe<FHIRCoverageEligibilityRequestitemdetail_detail_Union>>>,
};

/** The plan/proposal/order describing the proposed service in detail. */
export type FHIRCoverageEligibilityRequestitemdetail_detail_Union = FHIRResource;

export type FHIRCoverageEligibilityRequestitemdiagnosis = {
   __typename?: 'FHIRCoverageEligibilityRequestitemdiagnosis',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisReference?: Maybe<FHIRCoverageEligibilityRequestitemdiagnosisdiagnosisReference_diagnosisReference_Union>,
};

/** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
export type FHIRCoverageEligibilityRequestitemdiagnosisdiagnosisReference_diagnosisReference_Union = FHIRCondition;

/** Facility where the services will be provided. */
export type FHIRCoverageEligibilityRequestitemfacility_facility_Union = FHIRLocation | FHIROrganization;

/** The practitioner who is responsible for the product or service to be rendered to the patient. */
export type FHIRCoverageEligibilityRequestitemprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole;

/** The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. */
export type FHIRCoverageEligibilityRequestpatient_patient_Union = FHIRPatient;

/** The provider which is responsible for the request. */
export type FHIRCoverageEligibilityRequestprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRCoverageEligibilityRequestsupportingInfo = {
   __typename?: 'FHIRCoverageEligibilityRequestsupportingInfo',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify supporting information entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  information: FHIRCoverageEligibilityRequestsupportingInfoinformation_information_Union,
  /** The supporting materials are applicable for all detail items, product/servce categories and specific billing codes. */
  appliesToAll?: Maybe<Scalars['Boolean']>,
};

/** 
 * Additional data or information such as resources, documents, images etc.
 * including references to the data or the actual inclusion of the data.
 */
export type FHIRCoverageEligibilityRequestsupportingInfoinformation_information_Union = FHIRResource;

/** This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource. */
export type FHIRCoverageEligibilityResponse = {
   __typename?: 'FHIRCoverageEligibilityResponse',
  /** Type of resource */
  resourceType: FHIRCoverageEligibilityResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this coverage eligiblity request. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** 
 * Code to specify whether requesting: prior authorization requirements for some
   * service categories or billing codes; benefits for coverages specified or
   * discovered; discovery and return of coverages for the patient; and/or
   * validation that the specified coverage is in-force at the date/period
   * specified or 'now' if not specified.
 */
  purpose?: Maybe<Array<Scalars['FHIRCode']>>,
  /** The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. */
  patient: FHIRCoverageEligibilityResponsepatient_patient_Union,
  /** The date or dates when the enclosed suite of services were performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the enclosed suite of services were performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** The date this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** The provider which is responsible for the request. */
  requestor?: Maybe<FHIRCoverageEligibilityResponserequestor_requestor_Union>,
  /** Reference to the original request resource. */
  request: FHIRCoverageEligibilityResponserequest_request_Union,
  /** The outcome of the request processing. */
  outcome: Scalars['FHIRCode'],
  /** A human readable description of the status of the adjudication. */
  disposition?: Maybe<Scalars['String']>,
  /** The Insurer who issued the coverage in question and is the author of the response. */
  insurer: FHIRCoverageEligibilityResponseinsurer_insurer_Union,
  /** Financial instruments for reimbursement for the health care products and services. */
  insurance?: Maybe<Array<Maybe<FHIRCoverageEligibilityResponseinsurance>>>,
  /** 
 * A reference from the Insurer to which these services pertain to be used on
   * further communication and as proof that the request occurred.
 */
  preAuthRef?: Maybe<Scalars['String']>,
  /** A code for the form to be used for printing the content. */
  form?: Maybe<FHIRCodeableConcept>,
  /** Errors encountered during the processing of the request. */
  error?: Maybe<Array<Maybe<FHIRCoverageEligibilityResponseerror>>>,
};

export enum FHIRCoverageEligibilityResponse_Enum_schema {
  CoverageEligibilityResponse = 'CoverageEligibilityResponse'
}

export type FHIRCoverageEligibilityResponseerror = {
   __typename?: 'FHIRCoverageEligibilityResponseerror',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An error code,from a specified code system, which details why the eligibility check could not be performed. */
  code: FHIRCodeableConcept,
};

export type FHIRCoverageEligibilityResponseinsurance = {
   __typename?: 'FHIRCoverageEligibilityResponseinsurance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Reference to the insurance card level information contained in the Coverage
   * resource. The coverage issuing insurer will use these details to locate the
   * patient's actual coverage within the insurer's information system.
 */
  coverage: FHIRCoverageEligibilityResponseinsurancecoverage_coverage_Union,
  /** 
 * Flag indicating if the coverage provided is inforce currently if no service
   * date(s) specified or for the whole duration of the service dates.
 */
  inforce?: Maybe<Scalars['Boolean']>,
  /** The term of the benefits documented in this response. */
  benefitPeriod?: Maybe<FHIRPeriod>,
  /** Benefits and optionally current balances, and authorization details by category or service. */
  item?: Maybe<Array<Maybe<FHIRCoverageEligibilityResponseinsuranceitem>>>,
};

/** 
 * Reference to the insurance card level information contained in the Coverage
 * resource. The coverage issuing insurer will use these details to locate the
 * patient's actual coverage within the insurer's information system.
 */
export type FHIRCoverageEligibilityResponseinsurancecoverage_coverage_Union = FHIRCoverage;

export type FHIRCoverageEligibilityResponseinsuranceitem = {
   __typename?: 'FHIRCoverageEligibilityResponseinsuranceitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** This contains the product, service, drug or other billing code for the item. */
  productOrService?: Maybe<FHIRCodeableConcept>,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The practitioner who is eligible for the provision of the product or service. */
  provider?: Maybe<FHIRCoverageEligibilityResponseinsuranceitemprovider_provider_Union>,
  /** 
 * True if the indicated class of service is excluded from the plan, missing or
   * False indicates the product or service is included in the coverage.
 */
  excluded?: Maybe<Scalars['Boolean']>,
  /** A short name or tag for the benefit. */
  name?: Maybe<Scalars['String']>,
  /** A richer description of the benefit or services covered. */
  description?: Maybe<Scalars['String']>,
  /** Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. */
  network?: Maybe<FHIRCodeableConcept>,
  /** Indicates if the benefits apply to an individual or to the family. */
  unit?: Maybe<FHIRCodeableConcept>,
  /** The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. */
  term?: Maybe<FHIRCodeableConcept>,
  /** Benefits used to date. */
  benefit?: Maybe<Array<Maybe<FHIRCoverageEligibilityResponseinsuranceitembenefit>>>,
  /** A boolean flag indicating whether a preauthorization is required prior to actual service delivery. */
  authorizationRequired?: Maybe<Scalars['Boolean']>,
  /** Codes or comments regarding information or actions associated with the preauthorization. */
  authorizationSupporting?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A web location for obtaining requirements or descriptive information regarding the preauthorization. */
  authorizationUrl?: Maybe<Scalars['FHIRUri']>,
};

export type FHIRCoverageEligibilityResponseinsuranceitembenefit = {
   __typename?: 'FHIRCoverageEligibilityResponseinsuranceitembenefit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Classification of benefit being provided. */
  type: FHIRCodeableConcept,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedString?: Maybe<Scalars['String']>,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedMoney?: Maybe<FHIRMoney>,
  /** The quantity of the benefit which have been consumed to date. */
  usedUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The quantity of the benefit which have been consumed to date. */
  usedString?: Maybe<Scalars['String']>,
  /** The quantity of the benefit which have been consumed to date. */
  usedMoney?: Maybe<FHIRMoney>,
};

/** The practitioner who is eligible for the provision of the product or service. */
export type FHIRCoverageEligibilityResponseinsuranceitemprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole;

/** The Insurer who issued the coverage in question and is the author of the response. */
export type FHIRCoverageEligibilityResponseinsurer_insurer_Union = FHIROrganization;

/** The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. */
export type FHIRCoverageEligibilityResponsepatient_patient_Union = FHIRPatient;

/** Reference to the original request resource. */
export type FHIRCoverageEligibilityResponserequest_request_Union = FHIRCoverageEligibilityRequest;

/** The provider which is responsible for the request. */
export type FHIRCoverageEligibilityResponserequestor_requestor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** 
 * The program or plan underwriter or payor including both insurance and
 * non-insurance agreements, such as patient-pay agreements.
 */
export type FHIRCoveragepayor_payor_Union = FHIROrganization | FHIRPatient | FHIRRelatedPerson;

/** The party who 'owns' the insurance policy. */
export type FHIRCoveragepolicyHolder_policyHolder_Union = FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** 
 * The party who has signed-up for or 'owns' the contractual relationship to the
 * policy or to whom the benefit of the policy for services rendered to them or
 * their family is due.
 */
export type FHIRCoveragesubscriber_subscriber_Union = FHIRPatient | FHIRRelatedPerson;

/** 
 * Base StructureDefinition for DataRequirement Type: Describes a required data
 * item for evaluation in terms of the type of data, and optional code or
 * date-based filters of the data.
 */
export type FHIRDataRequirement = {
   __typename?: 'FHIRDataRequirement',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The type of the required data, specified as the type name of a resource. For
   * profiles, this value is set to the type of the base resource of the profile.
 */
  type: Scalars['FHIRCode'],
  /** The profile of the required data, specified as the uri of the profile definition. */
  profile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. */
  subjectReference?: Maybe<FHIRDataRequirementsubjectReference_subjectReference_Union>,
  /** 
 * Indicates that specific elements of the type are referenced by the knowledge
   * module and must be supported by the consumer in order to obtain an effective
   * evaluation. This does not mean that a value is required for this element, only
   * that the consuming system must understand the element and be able to provide
   * values for it if they are available.   The value of mustSupport SHALL be a
   * FHIRPath resolveable on the type of the DataRequirement. The path SHALL
   * consist only of identifiers, constant indexers, and .resolve() (see the
   * [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
 */
  mustSupport?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Code filters specify additional constraints on the data, specifying the value
   * set of interest for a particular element of the data. Each code filter defines
   * an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
 */
  codeFilter?: Maybe<Array<Maybe<FHIRElement>>>,
  /** 
 * Date filters specify additional constraints on the data in terms of the
   * applicable date range for specific elements. Each date filter specifies an
   * additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
 */
  dateFilter?: Maybe<Array<Maybe<FHIRElement>>>,
  /** Specifies a maximum number of results that are required (uses the _count search parameter). */
  limit?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Specifies the order of the results to be returned. */
  sort?: Maybe<Array<Maybe<FHIRElement>>>,
};

/** 
 * Base StructureDefinition for DataRequirement Type: Describes a required data
 * item for evaluation in terms of the type of data, and optional code or
 * date-based filters of the data.
 */
export type FHIRDataRequirement_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * The type of the required data, specified as the type name of a resource. For
   * profiles, this value is set to the type of the base resource of the profile.
 */
  _type?: Maybe<FHIRElement_Input>,
  /** 
 * The type of the required data, specified as the type name of a resource. For
   * profiles, this value is set to the type of the base resource of the profile.
 */
  type: Scalars['FHIRCode'],
  /** The profile of the required data, specified as the uri of the profile definition. */
  _profile?: Maybe<FHIRElement_Input>,
  /** The profile of the required data, specified as the uri of the profile definition. */
  profile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept_Input>,
  /** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. */
  subjectReference?: Maybe<Scalars['String']>,
  /** 
 * Indicates that specific elements of the type are referenced by the knowledge
   * module and must be supported by the consumer in order to obtain an effective
   * evaluation. This does not mean that a value is required for this element, only
   * that the consuming system must understand the element and be able to provide
   * values for it if they are available.   The value of mustSupport SHALL be a
   * FHIRPath resolveable on the type of the DataRequirement. The path SHALL
   * consist only of identifiers, constant indexers, and .resolve() (see the
   * [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
 */
  _mustSupport?: Maybe<FHIRElement_Input>,
  /** 
 * Indicates that specific elements of the type are referenced by the knowledge
   * module and must be supported by the consumer in order to obtain an effective
   * evaluation. This does not mean that a value is required for this element, only
   * that the consuming system must understand the element and be able to provide
   * values for it if they are available.   The value of mustSupport SHALL be a
   * FHIRPath resolveable on the type of the DataRequirement. The path SHALL
   * consist only of identifiers, constant indexers, and .resolve() (see the
   * [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
 */
  mustSupport?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Code filters specify additional constraints on the data, specifying the value
   * set of interest for a particular element of the data. Each code filter defines
   * an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
 */
  codeFilter?: Maybe<Array<Maybe<FHIRElement_Input>>>,
  /** 
 * Date filters specify additional constraints on the data in terms of the
   * applicable date range for specific elements. Each date filter specifies an
   * additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
 */
  dateFilter?: Maybe<Array<Maybe<FHIRElement_Input>>>,
  /** Specifies a maximum number of results that are required (uses the _count search parameter). */
  _limit?: Maybe<FHIRElement_Input>,
  /** Specifies a maximum number of results that are required (uses the _count search parameter). */
  limit?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Specifies the order of the results to be returned. */
  sort?: Maybe<Array<Maybe<FHIRElement_Input>>>,
};

/** The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. */
export type FHIRDataRequirementsubjectReference_subjectReference_Union = FHIRGroup;



/** 
 * Indicates an actual or potential clinical issue with or between one or more
 * active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
 * Ineffective treatment frequency, Procedure-condition conflict, etc.
 */
export type FHIRDetectedIssue = {
   __typename?: 'FHIRDetectedIssue',
  /** Type of resource */
  resourceType: FHIRDetectedIssue_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifier associated with the detected issue record. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the status of the detected issue. */
  status: Scalars['FHIRCode'],
  /** Identifies the general type of issue identified. */
  code?: Maybe<FHIRCodeableConcept>,
  /** Indicates the degree of importance associated with the identified issue based on the potential impact on the patient. */
  severity?: Maybe<Scalars['FHIRCode']>,
  /** Indicates the patient whose record the detected issue is associated with. */
  patient?: Maybe<FHIRDetectedIssuepatient_patient_Union>,
  /** The date or period when the detected issue was initially identified. */
  identifiedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The date or period when the detected issue was initially identified. */
  identifiedPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Individual or device responsible for the issue being raised.  For example, a
   * decision support application or a pharmacist conducting a medication review.
 */
  author?: Maybe<FHIRDetectedIssueauthor_author_Union>,
  /** Indicates the resource representing the current activity or proposed activity that is potentially problematic. */
  implicated?: Maybe<Array<Maybe<FHIRDetectedIssueimplicated_implicated_Union>>>,
  /** 
 * Supporting evidence or manifestations that provide the basis for identifying
   * the detected issue such as a GuidanceResponse or MeasureReport.
 */
  evidence?: Maybe<Array<Maybe<FHIRDetectedIssueevidence>>>,
  /** A textual explanation of the detected issue. */
  detail?: Maybe<Scalars['String']>,
  /** The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified. */
  reference?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Indicates an action that has been taken or is committed to reduce or eliminate
   * the likelihood of the risk identified by the detected issue from manifesting. 
   * Can also reflect an observation of known mitigating factors that may
   * reduce/eliminate the need for any action.
 */
  mitigation?: Maybe<Array<Maybe<FHIRDetectedIssuemitigation>>>,
};

export enum FHIRDetectedIssue_Enum_schema {
  DetectedIssue = 'DetectedIssue'
}

/** 
 * Individual or device responsible for the issue being raised.  For example, a
 * decision support application or a pharmacist conducting a medication review.
 */
export type FHIRDetectedIssueauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRDevice;

export type FHIRDetectedIssueevidence = {
   __typename?: 'FHIRDetectedIssueevidence',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A manifestation that led to the recording of this detected issue. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport. */
  detail?: Maybe<Array<Maybe<FHIRDetectedIssueevidencedetail_detail_Union>>>,
};

/** Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport. */
export type FHIRDetectedIssueevidencedetail_detail_Union = FHIRResource;

/** Indicates the resource representing the current activity or proposed activity that is potentially problematic. */
export type FHIRDetectedIssueimplicated_implicated_Union = FHIRResource;

export type FHIRDetectedIssuemitigation = {
   __typename?: 'FHIRDetectedIssuemitigation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Describes the action that was taken or the observation that was made that
   * reduces/eliminates the risk associated with the identified issue.
 */
  action: FHIRCodeableConcept,
  /** Indicates when the mitigating action was documented. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. */
  author?: Maybe<FHIRDetectedIssuemitigationauthor_author_Union>,
};

/** Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. */
export type FHIRDetectedIssuemitigationauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole;

/** Indicates the patient whose record the detected issue is associated with. */
export type FHIRDetectedIssuepatient_patient_Union = FHIRPatient;

/** 
 * A type of a manufactured item that is used in the provision of healthcare
 * without being substantially changed through that activity. The device may be a
 * medical or non-medical device.
 */
export type FHIRDevice = {
   __typename?: 'FHIRDevice',
  /** Type of resource */
  resourceType: FHIRDevice_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique instance identifiers assigned to a device by manufacturers other organizations or owners. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The reference to the definition for the device. */
  definition?: Maybe<FHIRDevicedefinition_definition_Union>,
  /** 
 * Unique device identifier (UDI) assigned to device label or package.  Note that
   * the Device may include multiple udiCarriers as it either may include just the
   * udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it
   * could have been sold.
 */
  udiCarrier?: Maybe<Array<Maybe<FHIRDeviceudiCarrier>>>,
  /** Status of the Device availability. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** Reason for the dtatus of the Device availability. */
  statusReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The distinct identification string as required by regulation for a human cell,
   * tissue, or cellular and tissue-based product.
 */
  distinctIdentifier?: Maybe<Scalars['String']>,
  /** A name of the manufacturer. */
  manufacturer?: Maybe<Scalars['String']>,
  /** The date and time when the device was manufactured. */
  manufactureDate?: Maybe<Scalars['FHIRDateTime']>,
  /** The date and time beyond which this device is no longer valid or should not be used (if applicable). */
  expirationDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Lot number assigned by the manufacturer. */
  lotNumber?: Maybe<Scalars['String']>,
  /** The serial number assigned by the organization when the device was manufactured. */
  serialNumber?: Maybe<Scalars['String']>,
  /** 
 * This represents the manufacturer's name of the device as provided by the
   * device, from a UDI label, or by a person describing the Device.  This
   * typically would be used when a person provides the name(s) or when the device
   * represents one of the names available from DeviceDefinition.
 */
  deviceName?: Maybe<Array<Maybe<FHIRDevicedeviceName>>>,
  /** The model number for the device. */
  modelNumber?: Maybe<Scalars['String']>,
  /** The part number of the device. */
  partNumber?: Maybe<Scalars['String']>,
  /** The kind or type of device. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * The capabilities supported on a  device, the standards to which the device
   * conforms for a particular purpose, and used for the communication.
 */
  specialization?: Maybe<Array<Maybe<FHIRDevicespecialization>>>,
  /** The actual design of the device or software version running on the device. */
  version?: Maybe<Array<Maybe<FHIRDeviceversion>>>,
  /** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties. */
  property?: Maybe<Array<Maybe<FHIRDeviceproperty>>>,
  /** Patient information, If the device is affixed to a person. */
  patient?: Maybe<FHIRDevicepatient_patient_Union>,
  /** An organization that is responsible for the provision and ongoing maintenance of the device. */
  owner?: Maybe<FHIRDeviceowner_owner_Union>,
  /** Contact details for an organization or a particular human that is responsible for the device. */
  contact?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** The place where the device can be found. */
  location?: Maybe<FHIRDevicelocation_location_Union>,
  /** A network address on which the device may be contacted directly. */
  url?: Maybe<Scalars['FHIRUri']>,
  /** Descriptive information, usage information or implantation information that is not captured in an existing element. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Provides additional safety characteristics about a medical device.  For example devices containing latex. */
  safety?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The parent device. */
  parent?: Maybe<FHIRDeviceparent_parent_Union>,
};

export enum FHIRDevice_Enum_schema {
  Device = 'Device'
}

/** The characteristics, operational status and capabilities of a medical-related component of a medical device. */
export type FHIRDeviceDefinition = {
   __typename?: 'FHIRDeviceDefinition',
  /** Type of resource */
  resourceType: FHIRDeviceDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Unique instance identifiers assigned to a device by the software,
   * manufacturers, other organizations or owners. For example: handle ID.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * Unique device identifier (UDI) assigned to device label or package.  Note that
   * the Device may include multiple udiCarriers as it either may include just the
   * udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it
   * could have been sold.
 */
  udiDeviceIdentifier?: Maybe<Array<Maybe<FHIRDeviceDefinitionudiDeviceIdentifier>>>,
  /** A name of the manufacturer. */
  manufacturerString?: Maybe<Scalars['String']>,
  /** A name of the manufacturer. */
  manufacturerReference?: Maybe<FHIRDeviceDefinitionmanufacturerReference_manufacturerReference_Union>,
  /** A name given to the device to identify it. */
  deviceName?: Maybe<Array<Maybe<FHIRDeviceDefinitiondeviceName>>>,
  /** The model number for the device. */
  modelNumber?: Maybe<Scalars['String']>,
  /** What kind of device or device system this is. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * The capabilities supported on a  device, the standards to which the device
   * conforms for a particular purpose, and used for the communication.
 */
  specialization?: Maybe<Array<Maybe<FHIRDeviceDefinitionspecialization>>>,
  /** The available versions of the device, e.g., software versions. */
  version?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Safety characteristics of the device. */
  safety?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Shelf Life and storage information. */
  shelfLifeStorage?: Maybe<Array<Maybe<FHIRProductShelfLife>>>,
  /** Dimensions, color etc. */
  physicalCharacteristics?: Maybe<FHIRProdCharacteristic>,
  /** Language code for the human-readable text strings produced by the device (all supported). */
  languageCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Device capabilities. */
  capability?: Maybe<Array<Maybe<FHIRDeviceDefinitioncapability>>>,
  /** The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties. */
  property?: Maybe<Array<Maybe<FHIRDeviceDefinitionproperty>>>,
  /** An organization that is responsible for the provision and ongoing maintenance of the device. */
  owner?: Maybe<FHIRDeviceDefinitionowner_owner_Union>,
  /** Contact details for an organization or a particular human that is responsible for the device. */
  contact?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** A network address on which the device may be contacted directly. */
  url?: Maybe<Scalars['FHIRUri']>,
  /** Access to on-line information about the device. */
  onlineInformation?: Maybe<Scalars['FHIRUri']>,
  /** Descriptive information, usage information or implantation information that is not captured in an existing element. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The quantity of the device present in the packaging (e.g. the number of
   * devices present in a pack, or the number of devices in the same package of the
   * medicinal product).
 */
  quantity?: Maybe<FHIRQuantity>,
  /** The parent device it can be part of. */
  parentDevice?: Maybe<FHIRDeviceDefinitionparentDevice_parentDevice_Union>,
  /** A substance used to create the material(s) of which the device is made. */
  material?: Maybe<Array<Maybe<FHIRDeviceDefinitionmaterial>>>,
};

/** The reference to the definition for the device. */
export type FHIRDevicedefinition_definition_Union = FHIRDeviceDefinition;

export enum FHIRDeviceDefinition_Enum_schema {
  DeviceDefinition = 'DeviceDefinition'
}

export type FHIRDeviceDefinitioncapability = {
   __typename?: 'FHIRDeviceDefinitioncapability',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of capability. */
  type: FHIRCodeableConcept,
  /** Description of capability. */
  description?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export type FHIRDeviceDefinitiondeviceName = {
   __typename?: 'FHIRDeviceDefinitiondeviceName',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the device. */
  name: Scalars['String'],
  /** The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName. */
  type: Scalars['FHIRCode'],
};

/** A name of the manufacturer. */
export type FHIRDeviceDefinitionmanufacturerReference_manufacturerReference_Union = FHIROrganization;

export type FHIRDeviceDefinitionmaterial = {
   __typename?: 'FHIRDeviceDefinitionmaterial',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The substance. */
  substance: FHIRCodeableConcept,
  /** Indicates an alternative material of the device. */
  alternate?: Maybe<Scalars['Boolean']>,
  /** Whether the substance is a known or suspected allergen. */
  allergenicIndicator?: Maybe<Scalars['Boolean']>,
};

/** An organization that is responsible for the provision and ongoing maintenance of the device. */
export type FHIRDeviceDefinitionowner_owner_Union = FHIROrganization;

/** The parent device it can be part of. */
export type FHIRDeviceDefinitionparentDevice_parentDevice_Union = FHIRDeviceDefinition;

export type FHIRDeviceDefinitionproperty = {
   __typename?: 'FHIRDeviceDefinitionproperty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Code that specifies the property DeviceDefinitionPropetyCode (Extensible). */
  type: FHIRCodeableConcept,
  /** Property value as a quantity. */
  valueQuantity?: Maybe<Array<Maybe<FHIRQuantity>>>,
  /** Property value as a code, e.g., NTP4 (synced to NTP). */
  valueCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export type FHIRDeviceDefinitionspecialization = {
   __typename?: 'FHIRDeviceDefinitionspecialization',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The standard that is used to operate and communicate. */
  systemType: Scalars['String'],
  /** The version of the standard that is used to operate and communicate. */
  version?: Maybe<Scalars['String']>,
};

export type FHIRDeviceDefinitionudiDeviceIdentifier = {
   __typename?: 'FHIRDeviceDefinitionudiDeviceIdentifier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The identifier that is to be associated with every Device that references this
   * DeviceDefintiion for the issuer and jurisdication porvided in the
   * DeviceDefinition.udiDeviceIdentifier.
 */
  deviceIdentifier: Scalars['String'],
  /** The organization that assigns the identifier algorithm. */
  issuer: Scalars['FHIRUri'],
  /** The jurisdiction to which the deviceIdentifier applies. */
  jurisdiction: Scalars['FHIRUri'],
};

export type FHIRDevicedeviceName = {
   __typename?: 'FHIRDevicedeviceName',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the device. */
  name: Scalars['String'],
  /** The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName. */
  type: Scalars['FHIRCode'],
};

/** The place where the device can be found. */
export type FHIRDevicelocation_location_Union = FHIRLocation;

/** Describes a measurement, calculation or setting capability of a medical device. */
export type FHIRDeviceMetric = {
   __typename?: 'FHIRDeviceMetric',
  /** Type of resource */
  resourceType: FHIRDeviceMetric_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Unique instance identifiers assigned to a device by the device or gateway
   * software, manufacturers, other organizations or owners. For example: handle ID.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc. */
  type: FHIRCodeableConcept,
  /** Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc. */
  unit?: Maybe<FHIRCodeableConcept>,
  /** 
 * Describes the link to the  Device that this DeviceMetric belongs to and that
   * contains administrative device information such as manufacturer, serial number, etc.
 */
  source?: Maybe<FHIRDeviceMetricsource_source_Union>,
  /** 
 * Describes the link to the  Device that this DeviceMetric belongs to and that
   * provide information about the location of this DeviceMetric in the containment
   * structure of the parent Device. An example would be a Device that represents a
   * Channel. This reference can be used by a client application to distinguish
   * DeviceMetrics that have the same type, but should be interpreted based on
   * their containment location.
 */
  parent?: Maybe<FHIRDeviceMetricparent_parent_Union>,
  /** Indicates current operational state of the device. For example: On, Off, Standby, etc. */
  operationalStatus?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Describes the color representation for the metric. This is often used to aid
   * clinicians to track and identify parameter types by color. In practice,
   * consider a Patient Monitor that has ECG/HR and Pleth for example; the
   * parameters are displayed in different characteristic colors, such as HR-blue,
   * BP-green, and PR and SpO2- magenta.
 */
  color?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Indicates the category of the observation generation process. A DeviceMetric
   * can be for example a setting, measurement, or calculation.
 */
  category: Scalars['FHIRCode'],
  /** 
 * Describes the measurement repetition time. This is not necessarily the same as
   * the update period. The measurement repetition time can range from milliseconds
   * up to hours. An example for a measurement repetition time in the range of
   * milliseconds is the sampling rate of an ECG. An example for a measurement
   * repetition time in the range of hours is a NIBP that is triggered
   * automatically every hour. The update period may be different than the
   * measurement repetition time, if the device does not update the published
   * observed value with the same frequency as it was measured.
 */
  measurementPeriod?: Maybe<FHIRTiming>,
  /** Describes the calibrations that have been performed or that are required to be performed. */
  calibration?: Maybe<Array<Maybe<FHIRDeviceMetriccalibration>>>,
};

export enum FHIRDeviceMetric_Enum_schema {
  DeviceMetric = 'DeviceMetric'
}

export type FHIRDeviceMetriccalibration = {
   __typename?: 'FHIRDeviceMetriccalibration',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Describes the type of the calibration method. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** Describes the state of the calibration. */
  state?: Maybe<Scalars['FHIRCode']>,
  /** Describes the time last calibration has been performed. */
  time?: Maybe<Scalars['FHIRInstant']>,
};

/** 
 * Describes the link to the  Device that this DeviceMetric belongs to and that
 * provide information about the location of this DeviceMetric in the containment
 * structure of the parent Device. An example would be a Device that represents a
 * Channel. This reference can be used by a client application to distinguish
 * DeviceMetrics that have the same type, but should be interpreted based on their
 * containment location.
 */
export type FHIRDeviceMetricparent_parent_Union = FHIRDevice;

/** 
 * Describes the link to the  Device that this DeviceMetric belongs to and that
 * contains administrative device information such as manufacturer, serial number, etc.
 */
export type FHIRDeviceMetricsource_source_Union = FHIRDevice;

/** An organization that is responsible for the provision and ongoing maintenance of the device. */
export type FHIRDeviceowner_owner_Union = FHIROrganization;

/** The parent device. */
export type FHIRDeviceparent_parent_Union = FHIRDevice;

/** Patient information, If the device is affixed to a person. */
export type FHIRDevicepatient_patient_Union = FHIRPatient;

export type FHIRDeviceproperty = {
   __typename?: 'FHIRDeviceproperty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Code that specifies the property DeviceDefinitionPropetyCode (Extensible). */
  type: FHIRCodeableConcept,
  /** Property value as a quantity. */
  valueQuantity?: Maybe<Array<Maybe<FHIRQuantity>>>,
  /** Property value as a code, e.g., NTP4 (synced to NTP). */
  valueCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

/** 
 * Represents a request for a patient to employ a medical device. The device may be
 * an implantable device, or an external assistive device, such as a walker.
 */
export type FHIRDeviceRequest = {
   __typename?: 'FHIRDeviceRequest',
  /** Type of resource */
  resourceType: FHIRDeviceRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this order by the orderer or by the receiver. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this DeviceRequest.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this DeviceRequest.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** Plan/proposal/order fulfilled by this request. */
  basedOn?: Maybe<Array<Maybe<FHIRDeviceRequestbasedOn_basedOn_Union>>>,
  /** The request takes the place of the referenced completed or terminated request(s). */
  priorRequest?: Maybe<Array<Maybe<FHIRDeviceRequestpriorRequest_priorRequest_Union>>>,
  /** Composite request this is part of. */
  groupIdentifier?: Maybe<FHIRIdentifier>,
  /** The status of the request. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** Whether the request is a proposal, plan, an original order or a reflex order. */
  intent: Scalars['FHIRCode'],
  /** Indicates how quickly the {{title}} should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** The details of the device to be used. */
  codeReference: FHIRDeviceRequestcodeReference_codeReference_Union,
  /** The details of the device to be used. */
  codeCodeableConcept: FHIRCodeableConcept,
  /** Specific parameters for the ordered item.  For example, the prism value for lenses. */
  parameter?: Maybe<Array<Maybe<FHIRDeviceRequestparameter>>>,
  /** The patient who will use the device. */
  subject: FHIRDeviceRequestsubject_subject_Union,
  /** An encounter that provides additional context in which this request is made. */
  encounter?: Maybe<FHIRDeviceRequestencounter_encounter_Union>,
  /** 
 * The timing schedule for the use of the device. The Schedule data type allows
   * many different expressions, for example. 'Every 8 hours'; 'Three times a day';
   * '1/2 an hour before breakfast for 10 days from 23-Dec 2011:'; '15 Oct 2013, 17
   * Oct 2013 and 1 Nov 2013'.
 */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The timing schedule for the use of the device. The Schedule data type allows
   * many different expressions, for example. 'Every 8 hours'; 'Three times a day';
   * '1/2 an hour before breakfast for 10 days from 23-Dec 2011:'; '15 Oct 2013, 17
   * Oct 2013 and 1 Nov 2013'.
 */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** 
 * The timing schedule for the use of the device. The Schedule data type allows
   * many different expressions, for example. 'Every 8 hours'; 'Three times a day';
   * '1/2 an hour before breakfast for 10 days from 23-Dec 2011:'; '15 Oct 2013, 17
   * Oct 2013 and 1 Nov 2013'.
 */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** When the request transitioned to being actionable. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The individual who initiated the request and has responsibility for its activation. */
  requester?: Maybe<FHIRDeviceRequestrequester_requester_Union>,
  /** Desired type of performer for doing the diagnostic testing. */
  performerType?: Maybe<FHIRCodeableConcept>,
  /** The desired performer for doing the diagnostic testing. */
  performer?: Maybe<FHIRDeviceRequestperformer_performer_Union>,
  /** Reason or justification for the use of this device. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Reason or justification for the use of this device. */
  reasonReference?: Maybe<Array<Maybe<FHIRDeviceRequestreasonReference_reasonReference_Union>>>,
  /** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
   * pre-determinations that may be required for delivering the requested service.
 */
  insurance?: Maybe<Array<Maybe<FHIRDeviceRequestinsurance_insurance_Union>>>,
  /** 
 * Additional clinical information about the patient that may influence the
   * request fulfilment.  For example, this may include where on the subject's body
   * the device will be used (i.e. the target site).
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRDeviceRequestsupportingInfo_supportingInfo_Union>>>,
  /** 
 * Details about this request that were not represented at all or sufficiently in
   * one of the attributes provided in a class. These may include for example a
   * comment, an instruction, or a note associated with the statement.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Key events in the history of the request. */
  relevantHistory?: Maybe<Array<Maybe<FHIRDeviceRequestrelevantHistory_relevantHistory_Union>>>,
};

export enum FHIRDeviceRequest_Enum_schema {
  DeviceRequest = 'DeviceRequest'
}

/** Plan/proposal/order fulfilled by this request. */
export type FHIRDeviceRequestbasedOn_basedOn_Union = FHIRResource;

/** The details of the device to be used. */
export type FHIRDeviceRequestcodeReference_codeReference_Union = FHIRDevice;

/** An encounter that provides additional context in which this request is made. */
export type FHIRDeviceRequestencounter_encounter_Union = FHIREncounter;

/** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
 * pre-determinations that may be required for delivering the requested service.
 */
export type FHIRDeviceRequestinsurance_insurance_Union = FHIRCoverage | FHIRClaimResponse;

export type FHIRDeviceRequestparameter = {
   __typename?: 'FHIRDeviceRequestparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code or string that identifies the device detail being asserted. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The value of the device detail. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The value of the device detail. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** The value of the device detail. */
  valueRange?: Maybe<FHIRRange>,
  /** The value of the device detail. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
};

/** The desired performer for doing the diagnostic testing. */
export type FHIRDeviceRequestperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRHealthcareService | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** The request takes the place of the referenced completed or terminated request(s). */
export type FHIRDeviceRequestpriorRequest_priorRequest_Union = FHIRResource;

/** Reason or justification for the use of this device. */
export type FHIRDeviceRequestreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** Key events in the history of the request. */
export type FHIRDeviceRequestrelevantHistory_relevantHistory_Union = FHIRProvenance;

/** The individual who initiated the request and has responsibility for its activation. */
export type FHIRDeviceRequestrequester_requester_Union = FHIRDevice | FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** The patient who will use the device. */
export type FHIRDeviceRequestsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRLocation | FHIRDevice;

/** 
 * Additional clinical information about the patient that may influence the request
 * fulfilment.  For example, this may include where on the subject's body the
 * device will be used (i.e. the target site).
 */
export type FHIRDeviceRequestsupportingInfo_supportingInfo_Union = FHIRResource;

export type FHIRDevicespecialization = {
   __typename?: 'FHIRDevicespecialization',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The standard that is used to operate and communicate. */
  systemType: FHIRCodeableConcept,
  /** The version of the standard that is used to operate and communicate. */
  version?: Maybe<Scalars['String']>,
};

export type FHIRDeviceudiCarrier = {
   __typename?: 'FHIRDeviceudiCarrier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The device identifier (DI) is a mandatory, fixed portion of a UDI that
   * identifies the labeler and the specific version or model of a device.
 */
  deviceIdentifier?: Maybe<Scalars['String']>,
  /** 
 * Organization that is charged with issuing UDIs for devices.  For example, the
   * US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2)
   * HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood
   * containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for
   * other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
 */
  issuer?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The identity of the authoritative source for UDI generation within a 
   * jurisdiction.  All UDIs are globally unique within a single namespace with the
   * appropriate repository uri as the system.  For example,  UDIs of devices
   * managed in the U.S. by the FDA, the value is 
   * http://hl7.org/fhir/NamingSystem/fda-udi.
 */
  jurisdiction?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The full UDI carrier of the Automatic Identification and Data Capture (AIDC)
   * technology representation of the barcode string as printed on the packaging of
   * the device - e.g., a barcode or RFID.   Because of limitations on character
   * sets in XML and the need to round-trip JSON data through XML, AIDC Formats
   * *SHALL* be base64 encoded.
 */
  carrierAIDC?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * The full UDI carrier as the human readable form (HRF) representation of the
   * barcode string as printed on the packaging of the device.
 */
  carrierHRF?: Maybe<Scalars['String']>,
  /** A coded entry to indicate how the data was entered. */
  entryType?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * A record of a device being used by a patient where the record is the result of a
 * report from the patient or another clinician.
 */
export type FHIRDeviceUseStatement = {
   __typename?: 'FHIRDeviceUseStatement',
  /** Type of resource */
  resourceType: FHIRDeviceUseStatement_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An external identifier for this statement such as an IRI. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A plan, proposal or order that is fulfilled in whole or in part by this DeviceUseStatement. */
  basedOn?: Maybe<Array<Maybe<FHIRDeviceUseStatementbasedOn_basedOn_Union>>>,
  /** 
 * A code representing the patient or other source's judgment about the state of
   * the device used that this statement is about.  Generally this will be active or completed.
 */
  status: Scalars['FHIRCode'],
  /** The patient who used the device. */
  subject: FHIRDeviceUseStatementsubject_subject_Union,
  /** 
 * Allows linking the DeviceUseStatement to the underlying Request, or to other
   * information that supports or is used to derive the DeviceUseStatement.
 */
  derivedFrom?: Maybe<Array<Maybe<FHIRDeviceUseStatementderivedFrom_derivedFrom_Union>>>,
  /** How often the device was used. */
  timingTiming?: Maybe<FHIRTiming>,
  /** How often the device was used. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** How often the device was used. */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The time at which the statement was made/recorded. */
  recordedOn?: Maybe<Scalars['FHIRDateTime']>,
  /** Who reported the device was being used by the patient. */
  source?: Maybe<FHIRDeviceUseStatementsource_source_Union>,
  /** The details of the device used. */
  device: FHIRDeviceUseStatementdevice_device_Union,
  /** Reason or justification for the use of the device. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies this DeviceUseStatement. */
  reasonReference?: Maybe<Array<Maybe<FHIRDeviceUseStatementreasonReference_reasonReference_Union>>>,
  /** Indicates the anotomic location on the subject's body where the device was used ( i.e. the target). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** 
 * Details about the device statement that were not represented at all or
   * sufficiently in one of the attributes provided in a class. These may include
   * for example a comment, an instruction, or a note associated with the statement.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRDeviceUseStatement_Enum_schema {
  DeviceUseStatement = 'DeviceUseStatement'
}

/** A plan, proposal or order that is fulfilled in whole or in part by this DeviceUseStatement. */
export type FHIRDeviceUseStatementbasedOn_basedOn_Union = FHIRServiceRequest;

/** 
 * Allows linking the DeviceUseStatement to the underlying Request, or to other
 * information that supports or is used to derive the DeviceUseStatement.
 */
export type FHIRDeviceUseStatementderivedFrom_derivedFrom_Union = FHIRServiceRequest | FHIRProcedure | FHIRClaim | FHIRObservation | FHIRQuestionnaireResponse | FHIRDocumentReference;

/** The details of the device used. */
export type FHIRDeviceUseStatementdevice_device_Union = FHIRDevice;

/** Indicates another resource whose existence justifies this DeviceUseStatement. */
export type FHIRDeviceUseStatementreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference | FHIRMedia;

/** Who reported the device was being used by the patient. */
export type FHIRDeviceUseStatementsource_source_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** The patient who used the device. */
export type FHIRDeviceUseStatementsubject_subject_Union = FHIRPatient | FHIRGroup;

export type FHIRDeviceversion = {
   __typename?: 'FHIRDeviceversion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of the device version. */
  type?: Maybe<FHIRCodeableConcept>,
  /** A single component of the device version. */
  component?: Maybe<FHIRIdentifier>,
  /** The version text. */
  value: Scalars['String'],
};

/** 
 * The findings and interpretation of diagnostic  tests performed on patients,
 * groups of patients, devices, and locations, and/or specimens derived from these.
 * The report includes clinical context such as requesting and provider
 * information, and some mix of atomic results, images, textual and coded
 * interpretations, and formatted representation of diagnostic reports.
 */
export type FHIRDiagnosticReport = {
   __typename?: 'FHIRDiagnosticReport',
  /** Type of resource */
  resourceType: FHIRDiagnosticReport_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this report by the performer or other systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Details concerning a service requested. */
  basedOn?: Maybe<Array<Maybe<FHIRDiagnosticReportbasedOn_basedOn_Union>>>,
  /** The status of the diagnostic report. */
  status: Scalars['FHIRCode'],
  /** 
 * A code that classifies the clinical discipline, department or diagnostic
   * service that created the report (e.g. cardiology, biochemistry, hematology,
   * MRI). This is used for searching, sorting and display purposes.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A code or name that describes this diagnostic report. */
  code: FHIRCodeableConcept,
  /** 
 * The subject of the report. Usually, but not always, this is a patient.
   * However, diagnostic services also perform analyses on specimens collected from
   * a variety of other sources.
 */
  subject?: Maybe<FHIRDiagnosticReportsubject_subject_Union>,
  /** The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about. */
  encounter?: Maybe<FHIRDiagnosticReportencounter_encounter_Union>,
  /** 
 * The time or time-period the observed values are related to. When the subject
   * of the report is a patient, this is usually either the time of the procedure
   * or of specimen collection(s), but very often the source of the date/time is
   * not known, only the date/time itself.
 */
  effectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The time or time-period the observed values are related to. When the subject
   * of the report is a patient, this is usually either the time of the procedure
   * or of specimen collection(s), but very often the source of the date/time is
   * not known, only the date/time itself.
 */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * The date and time that this version of the report was made available to
   * providers, typically after the report was reviewed and verified.
 */
  issued?: Maybe<Scalars['FHIRInstant']>,
  /** The diagnostic service that is responsible for issuing the report. */
  performer?: Maybe<Array<Maybe<FHIRDiagnosticReportperformer_performer_Union>>>,
  /** The practitioner or organization that is responsible for the report's conclusions and interpretations. */
  resultsInterpreter?: Maybe<Array<Maybe<FHIRDiagnosticReportresultsInterpreter_resultsInterpreter_Union>>>,
  /** Details about the specimens on which this diagnostic report is based. */
  specimen?: Maybe<Array<Maybe<FHIRDiagnosticReportspecimen_specimen_Union>>>,
  /** [Observations](observation.html)  that are part of this diagnostic report. */
  result?: Maybe<Array<Maybe<FHIRDiagnosticReportresult_result_Union>>>,
  /** 
 * One or more links to full details of any imaging performed during the
   * diagnostic investigation. Typically, this is imaging performed by DICOM
   * enabled modalities, but this is not required. A fully enabled PACS viewer can
   * use this information to provide views of the source images.
 */
  imagingStudy?: Maybe<Array<Maybe<FHIRDiagnosticReportimagingStudy_imagingStudy_Union>>>,
  /** 
 * A list of key images associated with this report. The images are generally
   * created during the diagnostic process, and may be directly of the patient, or
   * of treated specimens (i.e. slides of interest).
 */
  media?: Maybe<Array<Maybe<FHIRDiagnosticReportmedia>>>,
  /** Concise and clinically contextualized summary conclusion (interpretation/impression) of the diagnostic report. */
  conclusion?: Maybe<Scalars['String']>,
  /** One or more codes that represent the summary conclusion (interpretation/impression) of the diagnostic report. */
  conclusionCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Rich text representation of the entire result as issued by the diagnostic
   * service. Multiple formats are allowed but they SHALL be semantically equivalent.
 */
  presentedForm?: Maybe<Array<Maybe<FHIRAttachment>>>,
};

export enum FHIRDiagnosticReport_Enum_schema {
  DiagnosticReport = 'DiagnosticReport'
}

/** Details concerning a service requested. */
export type FHIRDiagnosticReportbasedOn_basedOn_Union = FHIRCarePlan | FHIRImmunizationRecommendation | FHIRMedicationRequest | FHIRNutritionOrder | FHIRServiceRequest;

/** The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about. */
export type FHIRDiagnosticReportencounter_encounter_Union = FHIREncounter;

/** 
 * One or more links to full details of any imaging performed during the diagnostic
 * investigation. Typically, this is imaging performed by DICOM enabled modalities,
 * but this is not required. A fully enabled PACS viewer can use this information
 * to provide views of the source images.
 */
export type FHIRDiagnosticReportimagingStudy_imagingStudy_Union = FHIRImagingStudy;

export type FHIRDiagnosticReportmedia = {
   __typename?: 'FHIRDiagnosticReportmedia',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A comment about the image. Typically, this is used to provide an explanation
   * for why the image is included, or to draw the viewer's attention to important features.
 */
  comment?: Maybe<Scalars['String']>,
  /** Reference to the image source. */
  link: FHIRDiagnosticReportmedialink_link_Union,
};

/** Reference to the image source. */
export type FHIRDiagnosticReportmedialink_link_Union = FHIRMedia;

/** The diagnostic service that is responsible for issuing the report. */
export type FHIRDiagnosticReportperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam;

/** [Observations](observation.html)  that are part of this diagnostic report. */
export type FHIRDiagnosticReportresult_result_Union = FHIRObservation;

/** The practitioner or organization that is responsible for the report's conclusions and interpretations. */
export type FHIRDiagnosticReportresultsInterpreter_resultsInterpreter_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam;

/** Details about the specimens on which this diagnostic report is based. */
export type FHIRDiagnosticReportspecimen_specimen_Union = FHIRSpecimen;

/** 
 * The subject of the report. Usually, but not always, this is a patient. However,
 * diagnostic services also perform analyses on specimens collected from a variety
 * of other sources.
 */
export type FHIRDiagnosticReportsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRDevice | FHIRLocation;

/** Base StructureDefinition for Distance Type: A length - a value with a unit that is a physical distance. */
export type FHIRDistance = {
   __typename?: 'FHIRDistance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** Base StructureDefinition for Distance Type: A length - a value with a unit that is a physical distance. */
export type FHIRDistance_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  _value?: Maybe<FHIRElement_Input>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  _comparator?: Maybe<FHIRElement_Input>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  _unit?: Maybe<FHIRElement_Input>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  _code?: Maybe<FHIRElement_Input>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** A collection of documents compiled for a purpose together with metadata that applies to the collection. */
export type FHIRDocumentManifest = {
   __typename?: 'FHIRDocumentManifest',
  /** Type of resource */
  resourceType: FHIRDocumentManifest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A single identifier that uniquely identifies this manifest. Principally used
   * to refer to the manifest in non-FHIR contexts.
 */
  masterIdentifier?: Maybe<FHIRIdentifier>,
  /** Other identifiers associated with the document manifest, including version independent  identifiers. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of this document manifest. */
  status: Scalars['FHIRCode'],
  /** 
 * The code specifying the type of clinical activity that resulted in placing the
   * associated content into the DocumentManifest.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Who or what the set of documents is about. The documents can be about a
   * person, (patient or healthcare practitioner), a device (i.e. machine) or even
   * a group of subjects (such as a document about a herd of farm animals, or a set
   * of patients that share a common exposure). If the documents cross more than
   * one subject, then more than one subject is allowed here (unusual use case).
 */
  subject?: Maybe<FHIRDocumentManifestsubject_subject_Union>,
  /** 
 * When the document manifest was created for submission to the server (not
   * necessarily the same thing as the actual resource last modified time, since it
   * may be modified, replicated, etc.).
 */
  created?: Maybe<Scalars['FHIRDateTime']>,
  /** Identifies who is the author of the manifest. Manifest author is not necessarly the author of the references included. */
  author?: Maybe<Array<Maybe<FHIRDocumentManifestauthor_author_Union>>>,
  /** A patient, practitioner, or organization for which this set of documents is intended. */
  recipient?: Maybe<Array<Maybe<FHIRDocumentManifestrecipient_recipient_Union>>>,
  /** Identifies the source system, application, or software that produced the document manifest. */
  source?: Maybe<Scalars['FHIRUri']>,
  /** Human-readable description of the source document. This is sometimes known as the 'title'. */
  description?: Maybe<Scalars['String']>,
  /** The list of Resources that consist of the parts of this manifest. */
  content?: Maybe<Array<FHIRDocumentManifestcontent_content_Union>>,
  /** Related identifiers or resources associated with the DocumentManifest. */
  related?: Maybe<Array<Maybe<FHIRDocumentManifestrelated>>>,
};

export enum FHIRDocumentManifest_Enum_schema {
  DocumentManifest = 'DocumentManifest'
}

/** Identifies who is the author of the manifest. Manifest author is not necessarly the author of the references included. */
export type FHIRDocumentManifestauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRDevice | FHIRPatient | FHIRRelatedPerson;

/** The list of Resources that consist of the parts of this manifest. */
export type FHIRDocumentManifestcontent_content_Union = FHIRResource;

/** A patient, practitioner, or organization for which this set of documents is intended. */
export type FHIRDocumentManifestrecipient_recipient_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIROrganization;

export type FHIRDocumentManifestrelated = {
   __typename?: 'FHIRDocumentManifestrelated',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc. */
  ref?: Maybe<FHIRDocumentManifestrelatedref_ref_Union>,
};

/** Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc. */
export type FHIRDocumentManifestrelatedref_ref_Union = FHIRResource;

/** 
 * Who or what the set of documents is about. The documents can be about a person,
 * (patient or healthcare practitioner), a device (i.e. machine) or even a group of
 * subjects (such as a document about a herd of farm animals, or a set of patients
 * that share a common exposure). If the documents cross more than one subject,
 * then more than one subject is allowed here (unusual use case).
 */
export type FHIRDocumentManifestsubject_subject_Union = FHIRPatient | FHIRPractitioner | FHIRGroup | FHIRDevice;

/** 
 * A reference to a document of any kind for any purpose. Provides metadata about
 * the document so that the document can be discovered and managed. The scope of a
 * document is any seralized object with a mime-type, so includes formal patient
 * centric documents (CDA), cliical notes, scanned paper, and non-patient specific
 * documents like policy text.
 */
export type FHIRDocumentReference = {
   __typename?: 'FHIRDocumentReference',
  /** Type of resource */
  resourceType: FHIRDocumentReference_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Document identifier as assigned by the source of the document. This identifier
   * is specific to this version of the document. This unique identifier may be
   * used elsewhere to identify this version of the document.
 */
  masterIdentifier?: Maybe<FHIRIdentifier>,
  /** Other identifiers associated with the document, including version independent identifiers. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of this document reference. */
  status: Scalars['FHIRCode'],
  /** The status of the underlying document. */
  docStatus?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies the particular kind of document referenced  (e.g. History and
   * Physical, Discharge Summary, Progress Note). This usually equates to the
   * purpose of making the document referenced.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * A categorization for the type of document referenced - helps for indexing and
   * searching. This may be implied by or derived from the code specified in the
   * DocumentReference.type.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Who or what the document is about. The document can be about a person,
   * (patient or healthcare practitioner), a device (e.g. a machine) or even a
   * group of subjects (such as a document about a herd of farm animals, or a set
   * of patients that share a common exposure).
 */
  subject?: Maybe<FHIRDocumentReferencesubject_subject_Union>,
  /** When the document reference was created. */
  date?: Maybe<Scalars['FHIRInstant']>,
  /** Identifies who is responsible for adding the information to the document. */
  author?: Maybe<Array<Maybe<FHIRDocumentReferenceauthor_author_Union>>>,
  /** Which person or organization authenticates that this document is valid. */
  authenticator?: Maybe<FHIRDocumentReferenceauthenticator_authenticator_Union>,
  /** Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. */
  custodian?: Maybe<FHIRDocumentReferencecustodian_custodian_Union>,
  /** Relationships that this document has with other document references that already exist. */
  relatesTo?: Maybe<Array<Maybe<FHIRDocumentReferencerelatesTo>>>,
  /** Human-readable description of the source document. */
  description?: Maybe<Scalars['String']>,
  /** 
 * A set of Security-Tag codes specifying the level of privacy/security of the
   * Document. Note that DocumentReference.meta.security contains the security
   * labels of the 'reference' to the document, while
   * DocumentReference.securityLabel contains a snapshot of the security labels on
   * the document the reference refers to.
 */
  securityLabel?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The document and format referenced. There may be multiple content element repetitions, each with a different format. */
  content?: Maybe<Array<FHIRDocumentReferencecontent>>,
  /** The clinical context in which the document was prepared. */
  context?: Maybe<FHIRDocumentReferencecontext>,
};

export enum FHIRDocumentReference_Enum_schema {
  DocumentReference = 'DocumentReference'
}

/** Which person or organization authenticates that this document is valid. */
export type FHIRDocumentReferenceauthenticator_authenticator_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Identifies who is responsible for adding the information to the document. */
export type FHIRDocumentReferenceauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRDevice | FHIRPatient | FHIRRelatedPerson;

export type FHIRDocumentReferencecontent = {
   __typename?: 'FHIRDocumentReferencecontent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The document or URL of the document along with critical metadata to prove content has integrity. */
  attachment: FHIRAttachment,
  /** 
 * An identifier of the document encoding, structure, and template that the
   * document conforms to beyond the base format indicated in the mimeType.
 */
  format?: Maybe<FHIRCoding>,
};

export type FHIRDocumentReferencecontext = {
   __typename?: 'FHIRDocumentReferencecontext',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Describes the clinical encounter or type of care that the document content is associated with. */
  encounter?: Maybe<Array<Maybe<FHIRDocumentReferencecontextencounter_encounter_Union>>>,
  /** 
 * This list of codes represents the main clinical acts, such as a colonoscopy or
   * an appendectomy, being documented. In some cases, the event is inherent in the
   * type Code, such as a 'History and Physical Report' in which the procedure
   * being documented is necessarily a 'History and Physical' act.
 */
  event?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The time period over which the service that is described by the document was provided. */
  period?: Maybe<FHIRPeriod>,
  /** The kind of facility where the patient was seen. */
  facilityType?: Maybe<FHIRCodeableConcept>,
  /** 
 * This property may convey specifics about the practice setting where the
   * content was created, often reflecting the clinical specialty.
 */
  practiceSetting?: Maybe<FHIRCodeableConcept>,
  /** The Patient Information as known when the document was published. May be a reference to a version specific, or contained. */
  sourcePatientInfo?: Maybe<FHIRDocumentReferencecontextsourcePatientInfo_sourcePatientInfo_Union>,
  /** Related identifiers or resources associated with the DocumentReference. */
  related?: Maybe<Array<Maybe<FHIRDocumentReferencecontextrelated_related_Union>>>,
};

/** Describes the clinical encounter or type of care that the document content is associated with. */
export type FHIRDocumentReferencecontextencounter_encounter_Union = FHIREncounter | FHIREpisodeOfCare;

/** Related identifiers or resources associated with the DocumentReference. */
export type FHIRDocumentReferencecontextrelated_related_Union = FHIRResource;

/** The Patient Information as known when the document was published. May be a reference to a version specific, or contained. */
export type FHIRDocumentReferencecontextsourcePatientInfo_sourcePatientInfo_Union = FHIRPatient;

/** Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. */
export type FHIRDocumentReferencecustodian_custodian_Union = FHIROrganization;

export type FHIRDocumentReferencerelatesTo = {
   __typename?: 'FHIRDocumentReferencerelatesTo',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relationship that this document has with anther document. */
  code: Scalars['FHIRCode'],
  /** The target document of this relationship. */
  target: FHIRDocumentReferencerelatesTotarget_target_Union,
};

/** The target document of this relationship. */
export type FHIRDocumentReferencerelatesTotarget_target_Union = FHIRDocumentReference;

/** 
 * Who or what the document is about. The document can be about a person, (patient
 * or healthcare practitioner), a device (e.g. a machine) or even a group of
 * subjects (such as a document about a herd of farm animals, or a set of patients
 * that share a common exposure).
 */
export type FHIRDocumentReferencesubject_subject_Union = FHIRPatient | FHIRPractitioner | FHIRGroup | FHIRDevice;

/** A resource that includes narrative, extensions, and contained resources. */
export type FHIRDomainResource = {
   __typename?: 'FHIRDomainResource',
  /** Type of resource */
  resourceType: FHIRDomainResource_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

export enum FHIRDomainResource_Enum_schema {
  DomainResource = 'DomainResource'
}

/** Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient. */
export type FHIRDosage = {
   __typename?: 'FHIRDosage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates the order in which the dosage instructions should be applied or interpreted. */
  sequence?: Maybe<Scalars['Int']>,
  /** Free text dosage instructions e.g. SIG. */
  text?: Maybe<Scalars['String']>,
  /** 
 * Supplemental instructions to the patient on how to take the medication  (e.g.
   * 'with meals' or'take half to one hour before food') or warnings for the
   * patient about the medication (e.g. 'may cause drowsiness' or 'avoid exposure
   * of skin to direct sunlight or sunlamps').
 */
  additionalInstruction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Instructions in terms that are understood by the patient or consumer. */
  patientInstruction?: Maybe<Scalars['String']>,
  /** When medication should be administered. */
  timing?: Maybe<FHIRTiming>,
  /** 
 * Indicates whether the Medication is only taken when needed within a specific
   * dosing schedule (Boolean option), or it indicates the precondition for taking
   * the Medication (CodeableConcept).
 */
  asNeededBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Indicates whether the Medication is only taken when needed within a specific
   * dosing schedule (Boolean option), or it indicates the precondition for taking
   * the Medication (CodeableConcept).
 */
  asNeededCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Body site to administer to. */
  site?: Maybe<FHIRCodeableConcept>,
  /** How drug should enter body. */
  route?: Maybe<FHIRCodeableConcept>,
  /** Technique for administering medication. */
  method?: Maybe<FHIRCodeableConcept>,
  /** The amount of medication administered. */
  doseAndRate?: Maybe<Array<Maybe<FHIRElement>>>,
  /** Upper limit on medication per unit of time. */
  maxDosePerPeriod?: Maybe<FHIRRatio>,
  /** Upper limit on medication per administration. */
  maxDosePerAdministration?: Maybe<FHIRQuantity>,
  /** Upper limit on medication per lifetime of the patient. */
  maxDosePerLifetime?: Maybe<FHIRQuantity>,
};

/** Base StructureDefinition for Dosage Type: Indicates how the medication is/was taken or should be taken by the patient. */
export type FHIRDosage_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Indicates the order in which the dosage instructions should be applied or interpreted. */
  _sequence?: Maybe<FHIRElement_Input>,
  /** Indicates the order in which the dosage instructions should be applied or interpreted. */
  sequence?: Maybe<Scalars['Int']>,
  /** Free text dosage instructions e.g. SIG. */
  _text?: Maybe<FHIRElement_Input>,
  /** Free text dosage instructions e.g. SIG. */
  text?: Maybe<Scalars['String']>,
  /** 
 * Supplemental instructions to the patient on how to take the medication  (e.g.
   * 'with meals' or'take half to one hour before food') or warnings for the
   * patient about the medication (e.g. 'may cause drowsiness' or 'avoid exposure
   * of skin to direct sunlight or sunlamps').
 */
  additionalInstruction?: Maybe<Array<Maybe<FHIRCodeableConcept_Input>>>,
  /** Instructions in terms that are understood by the patient or consumer. */
  _patientInstruction?: Maybe<FHIRElement_Input>,
  /** Instructions in terms that are understood by the patient or consumer. */
  patientInstruction?: Maybe<Scalars['String']>,
  /** When medication should be administered. */
  timing?: Maybe<FHIRTiming_Input>,
  /** 
 * Indicates whether the Medication is only taken when needed within a specific
   * dosing schedule (Boolean option), or it indicates the precondition for taking
   * the Medication (CodeableConcept).
 */
  _asNeededBoolean?: Maybe<FHIRElement_Input>,
  /** 
 * Indicates whether the Medication is only taken when needed within a specific
   * dosing schedule (Boolean option), or it indicates the precondition for taking
   * the Medication (CodeableConcept).
 */
  asNeededBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Indicates whether the Medication is only taken when needed within a specific
   * dosing schedule (Boolean option), or it indicates the precondition for taking
   * the Medication (CodeableConcept).
 */
  asNeededCodeableConcept?: Maybe<FHIRCodeableConcept_Input>,
  /** Body site to administer to. */
  site?: Maybe<FHIRCodeableConcept_Input>,
  /** How drug should enter body. */
  route?: Maybe<FHIRCodeableConcept_Input>,
  /** Technique for administering medication. */
  method?: Maybe<FHIRCodeableConcept_Input>,
  /** The amount of medication administered. */
  doseAndRate?: Maybe<Array<Maybe<FHIRElement_Input>>>,
  /** Upper limit on medication per unit of time. */
  maxDosePerPeriod?: Maybe<FHIRRatio_Input>,
  /** Upper limit on medication per administration. */
  maxDosePerAdministration?: Maybe<FHIRQuantity_Input>,
  /** Upper limit on medication per lifetime of the patient. */
  maxDosePerLifetime?: Maybe<FHIRQuantity_Input>,
};

/** Base StructureDefinition for Duration Type: A length of time. */
export type FHIRDuration = {
   __typename?: 'FHIRDuration',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** Base StructureDefinition for Duration Type: A length of time. */
export type FHIRDuration_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  _value?: Maybe<FHIRElement_Input>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  _comparator?: Maybe<FHIRElement_Input>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  _unit?: Maybe<FHIRElement_Input>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  _code?: Maybe<FHIRElement_Input>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * The EffectEvidenceSynthesis resource describes the difference in an outcome
 * between exposures states in a population where the effect estimate is derived
 * from a combination of research studies.
 */
export type FHIREffectEvidenceSynthesis = {
   __typename?: 'FHIREffectEvidenceSynthesis',
  /** Type of resource */
  resourceType: FHIREffectEvidenceSynthesis_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this effect evidence synthesis when
   * it is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this effect
   * evidence synthesis is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the effect evidence
   * synthesis is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this effect evidence synthesis
   * when it is represented in other formats, or referenced in a specification,
   * model, design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the effect evidence
   * synthesis when it is referenced in a specification, model, design or instance.
   * This is an arbitrary value managed by the effect evidence synthesis author and
   * is not expected to be globally unique. For example, it might be a timestamp
   * (e.g. yyyymmdd) if a managed version is not available. There is also no
   * expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the effect evidence synthesis. This name
   * should be usable as an identifier for the module by machine processing
   * applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the effect evidence synthesis. */
  title?: Maybe<Scalars['String']>,
  /** The status of this effect evidence synthesis. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * The date  (and optionally time) when the effect evidence synthesis was
   * published. The date must change when the business version changes and it must
   * change if the status code changes. In addition, it should change when the
   * substantive content of the effect evidence synthesis changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the effect evidence synthesis. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the effect evidence synthesis from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate effect
   * evidence synthesis instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the effect evidence synthesis is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the effect evidence synthesis and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the effect evidence synthesis.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the effect evidence synthesis content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the EffectEvidenceSynthesis.
   * Topics provide a high-level categorization grouping types of
   * EffectEvidenceSynthesiss that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** Type of synthesis eg meta-analysis. */
  synthesisType?: Maybe<FHIRCodeableConcept>,
  /** Type of study eg randomized trial. */
  studyType?: Maybe<FHIRCodeableConcept>,
  /** A reference to a EvidenceVariable resource that defines the population for the research. */
  population: FHIREffectEvidenceSynthesispopulation_population_Union,
  /** A reference to a EvidenceVariable resource that defines the exposure for the research. */
  exposure: FHIREffectEvidenceSynthesisexposure_exposure_Union,
  /** A reference to a EvidenceVariable resource that defines the comparison exposure for the research. */
  exposureAlternative: FHIREffectEvidenceSynthesisexposureAlternative_exposureAlternative_Union,
  /** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
  outcome: FHIREffectEvidenceSynthesisoutcome_outcome_Union,
  /** A description of the size of the sample involved in the synthesis. */
  sampleSize?: Maybe<FHIREffectEvidenceSynthesissampleSize>,
  /** A description of the results for each exposure considered in the effect estimate. */
  resultsByExposure?: Maybe<Array<Maybe<FHIREffectEvidenceSynthesisresultsByExposure>>>,
  /** The estimated effect of the exposure variant. */
  effectEstimate?: Maybe<Array<Maybe<FHIREffectEvidenceSynthesiseffectEstimate>>>,
  /** A description of the certainty of the effect estimate. */
  certainty?: Maybe<Array<Maybe<FHIREffectEvidenceSynthesiscertainty>>>,
};

export enum FHIREffectEvidenceSynthesis_Enum_schema {
  EffectEvidenceSynthesis = 'EffectEvidenceSynthesis'
}

export type FHIREffectEvidenceSynthesiscertainty = {
   __typename?: 'FHIREffectEvidenceSynthesiscertainty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A rating of the certainty of the effect estimate. */
  rating?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** A description of a component of the overall certainty. */
  certaintySubcomponent?: Maybe<Array<Maybe<FHIREffectEvidenceSynthesiscertaintycertaintySubcomponent>>>,
};

export type FHIREffectEvidenceSynthesiscertaintycertaintySubcomponent = {
   __typename?: 'FHIREffectEvidenceSynthesiscertaintycertaintySubcomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of subcomponent of certainty rating. */
  type?: Maybe<FHIRCodeableConcept>,
  /** A rating of a subcomponent of rating certainty. */
  rating?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export type FHIREffectEvidenceSynthesiseffectEstimate = {
   __typename?: 'FHIREffectEvidenceSynthesiseffectEstimate',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable summary of effect estimate. */
  description?: Maybe<Scalars['String']>,
  /** Examples include relative risk and mean difference. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Used to define variant exposure states such as low-risk state. */
  variantState?: Maybe<FHIRCodeableConcept>,
  /** The point estimate of the effect estimate. */
  value?: Maybe<Scalars['Float']>,
  /** Specifies the UCUM unit for the outcome. */
  unitOfMeasure?: Maybe<FHIRCodeableConcept>,
  /** A description of the precision of the estimate for the effect. */
  precisionEstimate?: Maybe<Array<Maybe<FHIREffectEvidenceSynthesiseffectEstimateprecisionEstimate>>>,
};

export type FHIREffectEvidenceSynthesiseffectEstimateprecisionEstimate = {
   __typename?: 'FHIREffectEvidenceSynthesiseffectEstimateprecisionEstimate',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Examples include confidence interval and interquartile range. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Use 95 for a 95% confidence interval. */
  level?: Maybe<Scalars['Float']>,
  /** Lower bound of confidence interval. */
  from?: Maybe<Scalars['Float']>,
  /** Upper bound of confidence interval. */
  to?: Maybe<Scalars['Float']>,
};

/** A reference to a EvidenceVariable resource that defines the exposure for the research. */
export type FHIREffectEvidenceSynthesisexposure_exposure_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resource that defines the comparison exposure for the research. */
export type FHIREffectEvidenceSynthesisexposureAlternative_exposureAlternative_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
export type FHIREffectEvidenceSynthesisoutcome_outcome_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resource that defines the population for the research. */
export type FHIREffectEvidenceSynthesispopulation_population_Union = FHIREvidenceVariable;

export type FHIREffectEvidenceSynthesisresultsByExposure = {
   __typename?: 'FHIREffectEvidenceSynthesisresultsByExposure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable summary of results by exposure state. */
  description?: Maybe<Scalars['String']>,
  /** Whether these results are for the exposure state or alternative exposure state. */
  exposureState?: Maybe<Scalars['FHIRCode']>,
  /** Used to define variant exposure states such as low-risk state. */
  variantState?: Maybe<FHIRCodeableConcept>,
  /** Reference to a RiskEvidenceSynthesis resource. */
  riskEvidenceSynthesis: FHIREffectEvidenceSynthesisresultsByExposureriskEvidenceSynthesis_riskEvidenceSynthesis_Union,
};

/** Reference to a RiskEvidenceSynthesis resource. */
export type FHIREffectEvidenceSynthesisresultsByExposureriskEvidenceSynthesis_riskEvidenceSynthesis_Union = FHIRRiskEvidenceSynthesis;

export type FHIREffectEvidenceSynthesissampleSize = {
   __typename?: 'FHIREffectEvidenceSynthesissampleSize',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable summary of sample size. */
  description?: Maybe<Scalars['String']>,
  /** Number of studies included in this evidence synthesis. */
  numberOfStudies?: Maybe<Scalars['Int']>,
  /** Number of participants included in this evidence synthesis. */
  numberOfParticipants?: Maybe<Scalars['Int']>,
};

/** Base StructureDefinition for Element Type: Base definition for all elements in a resource. */
export type FHIRElement = {
   __typename?: 'FHIRElement',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

/** Base StructureDefinition for Element Type: Base definition for all elements in a resource. */
export type FHIRElement_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
};

/** 
 * Base StructureDefinition for ElementDefinition Type: Captures constraints on
 * each element within the resource, profile, or extension.
 */
export type FHIRElementDefinition = {
   __typename?: 'FHIRElementDefinition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The path identifies the element and is expressed as a '.'-separated list of
   * ancestor elements, beginning with the name of the resource or extension.
 */
  path: Scalars['String'],
  /** Codes that define how this element is represented in instances, when the deviation varies from the normal case. */
  representation?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * The name of this element definition slice, when slicing is working. The name
   * must be a token with no dots or spaces. This is a unique name referring to a
   * specific set of constraints applied to this element, used to provide a name to
   * different slices of the same element.
 */
  sliceName?: Maybe<Scalars['String']>,
  /** 
 * If true, indicates that this slice definition is constraining a slice
   * definition with the same name in an inherited profile. If false, the slice is
   * not overriding any slice in an inherited profile. If missing, the slice might
   * or might not be overriding a slice in an inherited profile, depending on the sliceName.
 */
  sliceIsConstraining?: Maybe<Scalars['Boolean']>,
  /** 
 * A single preferred label which is the text to display beside the element
   * indicating its meaning or to use to prompt for the element in a user display or form.
 */
  label?: Maybe<Scalars['String']>,
  /** A code that has the same meaning as the element in a particular terminology. */
  code?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * Indicates that the element is sliced into a set of alternative definitions
   * (i.e. in a structure definition, there are multiple different constraints on a
   * single element in the base resource). Slicing can be used in any resource that
   * has cardinality ..* on the base resource, or any resource with a choice of
   * types. The set of slices is any elements that come after this in the element
   * sequence that have the same path, until a shorter path occurs (the shorter
   * path terminates the set).
 */
  slicing?: Maybe<FHIRElement>,
  /** A concise description of what this element means (e.g. for use in autogenerated summaries). */
  short?: Maybe<Scalars['String']>,
  /** 
 * Provides a complete explanation of the meaning of the data element for human
   * readability.  For the case of elements derived from existing elements (e.g.
   * constraints), the definition SHALL be consistent with the base definition, but
   * convey the meaning of the element in the particular context of use of the
   * resource. (Note: The text you are reading is specified in
   * ElementDefinition.definition).
 */
  definition?: Maybe<Scalars['String']>,
  /** 
 * Explanatory notes and implementation guidance about the data element,
   * including notes about how to use the data properly, exceptions to proper use,
   * etc. (Note: The text you are reading is specified in
   * ElementDefinition.comment).
 */
  comment?: Maybe<Scalars['String']>,
  /** 
 * This element is for traceability of why the element was created and why the
   * constraints exist as they do. This may be used to point to source materials or
   * specifications that drove the structure of this element.
 */
  requirements?: Maybe<Scalars['String']>,
  /** Identifies additional names by which this element might also be known. */
  alias?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The minimum number of times this element SHALL appear in the instance. */
  min?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The maximum number of times this element is permitted to appear in the instance. */
  max?: Maybe<Scalars['String']>,
  /** 
 * Information about the base definition of the element, provided to make it
   * unnecessary for tools to trace the deviation of the element through the
   * derived and related profiles. When the element definition is not the original
   * definition of an element - i.g. either in a constraint on another type, or for
   * elements from a super type in a snap shot - then the information in provided
   * in the element definition may be different to the base definition. On the
   * original definition of the element, it will be same.
 */
  base?: Maybe<FHIRElement>,
  /** 
 * Identifies an element defined elsewhere in the definition whose content rules
   * should be applied to the current element. ContentReferences bring across all
   * the rules that are in the ElementDefinition for the element, including
   * definitions, cardinality constraints, bindings, invariants etc.
 */
  contentReference?: Maybe<Scalars['FHIRUri']>,
  /** The data type or resource that the value of this element is permitted to be. */
  type?: Maybe<Array<Maybe<FHIRElement>>>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueCode?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDecimal?: Maybe<Scalars['Float']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueId?: Maybe<Scalars['FHIRId']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueInteger?: Maybe<Scalars['Int']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueMarkdown?: Maybe<Scalars['String']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueOid?: Maybe<Scalars['FHIROid']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueString?: Maybe<Scalars['String']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueUrl?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueUuid?: Maybe<Scalars['FHIRUuid']>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueAddress?: Maybe<FHIRAddress>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueAge?: Maybe<FHIRAge>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueAnnotation?: Maybe<FHIRAnnotation>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueAttachment?: Maybe<FHIRAttachment>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueCoding?: Maybe<FHIRCoding>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueContactPoint?: Maybe<FHIRContactPoint>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueCount?: Maybe<FHIRCount>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDistance?: Maybe<FHIRDistance>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDuration?: Maybe<FHIRDuration>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueHumanName?: Maybe<FHIRHumanName>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueIdentifier?: Maybe<FHIRIdentifier>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueMoney?: Maybe<FHIRMoney>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValuePeriod?: Maybe<FHIRPeriod>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueRange?: Maybe<FHIRRange>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueRatio?: Maybe<FHIRRatio>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueReference?: Maybe<FHIRResourceList>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueSampledData?: Maybe<FHIRSampledData>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueSignature?: Maybe<FHIRSignature>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueTiming?: Maybe<FHIRTiming>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueContactDetail?: Maybe<FHIRContactDetail>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueContributor?: Maybe<FHIRContributor>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDataRequirement?: Maybe<FHIRDataRequirement>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueExpression?: Maybe<FHIRExpression>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueUsageContext?: Maybe<FHIRUsageContext>,
  /** 
 * The value that should be used if there is no value stated in the instance
   * (e.g. 'if not otherwise specified, the abstract is false').
 */
  defaultValueDosage?: Maybe<FHIRDosage>,
  /** 
 * The Implicit meaning that is to be understood when this element is missing
   * (e.g. 'when this element is missing, the period is ongoing').
 */
  meaningWhenMissing?: Maybe<Scalars['String']>,
  /** 
 * If present, indicates that the order of the repeating element has meaning and
   * describes what that meaning is.  If absent, it means that the order of the
   * element has no meaning.
 */
  orderMeaning?: Maybe<Scalars['String']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedCode?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDecimal?: Maybe<Scalars['Float']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedId?: Maybe<Scalars['FHIRId']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedInteger?: Maybe<Scalars['Int']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedMarkdown?: Maybe<Scalars['String']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedOid?: Maybe<Scalars['FHIROid']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedString?: Maybe<Scalars['String']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedUrl?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedUuid?: Maybe<Scalars['FHIRUuid']>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedAddress?: Maybe<FHIRAddress>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedAge?: Maybe<FHIRAge>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedAnnotation?: Maybe<FHIRAnnotation>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedCoding?: Maybe<FHIRCoding>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedContactPoint?: Maybe<FHIRContactPoint>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedCount?: Maybe<FHIRCount>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDistance?: Maybe<FHIRDistance>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDuration?: Maybe<FHIRDuration>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedHumanName?: Maybe<FHIRHumanName>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedIdentifier?: Maybe<FHIRIdentifier>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedMoney?: Maybe<FHIRMoney>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedRange?: Maybe<FHIRRange>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedRatio?: Maybe<FHIRRatio>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedReference?: Maybe<FHIRResourceList>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedSampledData?: Maybe<FHIRSampledData>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedSignature?: Maybe<FHIRSignature>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedTiming?: Maybe<FHIRTiming>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedContactDetail?: Maybe<FHIRContactDetail>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedContributor?: Maybe<FHIRContributor>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDataRequirement?: Maybe<FHIRDataRequirement>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedExpression?: Maybe<FHIRExpression>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedUsageContext?: Maybe<FHIRUsageContext>,
  /** 
 * Specifies a value that SHALL be exactly the value  for this element in the
   * instance. For purposes of comparison, non-significant whitespace is ignored,
   * and all values must be an exact match (case and accent sensitive). Missing
   * elements/attributes must also be missing.
 */
  fixedDosage?: Maybe<FHIRDosage>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternCode?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDecimal?: Maybe<Scalars['Float']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternId?: Maybe<Scalars['FHIRId']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternInteger?: Maybe<Scalars['Int']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternMarkdown?: Maybe<Scalars['String']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternOid?: Maybe<Scalars['FHIROid']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternString?: Maybe<Scalars['String']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternUrl?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternUuid?: Maybe<Scalars['FHIRUuid']>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternAddress?: Maybe<FHIRAddress>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternAge?: Maybe<FHIRAge>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternAnnotation?: Maybe<FHIRAnnotation>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternCoding?: Maybe<FHIRCoding>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternContactPoint?: Maybe<FHIRContactPoint>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternCount?: Maybe<FHIRCount>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDistance?: Maybe<FHIRDistance>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDuration?: Maybe<FHIRDuration>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternHumanName?: Maybe<FHIRHumanName>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternIdentifier?: Maybe<FHIRIdentifier>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternMoney?: Maybe<FHIRMoney>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternRange?: Maybe<FHIRRange>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternRatio?: Maybe<FHIRRatio>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternReference?: Maybe<FHIRResourceList>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternSampledData?: Maybe<FHIRSampledData>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternSignature?: Maybe<FHIRSignature>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternTiming?: Maybe<FHIRTiming>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternContactDetail?: Maybe<FHIRContactDetail>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternContributor?: Maybe<FHIRContributor>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDataRequirement?: Maybe<FHIRDataRequirement>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternExpression?: Maybe<FHIRExpression>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternUsageContext?: Maybe<FHIRUsageContext>,
  /** 
 * Specifies a value that the value in the instance SHALL follow - that is, any
   * value in the pattern must be found in the instance. Other additional values
   * may be found too. This is effectively constraint by example.    When
   * pattern[x] is used to constrain a primitive, it means that the value provided
   * in the pattern[x] must match the instance value exactly.  When pattern[x] is
   * used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the
   * instance array.  When pattern[x] is used to constrain a complex object, it
   * means that each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,  1. If primitive: it must match
   * exactly the pattern value 2. If a complex object: it must match (recursively)
   * the pattern value 3. If an array: it must match (recursively) the pattern value.
 */
  patternDosage?: Maybe<FHIRDosage>,
  /** A sample value for this element demonstrating the type of information that would typically be found in the element. */
  example?: Maybe<Array<Maybe<FHIRElement>>>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueDecimal?: Maybe<Scalars['Float']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueInteger?: Maybe<Scalars['Int']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * The minimum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  minValueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueDecimal?: Maybe<Scalars['Float']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueInteger?: Maybe<Scalars['Int']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * The maximum allowed value for the element. The value is inclusive. This is
   * allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
 */
  maxValueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Indicates the maximum length in characters that is permitted to be present in
   * conformant instances and which is expected to be supported by conformant
   * consumers that support the element.
 */
  maxLength?: Maybe<Scalars['Int']>,
  /** A reference to an invariant that may make additional statements about the cardinality or value in the instance. */
  condition?: Maybe<Array<Maybe<Scalars['FHIRId']>>>,
  /** 
 * Formal constraints such as co-occurrence and other constraints that can be
   * computationally evaluated within the context of the instance.
 */
  constraint?: Maybe<Array<Maybe<FHIRElement>>>,
  /** 
 * If true, implementations that produce or consume resources SHALL provide
   * 'support' for the element in some meaningful way.  If false, the element may
   * be ignored and not supported. If false, whether to populate or use the data
   * element in any way is at the discretion of the implementation.
 */
  mustSupport?: Maybe<Scalars['Boolean']>,
  /** 
 * If true, the value of this element affects the interpretation of the element
   * or resource that contains it, and the value of the element cannot be ignored.
   * Typically, this is used for status, negation and qualification codes. The
   * effect of this is that the element cannot be ignored by systems: they SHALL
   * either recognize the element and process it, and/or a pre-determination has
   * been made that it is not relevant to their particular system.
 */
  isModifier?: Maybe<Scalars['Boolean']>,
  /** Explains how that element affects the interpretation of the resource or element that contains it. */
  isModifierReason?: Maybe<Scalars['String']>,
  /** Whether the element should be included if a client requests a search with the parameter _summary=true. */
  isSummary?: Maybe<Scalars['Boolean']>,
  /** Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri). */
  binding?: Maybe<FHIRElement>,
  /** Identifies a concept from an external specification that roughly corresponds to this element. */
  mapping?: Maybe<Array<Maybe<FHIRElement>>>,
};

/** 
 * An interaction between a patient and healthcare provider(s) for the purpose of
 * providing healthcare service(s) or assessing the health status of a patient.
 */
export type FHIREncounter = {
   __typename?: 'FHIREncounter',
  /** Type of resource */
  resourceType: FHIREncounter_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier(s) by which this encounter is known. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** planned | arrived | triaged | in-progress | onleave | finished | cancelled +. */
  status: Scalars['FHIRCode'],
  /** 
 * The status history permits the encounter resource to contain the status
   * history without needing to read through the historical versions of the
   * resource, or even have the server store them.
 */
  statusHistory?: Maybe<Array<Maybe<FHIREncounterstatusHistory>>>,
  /** 
 * Concepts representing classification of patient encounter such as ambulatory
   * (outpatient), inpatient, emergency, home health or others due to local variations.
 */
  class: FHIRCoding,
  /** 
 * The class history permits the tracking of the encounters transitions without
   * needing to go  through the resource history.  This would be used for a case
   * where an admission starts of as an emergency encounter, then transitions into
   * an inpatient scenario. Doing this and not restarting a new encounter ensures
   * that any lab/diagnostic results can more easily follow the patient and not
   * require re-processing and not get lost or cancelled during a kind of discharge
   * from emergency to inpatient.
 */
  classHistory?: Maybe<Array<Maybe<FHIREncounterclassHistory>>>,
  /** Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation). */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Broad categorization of the service that is to be provided (e.g. cardiology). */
  serviceType?: Maybe<FHIRCodeableConcept>,
  /** Indicates the urgency of the encounter. */
  priority?: Maybe<FHIRCodeableConcept>,
  /** The patient or group present at the encounter. */
  subject?: Maybe<FHIREncountersubject_subject_Union>,
  /** 
 * Where a specific encounter should be classified as a part of a specific
   * episode(s) of care this field should be used. This association can facilitate
   * grouping of related encounters together for a specific purpose, such as
   * government reporting, issue tracking, association via a common problem.  The
   * association is recorded on the encounter as these are typically created after
   * the episode of care and grouped on entry rather than editing the episode of
   * care to append another encounter to it (the episode of care could span years).
 */
  episodeOfCare?: Maybe<Array<Maybe<FHIREncounterepisodeOfCare_episodeOfCare_Union>>>,
  /** The request this encounter satisfies (e.g. incoming referral or procedure request). */
  basedOn?: Maybe<Array<Maybe<FHIREncounterbasedOn_basedOn_Union>>>,
  /** The list of people responsible for providing the service. */
  participant?: Maybe<Array<Maybe<FHIREncounterparticipant>>>,
  /** The appointment that scheduled this encounter. */
  appointment?: Maybe<Array<Maybe<FHIREncounterappointment_appointment_Union>>>,
  /** The start and end time of the encounter. */
  period?: Maybe<FHIRPeriod>,
  /** Quantity of time the encounter lasted. This excludes the time during leaves of absence. */
  length?: Maybe<FHIRDuration>,
  /** Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis. */
  reasonReference?: Maybe<Array<Maybe<FHIREncounterreasonReference_reasonReference_Union>>>,
  /** The list of diagnosis relevant to this encounter. */
  diagnosis?: Maybe<Array<Maybe<FHIREncounterdiagnosis>>>,
  /** The set of accounts that may be used for billing for this Encounter. */
  account?: Maybe<Array<Maybe<FHIREncounteraccount_account_Union>>>,
  /** Details about the admission to a healthcare service. */
  hospitalization?: Maybe<FHIREncounterhospitalization>,
  /** List of locations where  the patient has been during this encounter. */
  location?: Maybe<Array<Maybe<FHIREncounterlocation>>>,
  /** 
 * The organization that is primarily responsible for this Encounter's services.
   * This MAY be the same as the organization on the Patient record, however it
   * could be different, such as if the actor performing the services was from an
   * external organization (which may be billed seperately) for an external
   * consultation.  Refer to the example bundle showing an abbreviated set of
   * Encounters for a colonoscopy.
 */
  serviceProvider?: Maybe<FHIREncounterserviceProvider_serviceProvider_Union>,
  /** Another Encounter of which this encounter is a part of (administratively or in time). */
  partOf?: Maybe<FHIREncounterpartOf_partOf_Union>,
};

export enum FHIREncounter_Enum_schema {
  Encounter = 'Encounter'
}

/** The set of accounts that may be used for billing for this Encounter. */
export type FHIREncounteraccount_account_Union = FHIRAccount;

/** The appointment that scheduled this encounter. */
export type FHIREncounterappointment_appointment_Union = FHIRAppointment;

/** The request this encounter satisfies (e.g. incoming referral or procedure request). */
export type FHIREncounterbasedOn_basedOn_Union = FHIRServiceRequest;

export type FHIREncounterclassHistory = {
   __typename?: 'FHIREncounterclassHistory',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** inpatient | outpatient | ambulatory | emergency +. */
  class: FHIRCoding,
  /** The time that the episode was in the specified class. */
  period: FHIRPeriod,
};

export type FHIREncounterdiagnosis = {
   __typename?: 'FHIREncounterdiagnosis',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Reason the encounter takes place, as specified using information from another
   * resource. For admissions, this is the admission diagnosis. The indication will
   * typically be a Condition (with other resources referenced in the
   * evidence.detail), or a Procedure.
 */
  condition: FHIREncounterdiagnosiscondition_condition_Union,
  /** Role that this diagnosis has within the encounter (e.g. admission, billing, discharge …). */
  use?: Maybe<FHIRCodeableConcept>,
  /** Ranking of the diagnosis (for each role type). */
  rank?: Maybe<Scalars['FHIRPositiveInt']>,
};

/** 
 * Reason the encounter takes place, as specified using information from another
 * resource. For admissions, this is the admission diagnosis. The indication will
 * typically be a Condition (with other resources referenced in the
 * evidence.detail), or a Procedure.
 */
export type FHIREncounterdiagnosiscondition_condition_Union = FHIRCondition | FHIRProcedure;

/** 
 * Where a specific encounter should be classified as a part of a specific
 * episode(s) of care this field should be used. This association can facilitate
 * grouping of related encounters together for a specific purpose, such as
 * government reporting, issue tracking, association via a common problem.  The
 * association is recorded on the encounter as these are typically created after
 * the episode of care and grouped on entry rather than editing the episode of care
 * to append another encounter to it (the episode of care could span years).
 */
export type FHIREncounterepisodeOfCare_episodeOfCare_Union = FHIREpisodeOfCare;

export type FHIREncounterhospitalization = {
   __typename?: 'FHIREncounterhospitalization',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Pre-admission identifier. */
  preAdmissionIdentifier?: Maybe<FHIRIdentifier>,
  /** The location/organization from which the patient came before admission. */
  origin?: Maybe<FHIREncounterhospitalizationorigin_origin_Union>,
  /** From where patient was admitted (physician referral, transfer). */
  admitSource?: Maybe<FHIRCodeableConcept>,
  /** Whether this hospitalization is a readmission and why if known. */
  reAdmission?: Maybe<FHIRCodeableConcept>,
  /** Diet preferences reported by the patient. */
  dietPreference?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Special courtesies (VIP, board member). */
  specialCourtesy?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Any special requests that have been made for this hospitalization encounter,
   * such as the provision of specific equipment or other things.
 */
  specialArrangement?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Location/organization to which the patient is discharged. */
  destination?: Maybe<FHIREncounterhospitalizationdestination_destination_Union>,
  /** Category or kind of location after discharge. */
  dischargeDisposition?: Maybe<FHIRCodeableConcept>,
};

/** Location/organization to which the patient is discharged. */
export type FHIREncounterhospitalizationdestination_destination_Union = FHIRLocation | FHIROrganization;

/** The location/organization from which the patient came before admission. */
export type FHIREncounterhospitalizationorigin_origin_Union = FHIRLocation | FHIROrganization;

export type FHIREncounterlocation = {
   __typename?: 'FHIREncounterlocation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The location where the encounter takes place. */
  location: FHIREncounterlocationlocation_location_Union,
  /** 
 * The status of the participants' presence at the specified location during the
   * period specified. If the participant is no longer at the location, then the
   * period will have an end date/time.
 */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * This will be used to specify the required levels (bed/ward/room/etc.) desired
   * to be recorded to simplify either messaging or query.
 */
  physicalType?: Maybe<FHIRCodeableConcept>,
  /** Time period during which the patient was present at the location. */
  period?: Maybe<FHIRPeriod>,
};

/** The location where the encounter takes place. */
export type FHIREncounterlocationlocation_location_Union = FHIRLocation;

export type FHIREncounterparticipant = {
   __typename?: 'FHIREncounterparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Role of participant in encounter. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The period of time that the specified participant participated in the
   * encounter. These can overlap or be sub-sets of the overall encounter's period.
 */
  period?: Maybe<FHIRPeriod>,
  /** Persons involved in the encounter other than the patient. */
  individual?: Maybe<FHIREncounterparticipantindividual_individual_Union>,
};

/** Persons involved in the encounter other than the patient. */
export type FHIREncounterparticipantindividual_individual_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** Another Encounter of which this encounter is a part of (administratively or in time). */
export type FHIREncounterpartOf_partOf_Union = FHIREncounter;

/** Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis. */
export type FHIREncounterreasonReference_reasonReference_Union = FHIRCondition | FHIRProcedure | FHIRObservation | FHIRImmunizationRecommendation;

/** 
 * The organization that is primarily responsible for this Encounter's services.
 * This MAY be the same as the organization on the Patient record, however it could
 * be different, such as if the actor performing the services was from an external
 * organization (which may be billed seperately) for an external consultation. 
 * Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
 */
export type FHIREncounterserviceProvider_serviceProvider_Union = FHIROrganization;

export type FHIREncounterstatusHistory = {
   __typename?: 'FHIREncounterstatusHistory',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** planned | arrived | triaged | in-progress | onleave | finished | cancelled +. */
  status: Scalars['FHIRCode'],
  /** The time that the episode was in the specified status. */
  period: FHIRPeriod,
};

/** The patient or group present at the encounter. */
export type FHIREncountersubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * The technical details of an endpoint that can be used for electronic services,
 * such as for web services providing XDS.b or a REST endpoint for another FHIR
 * server. This may include any security context information.
 */
export type FHIREndpoint = {
   __typename?: 'FHIREndpoint',
  /** Type of resource */
  resourceType: FHIREndpoint_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the organization that is used to identify the endpoint across multiple disparate systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** active | suspended | error | off | test. */
  status: Scalars['FHIRCode'],
  /** 
 * A coded value that represents the technical details of the usage of this
   * endpoint, such as what WSDLs should be used in what way. (e.g.
   * XDS.b/DICOM/cds-hook).
 */
  connectionType: FHIRCoding,
  /** A friendly name that this endpoint can be referred to with. */
  name?: Maybe<Scalars['String']>,
  /** 
 * The organization that manages this endpoint (even if technically another
   * organization is hosting this in the cloud, it is the organization associated
   * with the data).
 */
  managingOrganization?: Maybe<FHIREndpointmanagingOrganization_managingOrganization_Union>,
  /** 
 * Contact details for a human to contact about the subscription. The primary use
   * of this for system administrator troubleshooting.
 */
  contact?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** The interval during which the endpoint is expected to be operational. */
  period?: Maybe<FHIRPeriod>,
  /** The payload type describes the acceptable content that can be communicated on the endpoint. */
  payloadType?: Maybe<Array<FHIRCodeableConcept>>,
  /** 
 * The mime type to send the payload in - e.g. application/fhir+xml,
   * application/fhir+json. If the mime type is not specified, then the sender
   * could send any content (including no content depending on the connectionType).
 */
  payloadMimeType?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** The uri that describes the actual end-point to connect to. */
  address: Scalars['FHIRUrl'],
  /** Additional headers / information to send as part of the notification. */
  header?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export enum FHIREndpoint_Enum_schema {
  Endpoint = 'Endpoint'
}

/** 
 * The organization that manages this endpoint (even if technically another
 * organization is hosting this in the cloud, it is the organization associated
 * with the data).
 */
export type FHIREndpointmanagingOrganization_managingOrganization_Union = FHIROrganization;

/** This resource provides the insurance enrollment details to the insurer regarding a specified coverage. */
export type FHIREnrollmentRequest = {
   __typename?: 'FHIREnrollmentRequest',
  /** Type of resource */
  resourceType: FHIREnrollmentRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The Response business identifier. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** The date when this resource was created. */
  created?: Maybe<Scalars['FHIRDateTime']>,
  /** The Insurer who is target  of the request. */
  insurer?: Maybe<FHIREnrollmentRequestinsurer_insurer_Union>,
  /** The practitioner who is responsible for the services rendered to the patient. */
  provider?: Maybe<FHIREnrollmentRequestprovider_provider_Union>,
  /** Patient Resource. */
  candidate?: Maybe<FHIREnrollmentRequestcandidate_candidate_Union>,
  /** Reference to the program or plan identification, underwriter or payor. */
  coverage?: Maybe<FHIREnrollmentRequestcoverage_coverage_Union>,
};

export enum FHIREnrollmentRequest_Enum_schema {
  EnrollmentRequest = 'EnrollmentRequest'
}

/** Patient Resource. */
export type FHIREnrollmentRequestcandidate_candidate_Union = FHIRPatient;

/** Reference to the program or plan identification, underwriter or payor. */
export type FHIREnrollmentRequestcoverage_coverage_Union = FHIRCoverage;

/** The Insurer who is target  of the request. */
export type FHIREnrollmentRequestinsurer_insurer_Union = FHIROrganization;

/** The practitioner who is responsible for the services rendered to the patient. */
export type FHIREnrollmentRequestprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource. */
export type FHIREnrollmentResponse = {
   __typename?: 'FHIREnrollmentResponse',
  /** Type of resource */
  resourceType: FHIREnrollmentResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The Response business identifier. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** Original request resource reference. */
  request?: Maybe<FHIREnrollmentResponserequest_request_Union>,
  /** Processing status: error, complete. */
  outcome?: Maybe<Scalars['FHIRCode']>,
  /** A description of the status of the adjudication. */
  disposition?: Maybe<Scalars['String']>,
  /** The date when the enclosed suite of services were performed or completed. */
  created?: Maybe<Scalars['FHIRDateTime']>,
  /** The Insurer who produced this adjudicated response. */
  organization?: Maybe<FHIREnrollmentResponseorganization_organization_Union>,
  /** The practitioner who is responsible for the services rendered to the patient. */
  requestProvider?: Maybe<FHIREnrollmentResponserequestProvider_requestProvider_Union>,
};

export enum FHIREnrollmentResponse_Enum_schema {
  EnrollmentResponse = 'EnrollmentResponse'
}

/** The Insurer who produced this adjudicated response. */
export type FHIREnrollmentResponseorganization_organization_Union = FHIROrganization;

/** Original request resource reference. */
export type FHIREnrollmentResponserequest_request_Union = FHIREnrollmentRequest;

/** The practitioner who is responsible for the services rendered to the patient. */
export type FHIREnrollmentResponserequestProvider_requestProvider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** 
 * An association between a patient and an organization / healthcare provider(s)
 * during which time encounters may occur. The managing organization assumes a
 * level of responsibility for the patient during this time.
 */
export type FHIREpisodeOfCare = {
   __typename?: 'FHIREpisodeOfCare',
  /** Type of resource */
  resourceType: FHIREpisodeOfCare_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The EpisodeOfCare may be known by different identifiers for different contexts
   * of use, such as when an external agency is tracking the Episode for funding purposes.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** planned | waitlist | active | onhold | finished | cancelled. */
  status: Scalars['FHIRCode'],
  /** 
 * The history of statuses that the EpisodeOfCare has been through (without
   * requiring processing the history of the resource).
 */
  statusHistory?: Maybe<Array<Maybe<FHIREpisodeOfCarestatusHistory>>>,
  /** A classification of the type of episode of care; e.g. specialist referral, disease management, type of funded care. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The list of diagnosis relevant to this episode of care. */
  diagnosis?: Maybe<Array<Maybe<FHIREpisodeOfCarediagnosis>>>,
  /** The patient who is the focus of this episode of care. */
  patient: FHIREpisodeOfCarepatient_patient_Union,
  /** The organization that has assumed the specific responsibilities for the specified duration. */
  managingOrganization?: Maybe<FHIREpisodeOfCaremanagingOrganization_managingOrganization_Union>,
  /** The interval during which the managing organization assumes the defined responsibility. */
  period?: Maybe<FHIRPeriod>,
  /** Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming referrals. */
  referralRequest?: Maybe<Array<Maybe<FHIREpisodeOfCarereferralRequest_referralRequest_Union>>>,
  /** The practitioner that is the care manager/care coordinator for this patient. */
  careManager?: Maybe<FHIREpisodeOfCarecareManager_careManager_Union>,
  /** The list of practitioners that may be facilitating this episode of care for specific purposes. */
  team?: Maybe<Array<Maybe<FHIREpisodeOfCareteam_team_Union>>>,
  /** The set of accounts that may be used for billing for this EpisodeOfCare. */
  account?: Maybe<Array<Maybe<FHIREpisodeOfCareaccount_account_Union>>>,
};

export enum FHIREpisodeOfCare_Enum_schema {
  EpisodeOfCare = 'EpisodeOfCare'
}

/** The set of accounts that may be used for billing for this EpisodeOfCare. */
export type FHIREpisodeOfCareaccount_account_Union = FHIRAccount;

/** The practitioner that is the care manager/care coordinator for this patient. */
export type FHIREpisodeOfCarecareManager_careManager_Union = FHIRPractitioner | FHIRPractitionerRole;

export type FHIREpisodeOfCarediagnosis = {
   __typename?: 'FHIREpisodeOfCarediagnosis',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for. */
  condition: FHIREpisodeOfCarediagnosiscondition_condition_Union,
  /** Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge …). */
  role?: Maybe<FHIRCodeableConcept>,
  /** Ranking of the diagnosis (for each role type). */
  rank?: Maybe<Scalars['FHIRPositiveInt']>,
};

/** A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for. */
export type FHIREpisodeOfCarediagnosiscondition_condition_Union = FHIRCondition;

/** The organization that has assumed the specific responsibilities for the specified duration. */
export type FHIREpisodeOfCaremanagingOrganization_managingOrganization_Union = FHIROrganization;

/** The patient who is the focus of this episode of care. */
export type FHIREpisodeOfCarepatient_patient_Union = FHIRPatient;

/** Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming referrals. */
export type FHIREpisodeOfCarereferralRequest_referralRequest_Union = FHIRServiceRequest;

export type FHIREpisodeOfCarestatusHistory = {
   __typename?: 'FHIREpisodeOfCarestatusHistory',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** planned | waitlist | active | onhold | finished | cancelled. */
  status: Scalars['FHIRCode'],
  /** The period during this EpisodeOfCare that the specific status applied. */
  period: FHIRPeriod,
};

/** The list of practitioners that may be facilitating this episode of care for specific purposes. */
export type FHIREpisodeOfCareteam_team_Union = FHIRCareTeam;

/** The EventDefinition resource provides a reusable description of when a particular event can occur. */
export type FHIREventDefinition = {
   __typename?: 'FHIREventDefinition',
  /** Type of resource */
  resourceType: FHIREventDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this event definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this event definition
   * is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the event definition is stored on
   * different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this event definition when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the event definition
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the event definition author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the event definition. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the event definition. */
  title?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the event definition giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this event definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this event definition is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** A code or group definition that describes the intended subject of the event definition. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A code or group definition that describes the intended subject of the event definition. */
  subjectReference?: Maybe<FHIREventDefinitionsubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the event definition was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the event definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the event definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the event definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate event
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the event definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this event definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description of how the event definition is used from a clinical perspective. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the event definition and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the event definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the event definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the module. Topics provide a high-level
   * categorization of the module that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related resources such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** 
 * The trigger element defines when the event occurs. If more than one trigger
   * condition is specified, the event fires whenever any one of the trigger
   * conditions is met.
 */
  trigger?: Maybe<Array<FHIRTriggerDefinition>>,
};

export enum FHIREventDefinition_Enum_schema {
  EventDefinition = 'EventDefinition'
}

/** A code or group definition that describes the intended subject of the event definition. */
export type FHIREventDefinitionsubjectReference_subjectReference_Union = FHIRGroup;

/** 
 * The Evidence resource describes the conditional state (population and any
 * exposures being compared within the population) and outcome (if specified) that
 * the knowledge (evidence, assertion, recommendation) is about.
 */
export type FHIREvidence = {
   __typename?: 'FHIREvidence',
  /** Type of resource */
  resourceType: FHIREvidence_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this evidence when it is referenced
   * in a specification, model, design or an instance; also called its canonical
   * identifier. This SHOULD be globally unique and SHOULD be a literal address at
   * which at which an authoritative instance of this evidence is (or will be)
   * published. This URL can be the target of a canonical reference. It SHALL
   * remain the same when the evidence is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this evidence when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the evidence when it
   * is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the evidence author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence. To provide a version consistent
   * with the Decision Support Service specification, use the format
   * Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
   * knowledge assets, refer to the Decision Support Service specification. Note
   * that a version is required for non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the evidence. This name should be usable
   * as an identifier for the module by machine processing applications such as
   * code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the evidence. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The short title provides an alternate title for use in informal descriptive
   * contexts where the full, formal title is not necessary.
 */
  shortTitle?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the Evidence giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this evidence. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * The date  (and optionally time) when the evidence was published. The date must
   * change when the business version changes and it must change if the status code
   * changes. In addition, it should change when the substantive content of the
   * evidence changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the evidence. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the evidence from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate evidence instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the evidence is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the evidence and/or its contents. Copyright
   * statements are generally legal restrictions on the use and publishing of the evidence.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the evidence content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the Evidence. Topics provide a
   * high-level categorization grouping types of Evidences that can be useful for
   * filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a EvidenceVariable resource that defines the population for the research. */
  exposureBackground: FHIREvidenceexposureBackground_exposureBackground_Union,
  /** A reference to a EvidenceVariable resource that defines the exposure for the research. */
  exposureVariant?: Maybe<Array<Maybe<FHIREvidenceexposureVariant_exposureVariant_Union>>>,
  /** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
  outcome?: Maybe<Array<Maybe<FHIREvidenceoutcome_outcome_Union>>>,
};

export enum FHIREvidence_Enum_schema {
  Evidence = 'Evidence'
}

/** A reference to a EvidenceVariable resource that defines the population for the research. */
export type FHIREvidenceexposureBackground_exposureBackground_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resource that defines the exposure for the research. */
export type FHIREvidenceexposureVariant_exposureVariant_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
export type FHIREvidenceoutcome_outcome_Union = FHIREvidenceVariable;

/** The EvidenceVariable resource describes a 'PICO' element that knowledge (evidence, assertion, recommendation) is about. */
export type FHIREvidenceVariable = {
   __typename?: 'FHIREvidenceVariable',
  /** Type of resource */
  resourceType: FHIREvidenceVariable_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this evidence variable when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this evidence variable
   * is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the evidence variable is stored on
   * different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this evidence variable when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the evidence variable
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the evidence variable author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence. To provide a version consistent
   * with the Decision Support Service specification, use the format
   * Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
   * knowledge assets, refer to the Decision Support Service specification. Note
   * that a version is required for non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the evidence variable. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the evidence variable. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The short title provides an alternate title for use in informal descriptive
   * contexts where the full, formal title is not necessary.
 */
  shortTitle?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the EvidenceVariable giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this evidence variable. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * The date  (and optionally time) when the evidence variable was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the evidence variable changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the evidence variable. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the evidence variable from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate evidence
   * variable instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the evidence variable is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the evidence variable and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the evidence variable.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the evidence variable content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the EvidenceVariable. Topics
   * provide a high-level categorization grouping types of EvidenceVariables that
   * can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** The type of evidence element, a population, an exposure, or an outcome. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A characteristic that defines the members of the evidence element. Multiple
   * characteristics are applied with 'and' semantics.
 */
  characteristic?: Maybe<Array<FHIREvidenceVariablecharacteristic>>,
};

export enum FHIREvidenceVariable_Enum_schema {
  EvidenceVariable = 'EvidenceVariable'
}

export type FHIREvidenceVariablecharacteristic = {
   __typename?: 'FHIREvidenceVariablecharacteristic',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user. */
  description?: Maybe<Scalars['String']>,
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionReference: FHIREvidenceVariablecharacteristicdefinitionReference_definitionReference_Union,
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionCanonical: Scalars['FHIRCanonical'],
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionCodeableConcept: FHIRCodeableConcept,
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionExpression: FHIRExpression,
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionDataRequirement: FHIRDataRequirement,
  /** 
 * Define members of the evidence element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionTriggerDefinition: FHIRTriggerDefinition,
  /** Use UsageContext to define the members of the population, such as Age Ranges, Genders, Settings. */
  usageContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** When true, members with this characteristic are excluded from the element. */
  exclude?: Maybe<Scalars['Boolean']>,
  /** Indicates what effective period the study covers. */
  participantEffectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates what effective period the study covers. */
  participantEffectivePeriod?: Maybe<FHIRPeriod>,
  /** Indicates what effective period the study covers. */
  participantEffectiveDuration?: Maybe<FHIRDuration>,
  /** Indicates what effective period the study covers. */
  participantEffectiveTiming?: Maybe<FHIRTiming>,
  /** Indicates duration from the participant's study entry. */
  timeFromStart?: Maybe<FHIRDuration>,
  /** Indicates how elements are aggregated within the study effective period. */
  groupMeasure?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * Define members of the evidence element using Codes (such as condition,
 * medication, or observation), Expressions ( using an expression language such as
 * FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
 */
export type FHIREvidenceVariablecharacteristicdefinitionReference_definitionReference_Union = FHIRGroup | FHIRActivityDefinition;

/** Example of workflow instance. */
export type FHIRExampleScenario = {
   __typename?: 'FHIRExampleScenario',
  /** Type of resource */
  resourceType: FHIRExampleScenario_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this example scenario when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this example scenario
   * is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the example scenario is stored on
   * different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this example scenario when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the example scenario
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the example scenario author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the example scenario. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** The status of this example scenario. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this example scenario is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the example scenario was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the example scenario changes. (e.g. the 'content logical definition').
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the example scenario. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate example
   * scenario instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the example scenario is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the example scenario and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the example scenario.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * What the example scenario resource is created for. This should not be used to
   * show the business purpose of the scenario itself, but the purpose of
   * documenting a scenario.
 */
  purpose?: Maybe<Scalars['String']>,
  /** Actor participating in the resource. */
  actor?: Maybe<Array<Maybe<FHIRExampleScenarioactor>>>,
  /** Each resource and each version that is present in the workflow. */
  instance?: Maybe<Array<Maybe<FHIRExampleScenarioinstance>>>,
  /** Each major process - a group of operations. */
  process?: Maybe<Array<Maybe<FHIRExampleScenarioprocess>>>,
  /** Another nested workflow. */
  workflow?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
};

export enum FHIRExampleScenario_Enum_schema {
  ExampleScenario = 'ExampleScenario'
}

export type FHIRExampleScenarioactor = {
   __typename?: 'FHIRExampleScenarioactor',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** ID or acronym of actor. */
  actorId: Scalars['String'],
  /** The type of actor - person or system. */
  type: Scalars['FHIRCode'],
  /** The name of the actor as shown in the page. */
  name?: Maybe<Scalars['String']>,
  /** The description of the actor. */
  description?: Maybe<Scalars['String']>,
};

export type FHIRExampleScenarioinstance = {
   __typename?: 'FHIRExampleScenarioinstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The id of the resource for referencing. */
  resourceId: Scalars['String'],
  /** The type of the resource. */
  resourceType: Scalars['FHIRCode'],
  /** A short name for the resource instance. */
  name?: Maybe<Scalars['String']>,
  /** Human-friendly description of the resource instance. */
  description?: Maybe<Scalars['String']>,
  /** A specific version of the resource. */
  version?: Maybe<Array<Maybe<FHIRExampleScenarioinstanceversion>>>,
  /** Resources contained in the instance (e.g. the observations contained in a bundle). */
  containedInstance?: Maybe<Array<Maybe<FHIRExampleScenarioinstancecontainedInstance>>>,
};

export type FHIRExampleScenarioinstancecontainedInstance = {
   __typename?: 'FHIRExampleScenarioinstancecontainedInstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Each resource contained in the instance. */
  resourceId: Scalars['String'],
  /** A specific version of a resource contained in the instance. */
  versionId?: Maybe<Scalars['String']>,
};

export type FHIRExampleScenarioinstanceversion = {
   __typename?: 'FHIRExampleScenarioinstanceversion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The identifier of a specific version of a resource. */
  versionId: Scalars['String'],
  /** The description of the resource version. */
  description: Scalars['String'],
};

export type FHIRExampleScenarioprocess = {
   __typename?: 'FHIRExampleScenarioprocess',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The diagram title of the group of operations. */
  title: Scalars['String'],
  /** A longer description of the group of operations. */
  description?: Maybe<Scalars['String']>,
  /** Description of initial status before the process starts. */
  preConditions?: Maybe<Scalars['String']>,
  /** Description of final status after the process ends. */
  postConditions?: Maybe<Scalars['String']>,
  /** Each step of the process. */
  step?: Maybe<Array<Maybe<FHIRExampleScenarioprocessstep>>>,
};

export type FHIRExampleScenarioprocessstep = {
   __typename?: 'FHIRExampleScenarioprocessstep',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** If there is a pause in the flow. */
  pause?: Maybe<Scalars['Boolean']>,
  /** Each interaction or action. */
  operation?: Maybe<FHIRExampleScenarioprocessstepoperation>,
  /** 
 * Indicates an alternative step that can be taken instead of the operations on
   * the base step in exceptional/atypical circumstances.
 */
  alternative?: Maybe<Array<Maybe<FHIRExampleScenarioprocessstepalternative>>>,
};

export type FHIRExampleScenarioprocessstepalternative = {
   __typename?: 'FHIRExampleScenarioprocessstepalternative',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The label to display for the alternative that gives a sense of the
   * circumstance in which the alternative should be invoked.
 */
  title: Scalars['String'],
  /** A human-readable description of the alternative explaining when the alternative should occur rather than the base step. */
  description?: Maybe<Scalars['String']>,
};

export type FHIRExampleScenarioprocessstepoperation = {
   __typename?: 'FHIRExampleScenarioprocessstepoperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The sequential number of the interaction, e.g. 1.2.5. */
  number: Scalars['String'],
  /** The type of operation - CRUD. */
  type?: Maybe<Scalars['String']>,
  /** The human-friendly name of the interaction. */
  name?: Maybe<Scalars['String']>,
  /** Who starts the transaction. */
  initiator?: Maybe<Scalars['String']>,
  /** Who receives the transaction. */
  receiver?: Maybe<Scalars['String']>,
  /** A comment to be inserted in the diagram. */
  description?: Maybe<Scalars['String']>,
  /** Whether the initiator is deactivated right after the transaction. */
  initiatorActive?: Maybe<Scalars['Boolean']>,
  /** Whether the receiver is deactivated right after the transaction. */
  receiverActive?: Maybe<Scalars['Boolean']>,
};

/** 
 * This resource provides: the claim details; adjudication details from the
 * processing of a Claim; and optionally account balance information, for informing
 * the subscriber of the benefits provided.
 */
export type FHIRExplanationOfBenefit = {
   __typename?: 'FHIRExplanationOfBenefit',
  /** Type of resource */
  resourceType: FHIRExplanationOfBenefit_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this explanation of benefit. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** The category of claim, e.g. oral, pharmacy, vision, institutional, professional. */
  type: FHIRCodeableConcept,
  /** 
 * A finer grained suite of claim type codes which may convey additional
   * information such as Inpatient vs Outpatient and/or a specialty service.
 */
  subType?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code to indicate whether the nature of the request is: to request
   * adjudication of products and services previously rendered; or requesting
   * authorization and adjudication for provision in the future; or requesting the
   * non-binding adjudication of the listed products and services which could be
   * provided in the future.
 */
  use: Scalars['FHIRCode'],
  /** 
 * The party to whom the professional services and/or products have been supplied
   * or are being considered and for whom actual for forecast reimbursement is sought.
 */
  patient: FHIRExplanationOfBenefitpatient_patient_Union,
  /** The period for which charges are being submitted. */
  billablePeriod?: Maybe<FHIRPeriod>,
  /** The date this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** Individual who created the claim, predetermination or preauthorization. */
  enterer?: Maybe<FHIRExplanationOfBenefitenterer_enterer_Union>,
  /** The party responsible for authorization, adjudication and reimbursement. */
  insurer: FHIRExplanationOfBenefitinsurer_insurer_Union,
  /** The provider which is responsible for the claim, predetermination or preauthorization. */
  provider: FHIRExplanationOfBenefitprovider_provider_Union,
  /** The provider-required urgency of processing the request. Typical values include: stat, routine deferred. */
  priority?: Maybe<FHIRCodeableConcept>,
  /** A code to indicate whether and for whom funds are to be reserved for future claims. */
  fundsReserveRequested?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code, used only on a response to a preauthorization, to indicate whether the
   * benefits payable have been reserved and for whom.
 */
  fundsReserve?: Maybe<FHIRCodeableConcept>,
  /** 
 * Other claims which are related to this claim such as prior submissions or
   * claims for related services or for the same event.
 */
  related?: Maybe<Array<Maybe<FHIRExplanationOfBenefitrelated>>>,
  /** Prescription to support the dispensing of pharmacy, device or vision products. */
  prescription?: Maybe<FHIRExplanationOfBenefitprescription_prescription_Union>,
  /** 
 * Original prescription which has been superseded by this prescription to
   * support the dispensing of pharmacy services, medications or products.
 */
  originalPrescription?: Maybe<FHIRExplanationOfBenefitoriginalPrescription_originalPrescription_Union>,
  /** The party to be reimbursed for cost of the products and services according to the terms of the policy. */
  payee?: Maybe<FHIRExplanationOfBenefitpayee>,
  /** A reference to a referral resource. */
  referral?: Maybe<FHIRExplanationOfBenefitreferral_referral_Union>,
  /** Facility where the services were provided. */
  facility?: Maybe<FHIRExplanationOfBenefitfacility_facility_Union>,
  /** The business identifier for the instance of the adjudication request: claim predetermination or preauthorization. */
  claim?: Maybe<FHIRExplanationOfBenefitclaim_claim_Union>,
  /** 
 * The business identifier for the instance of the adjudication response: claim,
   * predetermination or preauthorization response.
 */
  claimResponse?: Maybe<FHIRExplanationOfBenefitclaimResponse_claimResponse_Union>,
  /** The outcome of the claim, predetermination, or preauthorization processing. */
  outcome: Scalars['FHIRCode'],
  /** A human readable description of the status of the adjudication. */
  disposition?: Maybe<Scalars['String']>,
  /** Reference from the Insurer which is used in later communications which refers to this adjudication. */
  preAuthRef?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * The timeframe during which the supplied preauthorization reference may be
   * quoted on claims to obtain the adjudication as provided.
 */
  preAuthRefPeriod?: Maybe<Array<Maybe<FHIRPeriod>>>,
  /** The members of the team who provided the products and services. */
  careTeam?: Maybe<Array<Maybe<FHIRExplanationOfBenefitcareTeam>>>,
  /** 
 * Additional information codes regarding exceptions, special considerations, the
   * condition, situation, prior or concurrent issues.
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRExplanationOfBenefitsupportingInfo>>>,
  /** Information about diagnoses relevant to the claim items. */
  diagnosis?: Maybe<Array<Maybe<FHIRExplanationOfBenefitdiagnosis>>>,
  /** Procedures performed on the patient relevant to the billing items with the claim. */
  procedure?: Maybe<Array<Maybe<FHIRExplanationOfBenefitprocedure>>>,
  /** This indicates the relative order of a series of EOBs related to different coverages for the same suite of services. */
  precedence?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Financial instruments for reimbursement for the health care products and services specified on the claim. */
  insurance?: Maybe<Array<FHIRExplanationOfBenefitinsurance>>,
  /** Details of a accident which resulted in injuries which required the products and services listed in the claim. */
  accident?: Maybe<FHIRExplanationOfBenefitaccident>,
  /** 
 * A claim line. Either a simple (a product or service) or a 'group' of details
   * which can also be a simple items or groups of sub-details.
 */
  item?: Maybe<Array<Maybe<FHIRExplanationOfBenefititem>>>,
  /** The first-tier service adjudications for payor added product or service lines. */
  addItem?: Maybe<Array<Maybe<FHIRExplanationOfBenefitaddItem>>>,
  /** Categorized monetary totals for the adjudication. */
  total?: Maybe<Array<Maybe<FHIRExplanationOfBenefittotal>>>,
  /** Payment details for the adjudication of the claim. */
  payment?: Maybe<FHIRExplanationOfBenefitpayment>,
  /** A code for the form to be used for printing the content. */
  formCode?: Maybe<FHIRCodeableConcept>,
  /** The actual form, by reference or inclusion, for printing the content or an EOB. */
  form?: Maybe<FHIRAttachment>,
  /** A note that describes or explains adjudication results in a human readable form. */
  processNote?: Maybe<Array<Maybe<FHIRExplanationOfBenefitprocessNote>>>,
  /** The term of the benefits documented in this response. */
  benefitPeriod?: Maybe<FHIRPeriod>,
  /** Balance by Benefit Category. */
  benefitBalance?: Maybe<Array<Maybe<FHIRExplanationOfBenefitbenefitBalance>>>,
};

export enum FHIRExplanationOfBenefit_Enum_schema {
  ExplanationOfBenefit = 'ExplanationOfBenefit'
}

export type FHIRExplanationOfBenefitaccident = {
   __typename?: 'FHIRExplanationOfBenefitaccident',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Date of an accident event  related to the products and services contained in the claim. */
  date?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The type or context of the accident event for the purposes of selection of
   * potential insurance coverages and determination of coordination between insurers.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The physical location of the accident event. */
  locationAddress?: Maybe<FHIRAddress>,
  /** The physical location of the accident event. */
  locationReference?: Maybe<FHIRExplanationOfBenefitaccidentlocationReference_locationReference_Union>,
};

/** The physical location of the accident event. */
export type FHIRExplanationOfBenefitaccidentlocationReference_locationReference_Union = FHIRLocation;

export type FHIRExplanationOfBenefitaddItem = {
   __typename?: 'FHIRExplanationOfBenefitaddItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Claim items which this service line is intended to replace. */
  itemSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The sequence number of the details within the claim item which this line is intended to replace. */
  detailSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace. */
  subDetailSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The providers who are authorized for the services rendered to the patient. */
  provider?: Maybe<Array<Maybe<FHIRExplanationOfBenefitaddItemprovider_provider_Union>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** Where the product or service was provided. */
  locationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Where the product or service was provided. */
  locationAddress?: Maybe<FHIRAddress>,
  /** Where the product or service was provided. */
  locationReference?: Maybe<FHIRExplanationOfBenefitaddItemlocationReference_locationReference_Union>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Physical service site on the patient (limb, tooth, etc.). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** A region or surface of the bodySite, e.g. limb region or tooth surface(s). */
  subSite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The second-tier service adjudications for payor added services. */
  detail?: Maybe<Array<Maybe<FHIRExplanationOfBenefitaddItemdetail>>>,
};

export type FHIRExplanationOfBenefitaddItemdetail = {
   __typename?: 'FHIRExplanationOfBenefitaddItemdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The third-tier service adjudications for payor added services. */
  subDetail?: Maybe<Array<Maybe<FHIRExplanationOfBenefitaddItemdetailsubDetail>>>,
};

export type FHIRExplanationOfBenefitaddItemdetailsubDetail = {
   __typename?: 'FHIRExplanationOfBenefitaddItemdetailsubDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
};

/** Where the product or service was provided. */
export type FHIRExplanationOfBenefitaddItemlocationReference_locationReference_Union = FHIRLocation;

/** The providers who are authorized for the services rendered to the patient. */
export type FHIRExplanationOfBenefitaddItemprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRExplanationOfBenefitbenefitBalance = {
   __typename?: 'FHIRExplanationOfBenefitbenefitBalance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category: FHIRCodeableConcept,
  /** 
 * True if the indicated class of service is excluded from the plan, missing or
   * False indicates the product or service is included in the coverage.
 */
  excluded?: Maybe<Scalars['Boolean']>,
  /** A short name or tag for the benefit. */
  name?: Maybe<Scalars['String']>,
  /** A richer description of the benefit or services covered. */
  description?: Maybe<Scalars['String']>,
  /** Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. */
  network?: Maybe<FHIRCodeableConcept>,
  /** Indicates if the benefits apply to an individual or to the family. */
  unit?: Maybe<FHIRCodeableConcept>,
  /** The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. */
  term?: Maybe<FHIRCodeableConcept>,
  /** Benefits Used to date. */
  financial?: Maybe<Array<Maybe<FHIRExplanationOfBenefitbenefitBalancefinancial>>>,
};

export type FHIRExplanationOfBenefitbenefitBalancefinancial = {
   __typename?: 'FHIRExplanationOfBenefitbenefitBalancefinancial',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Classification of benefit being provided. */
  type: FHIRCodeableConcept,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedString?: Maybe<Scalars['String']>,
  /** The quantity of the benefit which is permitted under the coverage. */
  allowedMoney?: Maybe<FHIRMoney>,
  /** The quantity of the benefit which have been consumed to date. */
  usedUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The quantity of the benefit which have been consumed to date. */
  usedMoney?: Maybe<FHIRMoney>,
};

export type FHIRExplanationOfBenefitcareTeam = {
   __typename?: 'FHIRExplanationOfBenefitcareTeam',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify care team entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** Member of the team who provided the product or service. */
  provider: FHIRExplanationOfBenefitcareTeamprovider_provider_Union,
  /** The party who is billing and/or responsible for the claimed products or services. */
  responsible?: Maybe<Scalars['Boolean']>,
  /** The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. */
  role?: Maybe<FHIRCodeableConcept>,
  /** The qualification of the practitioner which is applicable for this service. */
  qualification?: Maybe<FHIRCodeableConcept>,
};

/** Member of the team who provided the product or service. */
export type FHIRExplanationOfBenefitcareTeamprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** The business identifier for the instance of the adjudication request: claim predetermination or preauthorization. */
export type FHIRExplanationOfBenefitclaim_claim_Union = FHIRClaim;

/** The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response. */
export type FHIRExplanationOfBenefitclaimResponse_claimResponse_Union = FHIRClaimResponse;

export type FHIRExplanationOfBenefitdiagnosis = {
   __typename?: 'FHIRExplanationOfBenefitdiagnosis',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify diagnosis entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisCodeableConcept: FHIRCodeableConcept,
  /** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
  diagnosisReference: FHIRExplanationOfBenefitdiagnosisdiagnosisReference_diagnosisReference_Union,
  /** When the condition was observed or the relative ranking. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indication of whether the diagnosis was present on admission to a facility. */
  onAdmission?: Maybe<FHIRCodeableConcept>,
  /** 
 * A package billing code or bundle code used to group products and services to a
   * particular health condition (such as heart attack) which is based on a
   * predetermined grouping code system.
 */
  packageCode?: Maybe<FHIRCodeableConcept>,
};

/** The nature of illness or problem in a coded form or as a reference to an external defined Condition. */
export type FHIRExplanationOfBenefitdiagnosisdiagnosisReference_diagnosisReference_Union = FHIRCondition;

/** Individual who created the claim, predetermination or preauthorization. */
export type FHIRExplanationOfBenefitenterer_enterer_Union = FHIRPractitioner | FHIRPractitionerRole;

/** Facility where the services were provided. */
export type FHIRExplanationOfBenefitfacility_facility_Union = FHIRLocation;

export type FHIRExplanationOfBenefitinsurance = {
   __typename?: 'FHIRExplanationOfBenefitinsurance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true. */
  focal: Scalars['Boolean'],
  /** 
 * Reference to the insurance card level information contained in the Coverage
   * resource. The coverage issuing insurer will use these details to locate the
   * patient's actual coverage within the insurer's information system.
 */
  coverage: FHIRExplanationOfBenefitinsurancecoverage_coverage_Union,
  /** 
 * Reference numbers previously provided by the insurer to the provider to be
   * quoted on subsequent claims containing services or products related to the
   * prior authorization.
 */
  preAuthRef?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** 
 * Reference to the insurance card level information contained in the Coverage
 * resource. The coverage issuing insurer will use these details to locate the
 * patient's actual coverage within the insurer's information system.
 */
export type FHIRExplanationOfBenefitinsurancecoverage_coverage_Union = FHIRCoverage;

/** The party responsible for authorization, adjudication and reimbursement. */
export type FHIRExplanationOfBenefitinsurer_insurer_Union = FHIROrganization;

export type FHIRExplanationOfBenefititem = {
   __typename?: 'FHIRExplanationOfBenefititem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify item entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** Care team members related to this service or product. */
  careTeamSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Diagnoses applicable for this service or product. */
  diagnosisSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Procedures applicable for this service or product. */
  procedureSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Exceptions, special conditions and supporting information applicable for this service or product. */
  informationSequence?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or dates when the service or product was supplied, performed or completed. */
  servicedPeriod?: Maybe<FHIRPeriod>,
  /** Where the product or service was provided. */
  locationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Where the product or service was provided. */
  locationAddress?: Maybe<FHIRAddress>,
  /** Where the product or service was provided. */
  locationReference?: Maybe<FHIRExplanationOfBenefititemlocationReference_locationReference_Union>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemudi_udi_Union>>>,
  /** Physical service site on the patient (limb, tooth, etc.). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** A region or surface of the bodySite, e.g. limb region or tooth surface(s). */
  subSite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A billed item may include goods or services provided in multiple encounters. */
  encounter?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemencounter_encounter_Union>>>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** 
 * If this item is a group then the values here are a summary of the adjudication
   * of the detail items. If this item is a simple product or service then this is
   * the result of the adjudication of this item.
 */
  adjudication?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemadjudication>>>,
  /** Second-tier of goods and services. */
  detail?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemdetail>>>,
};

export type FHIRExplanationOfBenefititemadjudication = {
   __typename?: 'FHIRExplanationOfBenefititemadjudication',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code to indicate the information type of this adjudication record.
   * Information types may include: the value submitted, maximum values or
   * percentages allowed or payable under the plan, amounts that the patient is
   * responsible for in-aggregate or pertaining to this item, amounts paid by other
   * coverages, and the benefit payable for this item.
 */
  category: FHIRCodeableConcept,
  /** A code supporting the understanding of the adjudication result and explaining variance from expected amount. */
  reason?: Maybe<FHIRCodeableConcept>,
  /** Monetary amount associated with the category. */
  amount?: Maybe<FHIRMoney>,
  /** A non-monetary value associated with the category. Mutually exclusive to the amount element above. */
  value?: Maybe<Scalars['Float']>,
};

export type FHIRExplanationOfBenefititemdetail = {
   __typename?: 'FHIRExplanationOfBenefititemdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemdetailudi_udi_Union>>>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
  /** Third-tier of goods and services. */
  subDetail?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemdetailsubDetail>>>,
};

export type FHIRExplanationOfBenefititemdetailsubDetail = {
   __typename?: 'FHIRExplanationOfBenefititemdetailsubDetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The type of revenue or cost center providing the product and/or service. */
  revenue?: Maybe<FHIRCodeableConcept>,
  /** Code to identify the general type of benefits under which products and services are provided. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * When the value is a group code then this item collects a set of related claim
   * details, otherwise this contains the product, service, drug or other billing
   * code for the item.
 */
  productOrService: FHIRCodeableConcept,
  /** Item typification or modifiers codes to convey additional context for the product or service. */
  modifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the program under which this may be recovered. */
  programCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The number of repetitions of a service or product. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * If the item is not a group then this is the fee for the product or service,
   * otherwise this is the total of the fees for the details of the group.
 */
  unitPrice?: Maybe<FHIRMoney>,
  /** 
 * A real number that represents a multiplier used in determining the overall
   * value of services delivered and/or goods received. The concept of a Factor
   * allows for a discount or surcharge multiplier to be applied to a monetary amount.
 */
  factor?: Maybe<Scalars['Float']>,
  /** The quantity times the unit price for an additional service or product or charge. */
  net?: Maybe<FHIRMoney>,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRExplanationOfBenefititemdetailsubDetailudi_udi_Union>>>,
  /** The numbers associated with notes below which apply to the adjudication of this item. */
  noteNumber?: Maybe<Array<Maybe<Scalars['FHIRPositiveInt']>>>,
};

/** Unique Device Identifiers associated with this line item. */
export type FHIRExplanationOfBenefititemdetailsubDetailudi_udi_Union = FHIRDevice;

/** Unique Device Identifiers associated with this line item. */
export type FHIRExplanationOfBenefititemdetailudi_udi_Union = FHIRDevice;

/** A billed item may include goods or services provided in multiple encounters. */
export type FHIRExplanationOfBenefititemencounter_encounter_Union = FHIREncounter;

/** Where the product or service was provided. */
export type FHIRExplanationOfBenefititemlocationReference_locationReference_Union = FHIRLocation;

/** Unique Device Identifiers associated with this line item. */
export type FHIRExplanationOfBenefititemudi_udi_Union = FHIRDevice;

/** 
 * Original prescription which has been superseded by this prescription to support
 * the dispensing of pharmacy services, medications or products.
 */
export type FHIRExplanationOfBenefitoriginalPrescription_originalPrescription_Union = FHIRMedicationRequest;

/** 
 * The party to whom the professional services and/or products have been supplied
 * or are being considered and for whom actual for forecast reimbursement is sought.
 */
export type FHIRExplanationOfBenefitpatient_patient_Union = FHIRPatient;

export type FHIRExplanationOfBenefitpayee = {
   __typename?: 'FHIRExplanationOfBenefitpayee',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of Party to be reimbursed: Subscriber, provider, other. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Reference to the individual or organization to whom any payment will be made. */
  party?: Maybe<FHIRExplanationOfBenefitpayeeparty_party_Union>,
};

/** Reference to the individual or organization to whom any payment will be made. */
export type FHIRExplanationOfBenefitpayeeparty_party_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson;

export type FHIRExplanationOfBenefitpayment = {
   __typename?: 'FHIRExplanationOfBenefitpayment',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Whether this represents partial or complete payment of the benefits payable. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Total amount of all adjustments to this payment included in this transaction
   * which are not related to this claim's adjudication.
 */
  adjustment?: Maybe<FHIRMoney>,
  /** Reason for the payment adjustment. */
  adjustmentReason?: Maybe<FHIRCodeableConcept>,
  /** Estimated date the payment will be issued or the actual issue date of payment. */
  date?: Maybe<Scalars['FHIRDate']>,
  /** Benefits payable less any payment adjustment. */
  amount?: Maybe<FHIRMoney>,
  /** Issuer's unique identifier for the payment instrument. */
  identifier?: Maybe<FHIRIdentifier>,
};

/** Prescription to support the dispensing of pharmacy, device or vision products. */
export type FHIRExplanationOfBenefitprescription_prescription_Union = FHIRMedicationRequest | FHIRVisionPrescription;

export type FHIRExplanationOfBenefitprocedure = {
   __typename?: 'FHIRExplanationOfBenefitprocedure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify procedure entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** When the condition was observed or the relative ranking. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Date and optionally time the procedure was performed. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
  procedureCodeableConcept: FHIRCodeableConcept,
  /** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
  procedureReference: FHIRExplanationOfBenefitprocedureprocedureReference_procedureReference_Union,
  /** Unique Device Identifiers associated with this line item. */
  udi?: Maybe<Array<Maybe<FHIRExplanationOfBenefitprocedureudi_udi_Union>>>,
};

/** The code or reference to a Procedure resource which identifies the clinical intervention performed. */
export type FHIRExplanationOfBenefitprocedureprocedureReference_procedureReference_Union = FHIRProcedure;

/** Unique Device Identifiers associated with this line item. */
export type FHIRExplanationOfBenefitprocedureudi_udi_Union = FHIRDevice;

export type FHIRExplanationOfBenefitprocessNote = {
   __typename?: 'FHIRExplanationOfBenefitprocessNote',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify a note entry. */
  number?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The business purpose of the note text. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** The explanation or description associated with the processing. */
  text?: Maybe<Scalars['String']>,
  /** A code to define the language used in the text of the note. */
  language?: Maybe<FHIRCodeableConcept>,
};

/** The provider which is responsible for the claim, predetermination or preauthorization. */
export type FHIRExplanationOfBenefitprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** A reference to a referral resource. */
export type FHIRExplanationOfBenefitreferral_referral_Union = FHIRServiceRequest;

export type FHIRExplanationOfBenefitrelated = {
   __typename?: 'FHIRExplanationOfBenefitrelated',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Reference to a related claim. */
  claim?: Maybe<FHIRExplanationOfBenefitrelatedclaim_claim_Union>,
  /** A code to convey how the claims are related. */
  relationship?: Maybe<FHIRCodeableConcept>,
  /** An alternate organizational reference to the case or file to which this particular claim pertains. */
  reference?: Maybe<FHIRIdentifier>,
};

/** Reference to a related claim. */
export type FHIRExplanationOfBenefitrelatedclaim_claim_Union = FHIRClaim;

export type FHIRExplanationOfBenefitsupportingInfo = {
   __typename?: 'FHIRExplanationOfBenefitsupportingInfo',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number to uniquely identify supporting information entries. */
  sequence: Scalars['FHIRPositiveInt'],
  /** The general class of the information supplied: information; exception; accident, employment; onset, etc. */
  category: FHIRCodeableConcept,
  /** 
 * System and code pertaining to the specific information regarding special
   * conditions relating to the setting, treatment or patient  for which care is sought.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The date when or period to which this information refers. */
  timingDate?: Maybe<Scalars['FHIRDate']>,
  /** The date when or period to which this information refers. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueString?: Maybe<Scalars['String']>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Additional data or information such as resources, documents, images etc.
   * including references to the data or the actual inclusion of the data.
 */
  valueReference?: Maybe<FHIRExplanationOfBenefitsupportingInfovalueReference_valueReference_Union>,
  /** Provides the reason in the situation where a reason code is required in addition to the content. */
  reason?: Maybe<FHIRCoding>,
};

/** 
 * Additional data or information such as resources, documents, images etc.
 * including references to the data or the actual inclusion of the data.
 */
export type FHIRExplanationOfBenefitsupportingInfovalueReference_valueReference_Union = FHIRResource;

export type FHIRExplanationOfBenefittotal = {
   __typename?: 'FHIRExplanationOfBenefittotal',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code to indicate the information type of this adjudication record.
   * Information types may include: the value submitted, maximum values or
   * percentages allowed or payable under the plan, amounts that the patient is
   * responsible for in aggregate or pertaining to this item, amounts paid by other
   * coverages, and the benefit payable for this item.
 */
  category: FHIRCodeableConcept,
  /** Monetary total amount associated with the category. */
  amount: FHIRMoney,
};

/** 
 * Base StructureDefinition for Expression Type: A expression that is evaluated in
 * a specified context and returns a value. The context of use of the expression
 * must specify the context in which the expression is evaluated, and how the
 * result of the expression is used.
 */
export type FHIRExpression = {
   __typename?: 'FHIRExpression',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A brief, natural language description of the condition that effectively communicates the intended semantics. */
  description?: Maybe<Scalars['String']>,
  /** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined. */
  name?: Maybe<Scalars['FHIRId']>,
  /** The media type of the language for the expression. */
  language: Scalars['FHIRCode'],
  /** An expression in the specified language that returns a value. */
  expression?: Maybe<Scalars['String']>,
  /** A URI that defines where the expression is found. */
  reference?: Maybe<Scalars['FHIRUri']>,
};

/** 
 * Base StructureDefinition for Expression Type: A expression that is evaluated in
 * a specified context and returns a value. The context of use of the expression
 * must specify the context in which the expression is evaluated, and how the
 * result of the expression is used.
 */
export type FHIRExpression_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** A brief, natural language description of the condition that effectively communicates the intended semantics. */
  _description?: Maybe<FHIRElement_Input>,
  /** A brief, natural language description of the condition that effectively communicates the intended semantics. */
  description?: Maybe<Scalars['String']>,
  /** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined. */
  _name?: Maybe<FHIRElement_Input>,
  /** A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined. */
  name?: Maybe<Scalars['FHIRId']>,
  /** The media type of the language for the expression. */
  _language?: Maybe<FHIRElement_Input>,
  /** The media type of the language for the expression. */
  language: Scalars['FHIRCode'],
  /** An expression in the specified language that returns a value. */
  _expression?: Maybe<FHIRElement_Input>,
  /** An expression in the specified language that returns a value. */
  expression?: Maybe<Scalars['String']>,
  /** A URI that defines where the expression is found. */
  _reference?: Maybe<FHIRElement_Input>,
  /** A URI that defines where the expression is found. */
  reference?: Maybe<Scalars['FHIRUri']>,
};

/** Base StructureDefinition for Extension Type: Optional Extension Element - found in all resources. */
export type FHIRExtension = {
   __typename?: 'FHIRExtension',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Source of the definition for the extension code - a logical name or a URL. */
  url: Scalars['String'],
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCode?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDecimal?: Maybe<Scalars['Float']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueId?: Maybe<Scalars['FHIRId']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueInteger?: Maybe<Scalars['Int']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueMarkdown?: Maybe<Scalars['String']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueOid?: Maybe<Scalars['FHIROid']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueString?: Maybe<Scalars['String']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUrl?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUuid?: Maybe<Scalars['FHIRUuid']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAddress?: Maybe<FHIRAddress>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAge?: Maybe<FHIRAge>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAnnotation?: Maybe<FHIRAnnotation>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAttachment?: Maybe<FHIRAttachment>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCoding?: Maybe<FHIRCoding>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContactPoint?: Maybe<FHIRContactPoint>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCount?: Maybe<FHIRCount>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDistance?: Maybe<FHIRDistance>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDuration?: Maybe<FHIRDuration>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueHumanName?: Maybe<FHIRHumanName>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueIdentifier?: Maybe<FHIRIdentifier>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueMoney?: Maybe<FHIRMoney>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valuePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRange?: Maybe<FHIRRange>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRatio?: Maybe<FHIRRatio>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueReference?: Maybe<FHIRResourceList>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueSampledData?: Maybe<FHIRSampledData>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueSignature?: Maybe<FHIRSignature>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTiming?: Maybe<FHIRTiming>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContactDetail?: Maybe<FHIRContactDetail>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContributor?: Maybe<FHIRContributor>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDataRequirement?: Maybe<FHIRDataRequirement>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueExpression?: Maybe<FHIRExpression>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUsageContext?: Maybe<FHIRUsageContext>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDosage?: Maybe<FHIRDosage>,
};

/** Base StructureDefinition for Extension Type: Optional Extension Element - found in all resources. */
export type FHIRExtension_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Source of the definition for the extension code - a logical name or a URL. */
  _url?: Maybe<FHIRElement_Input>,
  /** Source of the definition for the extension code - a logical name or a URL. */
  url: Scalars['String'],
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueBase64Binary?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueBoolean?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueCanonical?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueCode?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCode?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueDate?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueDateTime?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueDecimal?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDecimal?: Maybe<Scalars['Float']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueId?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueId?: Maybe<Scalars['FHIRId']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueInstant?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueInteger?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueInteger?: Maybe<Scalars['Int']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueMarkdown?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueMarkdown?: Maybe<Scalars['String']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueOid?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueOid?: Maybe<Scalars['FHIROid']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valuePositiveInt?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueString?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueString?: Maybe<Scalars['String']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueTime?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueUnsignedInt?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueUri?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueUrl?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUrl?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  _valueUuid?: Maybe<FHIRElement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUuid?: Maybe<Scalars['FHIRUuid']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAddress?: Maybe<FHIRAddress_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAge?: Maybe<FHIRAge_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAnnotation?: Maybe<FHIRAnnotation_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueAttachment?: Maybe<FHIRAttachment_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCoding?: Maybe<FHIRCoding_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContactPoint?: Maybe<FHIRContactPoint_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueCount?: Maybe<FHIRCount_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDistance?: Maybe<FHIRDistance_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDuration?: Maybe<FHIRDuration_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueHumanName?: Maybe<FHIRHumanName_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueIdentifier?: Maybe<FHIRIdentifier_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueMoney?: Maybe<FHIRMoney_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valuePeriod?: Maybe<FHIRPeriod_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueQuantity?: Maybe<FHIRQuantity_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRange?: Maybe<FHIRRange_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRatio?: Maybe<FHIRRatio_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueReference?: Maybe<Scalars['String']>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueSampledData?: Maybe<FHIRSampledData_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueSignature?: Maybe<FHIRSignature_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTiming?: Maybe<FHIRTiming_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContactDetail?: Maybe<FHIRContactDetail_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueContributor?: Maybe<FHIRContributor_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDataRequirement?: Maybe<FHIRDataRequirement_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueExpression?: Maybe<FHIRExpression_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueParameterDefinition?: Maybe<FHIRParameterDefinition_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueRelatedArtifact?: Maybe<FHIRRelatedArtifact_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueTriggerDefinition?: Maybe<FHIRTriggerDefinition_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueUsageContext?: Maybe<FHIRUsageContext_Input>,
  /** 
 * Value of extension - must be one of a constrained set of the data types (see
   * [Extensibility](extensibility.html) for a list).
 */
  valueDosage?: Maybe<FHIRDosage_Input>,
};

/** Significant health conditions for a person related to the patient relevant in the context of care for the patient. */
export type FHIRFamilyMemberHistory = {
   __typename?: 'FHIRFamilyMemberHistory',
  /** Type of resource */
  resourceType: FHIRFamilyMemberHistory_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this family member history by the performer
   * or other systems which remain constant as the resource is updated and
   * propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this FamilyMemberHistory.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * FamilyMemberHistory.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A code specifying the status of the record of the family history of a specific family member. */
  status: Scalars['FHIRCode'],
  /** Describes why the family member's history is not available. */
  dataAbsentReason?: Maybe<FHIRCodeableConcept>,
  /** The person who this history concerns. */
  patient: FHIRFamilyMemberHistorypatient_patient_Union,
  /** The date (and possibly time) when the family member history was recorded or last updated. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** This will either be a name or a description; e.g. 'Aunt Susan', 'my cousin with the red hair'. */
  name?: Maybe<Scalars['String']>,
  /** The type of relationship this person has to the patient (father, mother, brother etc.). */
  relationship: FHIRCodeableConcept,
  /** The birth sex of the family member. */
  sex?: Maybe<FHIRCodeableConcept>,
  /** The actual or approximate date of birth of the relative. */
  bornPeriod?: Maybe<FHIRPeriod>,
  /** The actual or approximate date of birth of the relative. */
  bornDate?: Maybe<Scalars['FHIRDate']>,
  /** The actual or approximate date of birth of the relative. */
  bornString?: Maybe<Scalars['String']>,
  /** The age of the relative at the time the family member history is recorded. */
  ageAge?: Maybe<FHIRAge>,
  /** The age of the relative at the time the family member history is recorded. */
  ageRange?: Maybe<FHIRRange>,
  /** The age of the relative at the time the family member history is recorded. */
  ageString?: Maybe<Scalars['String']>,
  /** If true, indicates that the age value specified is an estimated value. */
  estimatedAge?: Maybe<Scalars['Boolean']>,
  /** Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. */
  deceasedBoolean?: Maybe<Scalars['Boolean']>,
  /** Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. */
  deceasedAge?: Maybe<FHIRAge>,
  /** Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. */
  deceasedRange?: Maybe<FHIRRange>,
  /** Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. */
  deceasedDate?: Maybe<Scalars['FHIRDate']>,
  /** Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. */
  deceasedString?: Maybe<Scalars['String']>,
  /** Describes why the family member history occurred in coded or textual form. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates a Condition, Observation, AllergyIntolerance, or
   * QuestionnaireResponse that justifies this family member history event.
 */
  reasonReference?: Maybe<Array<Maybe<FHIRFamilyMemberHistoryreasonReference_reasonReference_Union>>>,
  /** 
 * This property allows a non condition-specific note to the made about the
   * related person. Ideally, the note would be in the condition property, but this
   * is not always possible.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The significant Conditions (or condition) that the family member had. This is
   * a repeating section to allow a system to represent more than one condition per
   * resource, though there is nothing stopping multiple resources - one per condition.
 */
  condition?: Maybe<Array<Maybe<FHIRFamilyMemberHistorycondition>>>,
};

export enum FHIRFamilyMemberHistory_Enum_schema {
  FamilyMemberHistory = 'FamilyMemberHistory'
}

export type FHIRFamilyMemberHistorycondition = {
   __typename?: 'FHIRFamilyMemberHistorycondition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The actual condition specified. Could be a coded condition (like MI or
   * Diabetes) or a less specific string like 'cancer' depending on how much is
   * known about the condition and the capabilities of the creating system.
 */
  code: FHIRCodeableConcept,
  /** 
 * Indicates what happened following the condition.  If the condition resulted in
   * death, deceased date is captured on the relation.
 */
  outcome?: Maybe<FHIRCodeableConcept>,
  /** 
 * This condition contributed to the cause of death of the related person. If
   * contributedToDeath is not populated, then it is unknown.
 */
  contributedToDeath?: Maybe<Scalars['Boolean']>,
  /** 
 * Either the age of onset, range of approximate age or descriptive string can be
   * recorded.  For conditions with multiple occurrences, this describes the first
   * known occurrence.
 */
  onsetAge?: Maybe<FHIRAge>,
  /** 
 * Either the age of onset, range of approximate age or descriptive string can be
   * recorded.  For conditions with multiple occurrences, this describes the first
   * known occurrence.
 */
  onsetRange?: Maybe<FHIRRange>,
  /** 
 * Either the age of onset, range of approximate age or descriptive string can be
   * recorded.  For conditions with multiple occurrences, this describes the first
   * known occurrence.
 */
  onsetPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Either the age of onset, range of approximate age or descriptive string can be
   * recorded.  For conditions with multiple occurrences, this describes the first
   * known occurrence.
 */
  onsetString?: Maybe<Scalars['String']>,
  /** An area where general notes can be placed about this specific condition. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

/** The person who this history concerns. */
export type FHIRFamilyMemberHistorypatient_patient_Union = FHIRPatient;

/** 
 * Indicates a Condition, Observation, AllergyIntolerance, or QuestionnaireResponse
 * that justifies this family member history event.
 */
export type FHIRFamilyMemberHistoryreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRAllergyIntolerance | FHIRQuestionnaireResponse | FHIRDiagnosticReport | FHIRDocumentReference;

/** Prospective warnings of potential issues when providing care to the patient. */
export type FHIRFlag = {
   __typename?: 'FHIRFlag',
  /** Type of resource */
  resourceType: FHIRFlag_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this flag by the performer or other systems
   * which remain constant as the resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Supports basic workflow. */
  status: Scalars['FHIRCode'],
  /** 
 * Allows a flag to be divided into different categories like clinical,
   * administrative etc. Intended to be used as a means of filtering which flags
   * are displayed to particular user or in a given context.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The coded value or textual component of the flag to display to the user. */
  code: FHIRCodeableConcept,
  /** The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with. */
  subject: FHIRFlagsubject_subject_Union,
  /** 
 * The period of time from the activation of the flag to inactivation of the
   * flag. If the flag is active, the end of the period should be unspecified.
 */
  period?: Maybe<FHIRPeriod>,
  /** This alert is only relevant during the encounter. */
  encounter?: Maybe<FHIRFlagencounter_encounter_Union>,
  /** The person, organization or device that created the flag. */
  author?: Maybe<FHIRFlagauthor_author_Union>,
};

export enum FHIRFlag_Enum_schema {
  Flag = 'Flag'
}

/** The person, organization or device that created the flag. */
export type FHIRFlagauthor_author_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole;

/** This alert is only relevant during the encounter. */
export type FHIRFlagencounter_encounter_Union = FHIREncounter;

/** The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with. */
export type FHIRFlagsubject_subject_Union = FHIRPatient | FHIRLocation | FHIRGroup | FHIROrganization | FHIRPractitioner | FHIRPlanDefinition | FHIRMedication | FHIRProcedure;

/** 
 * Describes the intended objective(s) for a patient, group or organization care,
 * for example, weight loss, restoring an activity of daily living, obtaining herd
 * immunity via immunization, meeting a process improvement objective, etc.
 */
export type FHIRGoal = {
   __typename?: 'FHIRGoal',
  /** Type of resource */
  resourceType: FHIRGoal_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this goal by the performer or other systems
   * which remain constant as the resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The state of the goal throughout its lifecycle. */
  lifecycleStatus: Scalars['FHIRCode'],
  /** Describes the progression, or lack thereof, towards the goal against the target. */
  achievementStatus?: Maybe<FHIRCodeableConcept>,
  /** Indicates a category the goal falls within. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Identifies the mutually agreed level of importance associated with reaching/sustaining the goal. */
  priority?: Maybe<FHIRCodeableConcept>,
  /** 
 * Human-readable and/or coded description of a specific desired objective of
   * care, such as 'control blood pressure' or 'negotiate an obstacle course' or
   * 'dance with child at wedding'.
 */
  description: FHIRCodeableConcept,
  /** Identifies the patient, group or organization for whom the goal is being established. */
  subject: FHIRGoalsubject_subject_Union,
  /** The date or event after which the goal should begin being pursued. */
  startDate?: Maybe<Scalars['FHIRDate']>,
  /** The date or event after which the goal should begin being pursued. */
  startCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Indicates what should be done by when. */
  target?: Maybe<Array<Maybe<FHIRGoaltarget>>>,
  /** Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc. */
  statusDate?: Maybe<Scalars['FHIRDate']>,
  /** Captures the reason for the current status. */
  statusReason?: Maybe<Scalars['String']>,
  /** Indicates whose goal this is - patient goal, practitioner goal, etc. */
  expressedBy?: Maybe<FHIRGoalexpressedBy_expressedBy_Union>,
  /** The identified conditions and other health record elements that are intended to be addressed by the goal. */
  addresses?: Maybe<Array<Maybe<FHIRGoaladdresses_addresses_Union>>>,
  /** Any comments related to the goal. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Identifies the change (or lack of change) at the point when the status of the goal is assessed. */
  outcomeCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Details of what's changed (or not changed). */
  outcomeReference?: Maybe<Array<Maybe<FHIRGoaloutcomeReference_outcomeReference_Union>>>,
};

export enum FHIRGoal_Enum_schema {
  Goal = 'Goal'
}

/** The identified conditions and other health record elements that are intended to be addressed by the goal. */
export type FHIRGoaladdresses_addresses_Union = FHIRCondition | FHIRObservation | FHIRMedicationStatement | FHIRNutritionOrder | FHIRServiceRequest | FHIRRiskAssessment;

/** Indicates whose goal this is - patient goal, practitioner goal, etc. */
export type FHIRGoalexpressedBy_expressedBy_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** Details of what's changed (or not changed). */
export type FHIRGoaloutcomeReference_outcomeReference_Union = FHIRObservation;

/** Identifies the patient, group or organization for whom the goal is being established. */
export type FHIRGoalsubject_subject_Union = FHIRPatient | FHIRGroup | FHIROrganization;

export type FHIRGoaltarget = {
   __typename?: 'FHIRGoaltarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. */
  measure?: Maybe<FHIRCodeableConcept>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailQuantity?: Maybe<FHIRQuantity>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailRange?: Maybe<FHIRRange>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailString?: Maybe<Scalars['String']>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailInteger?: Maybe<Scalars['Int']>,
  /** 
 * The target value of the focus to be achieved to signify the fulfillment of the
   * goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any focus value at or below the high value. Similarly, if
   * the high value is missing, it indicates that the goal is achieved at any focus
   * value at or above the low value.
 */
  detailRatio?: Maybe<FHIRRatio>,
  /** Indicates either the date or the duration after start by which the goal should be met. */
  dueDate?: Maybe<Scalars['FHIRDate']>,
  /** Indicates either the date or the duration after start by which the goal should be met. */
  dueDuration?: Maybe<FHIRDuration>,
};

/** 
 * A formal computable definition of a graph of resources - that is, a coherent set
 * of resources that form a graph by following references. The Graph Definition
 * resource defines a set and makes rules about the set.
 */
export type FHIRGraphDefinition = {
   __typename?: 'FHIRGraphDefinition',
  /** Type of resource */
  resourceType: FHIRGraphDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this graph definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this graph definition
   * is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the graph definition is stored on
   * different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The identifier that is used to identify this version of the graph definition
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the graph definition author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the graph definition. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name: Scalars['String'],
  /** The status of this graph definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this graph definition is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the graph definition was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the graph definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the graph definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the graph definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate graph
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the graph definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this graph definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** The type of FHIR resource at which instances of this graph start. */
  start: Scalars['FHIRCode'],
  /** The profile that describes the use of the base resource. */
  profile?: Maybe<Scalars['FHIRCanonical']>,
  /** Links this graph makes rules about. */
  link?: Maybe<Array<Maybe<FHIRGraphDefinitionlink>>>,
};

export enum FHIRGraphDefinition_Enum_schema {
  GraphDefinition = 'GraphDefinition'
}

export type FHIRGraphDefinitionlink = {
   __typename?: 'FHIRGraphDefinitionlink',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A FHIR expression that identifies one of FHIR References to other resources. */
  path?: Maybe<Scalars['String']>,
  /** Which slice (if profiled). */
  sliceName?: Maybe<Scalars['String']>,
  /** Minimum occurrences for this link. */
  min?: Maybe<Scalars['Int']>,
  /** Maximum occurrences for this link. */
  max?: Maybe<Scalars['String']>,
  /** Information about why this link is of interest in this graph definition. */
  description?: Maybe<Scalars['String']>,
  /** Potential target for the link. */
  target?: Maybe<Array<Maybe<FHIRGraphDefinitionlinktarget>>>,
};

export type FHIRGraphDefinitionlinktarget = {
   __typename?: 'FHIRGraphDefinitionlinktarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of resource this link refers to. */
  type: Scalars['FHIRCode'],
  /** A set of parameters to look up. */
  params?: Maybe<Scalars['String']>,
  /** Profile for the target resource. */
  profile?: Maybe<Scalars['FHIRCanonical']>,
  /** Compartment Consistency Rules. */
  compartment?: Maybe<Array<Maybe<FHIRGraphDefinitionlinktargetcompartment>>>,
};

export type FHIRGraphDefinitionlinktargetcompartment = {
   __typename?: 'FHIRGraphDefinitionlinktargetcompartment',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Defines how the compartment rule is used - whether it it is used to test
   * whether resources are subject to the rule, or whether it is a rule that must be followed.
 */
  use: Scalars['FHIRCode'],
  /** Identifies the compartment. */
  code: Scalars['FHIRCode'],
  /** identical | matching | different | no-rule | custom. */
  rule: Scalars['FHIRCode'],
  /** Custom rule, as a FHIRPath expression. */
  expression?: Maybe<Scalars['String']>,
  /** Documentation for FHIRPath expression. */
  description?: Maybe<Scalars['String']>,
};

/** 
 * Represents a defined collection of entities that may be discussed or acted upon
 * collectively but which are not expected to act collectively, and are not
 * formally or legally recognized; i.e. a collection of entities that isn't an Organization.
 */
export type FHIRGroup = {
   __typename?: 'FHIRGroup',
  /** Type of resource */
  resourceType: FHIRGroup_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique business identifier for this group. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates whether the record for the group is available for use or is merely being retained for historical purposes. */
  active?: Maybe<Scalars['Boolean']>,
  /** Identifies the broad classification of the kind of resources the group includes. */
  type: Scalars['FHIRCode'],
  /** 
 * If true, indicates that the resource refers to a specific group of real
   * individuals.  If false, the group defines a set of intended individuals.
 */
  actual: Scalars['Boolean'],
  /** Provides a specific type of resource the group includes; e.g. 'cow', 'syringe', etc. */
  code?: Maybe<FHIRCodeableConcept>,
  /** A label assigned to the group for human identification and communication. */
  name?: Maybe<Scalars['String']>,
  /** A count of the number of resource instances that are part of the group. */
  quantity?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** Entity responsible for defining and maintaining Group characteristics and/or registered members. */
  managingEntity?: Maybe<FHIRGroupmanagingEntity_managingEntity_Union>,
  /** Identifies traits whose presence r absence is shared by members of the group. */
  characteristic?: Maybe<Array<Maybe<FHIRGroupcharacteristic>>>,
  /** Identifies the resource instances that are members of the group. */
  member?: Maybe<Array<Maybe<FHIRGroupmember>>>,
};

export enum FHIRGroup_Enum_schema {
  Group = 'Group'
}

export type FHIRGroupcharacteristic = {
   __typename?: 'FHIRGroupcharacteristic',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code that identifies the kind of trait being asserted. */
  code: FHIRCodeableConcept,
  /** The value of the trait that holds (or does not hold - see 'exclude') for members of the group. */
  valueCodeableConcept: FHIRCodeableConcept,
  /** The value of the trait that holds (or does not hold - see 'exclude') for members of the group. */
  valueBoolean: Scalars['Boolean'],
  /** The value of the trait that holds (or does not hold - see 'exclude') for members of the group. */
  valueQuantity: FHIRQuantity,
  /** The value of the trait that holds (or does not hold - see 'exclude') for members of the group. */
  valueRange: FHIRRange,
  /** The value of the trait that holds (or does not hold - see 'exclude') for members of the group. */
  valueReference: FHIRResourceList,
  /** If true, indicates the characteristic is one that is NOT held by members of the group. */
  exclude: Scalars['Boolean'],
  /** The period over which the characteristic is tested; e.g. the patient had an operation during the month of June. */
  period?: Maybe<FHIRPeriod>,
};

/** Entity responsible for defining and maintaining Group characteristics and/or registered members. */
export type FHIRGroupmanagingEntity_managingEntity_Union = FHIROrganization | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole;

export type FHIRGroupmember = {
   __typename?: 'FHIRGroupmember',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A reference to the entity that is a member of the group. Must be consistent
   * with Group.type. If the entity is another group, then the type must be the same.
 */
  entity: FHIRGroupmemberentity_entity_Union,
  /** The period that the member was in the group, if known. */
  period?: Maybe<FHIRPeriod>,
  /** A flag to indicate that the member is no longer in the group, but previously may have been a member. */
  inactive?: Maybe<Scalars['Boolean']>,
};

/** 
 * A reference to the entity that is a member of the group. Must be consistent with
 * Group.type. If the entity is another group, then the type must be the same.
 */
export type FHIRGroupmemberentity_entity_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRDevice | FHIRMedication | FHIRSubstance | FHIRGroup;

/** 
 * A guidance response is the formal response to a guidance request, including any
 * output parameters returned by the evaluation, as well as the description of any
 * proposed actions to be taken.
 */
export type FHIRGuidanceResponse = {
   __typename?: 'FHIRGuidanceResponse',
  /** Type of resource */
  resourceType: FHIRGuidanceResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The identifier of the request associated with this response. If an identifier
   * was given as part of the request, it will be reproduced here to enable the
   * requester to more easily identify the response in a multi-request scenario.
 */
  requestIdentifier?: Maybe<FHIRIdentifier>,
  /** Allows a service to provide  unique, business identifiers for the response. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** An identifier, CodeableConcept or canonical reference to the guidance that was requested. */
  moduleUri: Scalars['FHIRUri'],
  /** An identifier, CodeableConcept or canonical reference to the guidance that was requested. */
  moduleCanonical: Scalars['FHIRCanonical'],
  /** An identifier, CodeableConcept or canonical reference to the guidance that was requested. */
  moduleCodeableConcept: FHIRCodeableConcept,
  /** 
 * The status of the response. If the evaluation is completed successfully, the
   * status will indicate success. However, in order to complete the evaluation,
   * the engine may require more information. In this case, the status will be
   * data-required, and the response will contain a description of the additional
   * required information. If the evaluation completed successfully, but the engine
   * determines that a potentially more accurate response could be provided if more
   * data was available, the status will be data-requested, and the response will
   * contain a description of the additional requested information.
 */
  status: Scalars['FHIRCode'],
  /** The patient for which the request was processed. */
  subject?: Maybe<FHIRGuidanceResponsesubject_subject_Union>,
  /** The encounter during which this response was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRGuidanceResponseencounter_encounter_Union>,
  /** Indicates when the guidance response was processed. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Provides a reference to the device that performed the guidance. */
  performer?: Maybe<FHIRGuidanceResponseperformer_performer_Union>,
  /** Describes the reason for the guidance response in coded or textual form. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates the reason the request was initiated. This is typically provided as
   * a parameter to the evaluation and echoed by the service, although for some use
   * cases, such as subscription- or event-based scenarios, it may provide an
   * indication of the cause for the response.
 */
  reasonReference?: Maybe<Array<Maybe<FHIRGuidanceResponsereasonReference_reasonReference_Union>>>,
  /** Provides a mechanism to communicate additional information about the response. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * Messages resulting from the evaluation of the artifact or artifacts. As part
   * of evaluating the request, the engine may produce informational or warning
   * messages. These messages will be provided by this element.
 */
  evaluationMessage?: Maybe<Array<Maybe<FHIRGuidanceResponseevaluationMessage_evaluationMessage_Union>>>,
  /** 
 * The output parameters of the evaluation, if any. Many modules will result in
   * the return of specific resources such as procedure or communication requests
   * that are returned as part of the operation result. However, modules may define
   * specific outputs that would be returned as the result of the evaluation, and
   * these would be returned in this element.
 */
  outputParameters?: Maybe<FHIRGuidanceResponseoutputParameters_outputParameters_Union>,
  /** The actions, if any, produced by the evaluation of the artifact. */
  result?: Maybe<FHIRGuidanceResponseresult_result_Union>,
  /** 
 * If the evaluation could not be completed due to lack of information, or
   * additional information would potentially result in a more accurate response,
   * this element will a description of the data required in order to proceed with
   * the evaluation. A subsequent request to the service should include this data.
 */
  dataRequirement?: Maybe<Array<Maybe<FHIRDataRequirement>>>,
};

export enum FHIRGuidanceResponse_Enum_schema {
  GuidanceResponse = 'GuidanceResponse'
}

/** The encounter during which this response was created or to which the creation of this record is tightly associated. */
export type FHIRGuidanceResponseencounter_encounter_Union = FHIREncounter;

/** 
 * Messages resulting from the evaluation of the artifact or artifacts. As part of
 * evaluating the request, the engine may produce informational or warning
 * messages. These messages will be provided by this element.
 */
export type FHIRGuidanceResponseevaluationMessage_evaluationMessage_Union = FHIROperationOutcome;

/** 
 * The output parameters of the evaluation, if any. Many modules will result in the
 * return of specific resources such as procedure or communication requests that
 * are returned as part of the operation result. However, modules may define
 * specific outputs that would be returned as the result of the evaluation, and
 * these would be returned in this element.
 */
export type FHIRGuidanceResponseoutputParameters_outputParameters_Union = FHIRParameters;

/** Provides a reference to the device that performed the guidance. */
export type FHIRGuidanceResponseperformer_performer_Union = FHIRDevice;

/** 
 * Indicates the reason the request was initiated. This is typically provided as a
 * parameter to the evaluation and echoed by the service, although for some use
 * cases, such as subscription- or event-based scenarios, it may provide an
 * indication of the cause for the response.
 */
export type FHIRGuidanceResponsereasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** The actions, if any, produced by the evaluation of the artifact. */
export type FHIRGuidanceResponseresult_result_Union = FHIRCarePlan | FHIRRequestGroup;

/** The patient for which the request was processed. */
export type FHIRGuidanceResponsesubject_subject_Union = FHIRPatient | FHIRGroup;

/** The details of a healthcare service available at a location. */
export type FHIRHealthcareService = {
   __typename?: 'FHIRHealthcareService',
  /** Type of resource */
  resourceType: FHIRHealthcareService_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** External identifiers for this item. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * This flag is used to mark the record to not be used. This is not used when a
   * center is closed for maintenance, or for holidays, the notAvailable period is
   * to be used for this.
 */
  active?: Maybe<Scalars['Boolean']>,
  /** The organization that provides this healthcare service. */
  providedBy?: Maybe<FHIRHealthcareServiceprovidedBy_providedBy_Union>,
  /** Identifies the broad category of service being performed or delivered. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specific type of service that may be delivered or performed. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Collection of specialties handled by the service site. This is more of a medical term. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The location(s) where this healthcare service may be provided. */
  location?: Maybe<Array<Maybe<FHIRHealthcareServicelocation_location_Union>>>,
  /** Further description of the service as it would be presented to a consumer while searching. */
  name?: Maybe<Scalars['String']>,
  /** 
 * Any additional description of the service and/or any specific issues not
   * covered by the other attributes, which can be displayed as further detail
   * under the serviceName.
 */
  comment?: Maybe<Scalars['String']>,
  /** Extra details about the service that can't be placed in the other fields. */
  extraDetails?: Maybe<Scalars['String']>,
  /** 
 * If there is a photo/symbol associated with this HealthcareService, it may be
   * included here to facilitate quick identification of the service in a list.
 */
  photo?: Maybe<FHIRAttachment>,
  /** List of contacts related to this specific healthcare service. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** The location(s) that this service is available to (not where the service is provided). */
  coverageArea?: Maybe<Array<Maybe<FHIRHealthcareServicecoverageArea_coverageArea_Union>>>,
  /** The code(s) that detail the conditions under which the healthcare service is available/offered. */
  serviceProvisionCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Does this service have specific eligibility requirements that need to be met in order to use the service? */
  eligibility?: Maybe<Array<Maybe<FHIRHealthcareServiceeligibility>>>,
  /** Programs that this service is applicable to. */
  program?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Collection of characteristics (attributes). */
  characteristic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Some services are specifically made available in multiple languages, this
   * property permits a directory to declare the languages this is offered in.
   * Typically this is only provided where a service operates in communities with
   * mixed languages used.
 */
  communication?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required. */
  referralMethod?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates whether or not a prospective consumer will require an appointment
   * for a particular service at a site to be provided by the Organization.
   * Indicates if an appointment is required for access to this service.
 */
  appointmentRequired?: Maybe<Scalars['Boolean']>,
  /** A collection of times that the Service Site is available. */
  availableTime?: Maybe<Array<Maybe<FHIRHealthcareServiceavailableTime>>>,
  /** The HealthcareService is not available during this period of time due to the provided reason. */
  notAvailable?: Maybe<Array<Maybe<FHIRHealthcareServicenotAvailable>>>,
  /** 
 * A description of site availability exceptions, e.g. public holiday
   * availability. Succinctly describing all possible exceptions to normal site
   * availability as details in the available Times and not available Times.
 */
  availabilityExceptions?: Maybe<Scalars['String']>,
  /** Technical endpoints providing access to services operated for the specific healthcare services defined at this resource. */
  endpoint?: Maybe<Array<Maybe<FHIRHealthcareServiceendpoint_endpoint_Union>>>,
};

export enum FHIRHealthcareService_Enum_schema {
  HealthcareService = 'HealthcareService'
}

export type FHIRHealthcareServiceavailableTime = {
   __typename?: 'FHIRHealthcareServiceavailableTime',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates which days of the week are available between the start and end Times. */
  daysOfWeek?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Is this always available? (hence times are irrelevant) e.g. 24 hour service. */
  allDay?: Maybe<Scalars['Boolean']>,
  /** The opening time of day. Note: If the AllDay flag is set, then this time is ignored. */
  availableStartTime?: Maybe<Scalars['FHIRTime']>,
  /** The closing time of day. Note: If the AllDay flag is set, then this time is ignored. */
  availableEndTime?: Maybe<Scalars['FHIRTime']>,
};

/** The location(s) that this service is available to (not where the service is provided). */
export type FHIRHealthcareServicecoverageArea_coverageArea_Union = FHIRLocation;

export type FHIRHealthcareServiceeligibility = {
   __typename?: 'FHIRHealthcareServiceeligibility',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Coded value for the eligibility. */
  code?: Maybe<FHIRCodeableConcept>,
  /** Describes the eligibility conditions for the service. */
  comment?: Maybe<Scalars['String']>,
};

/** Technical endpoints providing access to services operated for the specific healthcare services defined at this resource. */
export type FHIRHealthcareServiceendpoint_endpoint_Union = FHIREndpoint;

/** The location(s) where this healthcare service may be provided. */
export type FHIRHealthcareServicelocation_location_Union = FHIRLocation;

export type FHIRHealthcareServicenotAvailable = {
   __typename?: 'FHIRHealthcareServicenotAvailable',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The reason that can be presented to the user as to why this time is not available. */
  description: Scalars['String'],
  /** Service is not available (seasonally or for a public holiday) from this date. */
  during?: Maybe<FHIRPeriod>,
};

/** The organization that provides this healthcare service. */
export type FHIRHealthcareServiceprovidedBy_providedBy_Union = FHIROrganization;

/** Base StructureDefinition for HumanName Type: A human's name with the ability to identify parts and usage. */
export type FHIRHumanName = {
   __typename?: 'FHIRHumanName',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies the purpose for this name. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies the entire name as it should be displayed e.g. on an application UI.
   * This may be provided instead of or as well as the specific parts.
 */
  text?: Maybe<Scalars['String']>,
  /** 
 * The part of a name that links to the genealogy. In some cultures (e.g.
   * Eritrea) the family name of a son is the first name of his father.
 */
  family?: Maybe<Scalars['String']>,
  /** Given name. */
  given?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the start of the name.
 */
  prefix?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the end of the name.
 */
  suffix?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Indicates the period of time when this name was valid for the named person. */
  period?: Maybe<FHIRPeriod>,
};

/** Base StructureDefinition for HumanName Type: A human's name with the ability to identify parts and usage. */
export type FHIRHumanName_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Identifies the purpose for this name. */
  _use?: Maybe<FHIRElement_Input>,
  /** Identifies the purpose for this name. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Specifies the entire name as it should be displayed e.g. on an application UI.
   * This may be provided instead of or as well as the specific parts.
 */
  _text?: Maybe<FHIRElement_Input>,
  /** 
 * Specifies the entire name as it should be displayed e.g. on an application UI.
   * This may be provided instead of or as well as the specific parts.
 */
  text?: Maybe<Scalars['String']>,
  /** 
 * The part of a name that links to the genealogy. In some cultures (e.g.
   * Eritrea) the family name of a son is the first name of his father.
 */
  _family?: Maybe<FHIRElement_Input>,
  /** 
 * The part of a name that links to the genealogy. In some cultures (e.g.
   * Eritrea) the family name of a son is the first name of his father.
 */
  family?: Maybe<Scalars['String']>,
  /** Given name. */
  _given?: Maybe<FHIRElement_Input>,
  /** Given name. */
  given?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the start of the name.
 */
  _prefix?: Maybe<FHIRElement_Input>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the start of the name.
 */
  prefix?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the end of the name.
 */
  _suffix?: Maybe<FHIRElement_Input>,
  /** 
 * Part of the name that is acquired as a title due to academic, legal,
   * employment or nobility status, etc. and that appears at the end of the name.
 */
  suffix?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Indicates the period of time when this name was valid for the named person. */
  period?: Maybe<FHIRPeriod_Input>,
};


/** 
 * Base StructureDefinition for Identifier Type: An identifier - identifies some
 * entity uniquely and unambiguously. Typically this is used for business identifiers.
 */
export type FHIRIdentifier = {
   __typename?: 'FHIRIdentifier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The purpose of this identifier. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** A coded type for the identifier that can be used to determine which identifier to use for a specific purpose. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Establishes the namespace for the value - that is, a URL that describes a set values that are unique. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** The portion of the identifier typically relevant to the user and which is unique within the context of the system. */
  value?: Maybe<Scalars['String']>,
  /** Time period during which identifier is/was valid for use. */
  period?: Maybe<FHIRPeriod>,
  /** Organization that issued/manages the identifier. */
  assigner?: Maybe<FHIRIdentifierassigner_assigner_Union>,
};

/** 
 * Base StructureDefinition for Identifier Type: An identifier - identifies some
 * entity uniquely and unambiguously. Typically this is used for business identifiers.
 */
export type FHIRIdentifier_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The purpose of this identifier. */
  _use?: Maybe<FHIRElement_Input>,
  /** The purpose of this identifier. */
  use?: Maybe<Scalars['FHIRCode']>,
  /** A coded type for the identifier that can be used to determine which identifier to use for a specific purpose. */
  type?: Maybe<FHIRCodeableConcept_Input>,
  /** Establishes the namespace for the value - that is, a URL that describes a set values that are unique. */
  _system?: Maybe<FHIRElement_Input>,
  /** Establishes the namespace for the value - that is, a URL that describes a set values that are unique. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** The portion of the identifier typically relevant to the user and which is unique within the context of the system. */
  _value?: Maybe<FHIRElement_Input>,
  /** The portion of the identifier typically relevant to the user and which is unique within the context of the system. */
  value?: Maybe<Scalars['String']>,
  /** Time period during which identifier is/was valid for use. */
  period?: Maybe<FHIRPeriod_Input>,
  /** Organization that issued/manages the identifier. */
  assigner?: Maybe<Scalars['String']>,
};

/** Organization that issued/manages the identifier. */
export type FHIRIdentifierassigner_assigner_Union = FHIROrganization;

/** 
 * Representation of the content produced in a DICOM imaging study. A study
 * comprises a set of series, each of which includes a set of Service-Object Pair
 * Instances (SOP Instances - images or other data) acquired or produced in a
 * common context.  A series is of only one modality (e.g. X-ray, CT, MR,
 * ultrasound), but a study may have multiple series of different modalities.
 */
export type FHIRImagingStudy = {
   __typename?: 'FHIRImagingStudy',
  /** Type of resource */
  resourceType: FHIRImagingStudy_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers for the ImagingStudy such as DICOM Study Instance UID, and Accession Number. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The current state of the ImagingStudy. */
  status: Scalars['FHIRCode'],
  /** 
 * A list of all the series.modality values that are actual acquisition
   * modalities, i.e. those in the DICOM Context Group 29 (value set OID
   * 1.2.840.10008.6.1.19).
 */
  modality?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** The subject, typically a patient, of the imaging study. */
  subject: FHIRImagingStudysubject_subject_Union,
  /** The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made. */
  encounter?: Maybe<FHIRImagingStudyencounter_encounter_Union>,
  /** Date and time the study started. */
  started?: Maybe<Scalars['FHIRDateTime']>,
  /** A list of the diagnostic requests that resulted in this imaging study being performed. */
  basedOn?: Maybe<Array<Maybe<FHIRImagingStudybasedOn_basedOn_Union>>>,
  /** The requesting/referring physician. */
  referrer?: Maybe<FHIRImagingStudyreferrer_referrer_Union>,
  /** Who read the study and interpreted the images or other content. */
  interpreter?: Maybe<Array<Maybe<FHIRImagingStudyinterpreter_interpreter_Union>>>,
  /** 
 * The network service providing access (e.g., query, view, or retrieval) for the
   * study. See implementation notes for information about using DICOM endpoints. A
   * study-level endpoint applies to each series in the study, unless overridden by
   * a series-level endpoint with the same Endpoint.connectionType.
 */
  endpoint?: Maybe<Array<Maybe<FHIRImagingStudyendpoint_endpoint_Union>>>,
  /** 
 * Number of Series in the Study. This value given may be larger than the number
   * of series elements this Resource contains due to resource availability,
   * security, or other factors. This element should be present if any series
   * elements are present.
 */
  numberOfSeries?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * Number of SOP Instances in Study. This value given may be larger than the
   * number of instance elements this resource contains due to resource
   * availability, security, or other factors. This element should be present if
   * any instance elements are present.
 */
  numberOfInstances?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The procedure which this ImagingStudy was part of. */
  procedureReference?: Maybe<FHIRImagingStudyprocedureReference_procedureReference_Union>,
  /** The code for the performed procedure type. */
  procedureCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The principal physical location where the ImagingStudy was performed. */
  location?: Maybe<FHIRImagingStudylocation_location_Union>,
  /** Description of clinical condition indicating why the ImagingStudy was requested. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies this Study. */
  reasonReference?: Maybe<Array<Maybe<FHIRImagingStudyreasonReference_reasonReference_Union>>>,
  /** 
 * Per the recommended DICOM mapping, this element is derived from the Study
   * Description attribute (0008,1030). Observations or findings about the imaging
   * study should be recorded in another resource, e.g. Observation, and not in this element.
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The Imaging Manager description of the study. Institution-generated
   * description or classification of the Study (component) performed.
 */
  description?: Maybe<Scalars['String']>,
  /** Each study has one or more series of images or other content. */
  series?: Maybe<Array<Maybe<FHIRImagingStudyseries>>>,
};

export enum FHIRImagingStudy_Enum_schema {
  ImagingStudy = 'ImagingStudy'
}

/** A list of the diagnostic requests that resulted in this imaging study being performed. */
export type FHIRImagingStudybasedOn_basedOn_Union = FHIRCarePlan | FHIRServiceRequest | FHIRAppointment | FHIRAppointmentResponse | FHIRTask;

/** The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made. */
export type FHIRImagingStudyencounter_encounter_Union = FHIREncounter;

/** 
 * The network service providing access (e.g., query, view, or retrieval) for the
 * study. See implementation notes for information about using DICOM endpoints. A
 * study-level endpoint applies to each series in the study, unless overridden by a
 * series-level endpoint with the same Endpoint.connectionType.
 */
export type FHIRImagingStudyendpoint_endpoint_Union = FHIREndpoint;

/** Who read the study and interpreted the images or other content. */
export type FHIRImagingStudyinterpreter_interpreter_Union = FHIRPractitioner | FHIRPractitionerRole;

/** The principal physical location where the ImagingStudy was performed. */
export type FHIRImagingStudylocation_location_Union = FHIRLocation;

/** The procedure which this ImagingStudy was part of. */
export type FHIRImagingStudyprocedureReference_procedureReference_Union = FHIRProcedure;

/** Indicates another resource whose existence justifies this Study. */
export type FHIRImagingStudyreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRMedia | FHIRDiagnosticReport | FHIRDocumentReference;

/** The requesting/referring physician. */
export type FHIRImagingStudyreferrer_referrer_Union = FHIRPractitioner | FHIRPractitionerRole;

export type FHIRImagingStudyseries = {
   __typename?: 'FHIRImagingStudyseries',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The DICOM Series Instance UID for the series. */
  uid: Scalars['FHIRId'],
  /** The numeric identifier of this series in the study. */
  number?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The modality of this series sequence. */
  modality: FHIRCoding,
  /** A description of the series. */
  description?: Maybe<Scalars['String']>,
  /** 
 * Number of SOP Instances in the Study. The value given may be larger than the
   * number of instance elements this resource contains due to resource
   * availability, security, or other factors. This element should be present if
   * any instance elements are present.
 */
  numberOfInstances?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** 
 * The network service providing access (e.g., query, view, or retrieval) for
   * this series. See implementation notes for information about using DICOM
   * endpoints. A series-level endpoint, if present, has precedence over a
   * study-level endpoint with the same Endpoint.connectionType.
 */
  endpoint?: Maybe<Array<Maybe<FHIRImagingStudyseriesendpoint_endpoint_Union>>>,
  /** 
 * The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html)
   * for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of
   * body part imaged; if so, it shall be consistent with any content of
   * ImagingStudy.series.laterality.
 */
  bodySite?: Maybe<FHIRCoding>,
  /** 
 * The laterality of the (possibly paired) anatomic structures examined. E.g.,
   * the left knee, both lungs, or unpaired abdomen. If present, shall be
   * consistent with any laterality information indicated in
   * ImagingStudy.series.bodySite.
 */
  laterality?: Maybe<FHIRCoding>,
  /** The specimen imaged, e.g., for whole slide imaging of a biopsy. */
  specimen?: Maybe<Array<Maybe<FHIRImagingStudyseriesspecimen_specimen_Union>>>,
  /** The date and time the series was started. */
  started?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates who or what performed the series and how they were involved. */
  performer?: Maybe<Array<Maybe<FHIRImagingStudyseriesperformer>>>,
  /** A single SOP instance within the series, e.g. an image, or presentation state. */
  instance?: Maybe<Array<Maybe<FHIRImagingStudyseriesinstance>>>,
};

/** 
 * The network service providing access (e.g., query, view, or retrieval) for this
 * series. See implementation notes for information about using DICOM endpoints. A
 * series-level endpoint, if present, has precedence over a study-level endpoint
 * with the same Endpoint.connectionType.
 */
export type FHIRImagingStudyseriesendpoint_endpoint_Union = FHIREndpoint;

export type FHIRImagingStudyseriesinstance = {
   __typename?: 'FHIRImagingStudyseriesinstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The DICOM SOP Instance UID for this image or other DICOM content. */
  uid: Scalars['FHIRId'],
  /** DICOM instance  type. */
  sopClass: FHIRCoding,
  /** The number of instance in the series. */
  number?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The description of the instance. */
  title?: Maybe<Scalars['String']>,
};

export type FHIRImagingStudyseriesperformer = {
   __typename?: 'FHIRImagingStudyseriesperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Distinguishes the type of involvement of the performer in the series. */
  function?: Maybe<FHIRCodeableConcept>,
  /** Indicates who or what performed the series. */
  actor: FHIRImagingStudyseriesperformeractor_actor_Union,
};

/** Indicates who or what performed the series. */
export type FHIRImagingStudyseriesperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** The specimen imaged, e.g., for whole slide imaging of a biopsy. */
export type FHIRImagingStudyseriesspecimen_specimen_Union = FHIRSpecimen;

/** The subject, typically a patient, of the imaging study. */
export type FHIRImagingStudysubject_subject_Union = FHIRPatient | FHIRDevice | FHIRGroup;

/** 
 * Describes the event of a patient being administered a vaccine or a record of an
 * immunization as reported by a patient, a clinician or another party.
 */
export type FHIRImmunization = {
   __typename?: 'FHIRImmunization',
  /** Type of resource */
  resourceType: FHIRImmunization_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this immunization record. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the current status of the immunization event. */
  status: Scalars['FHIRCode'],
  /** Indicates the reason the immunization event was not performed. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** Vaccine that was administered or was to be administered. */
  vaccineCode: FHIRCodeableConcept,
  /** The patient who either received or did not receive the immunization. */
  patient: FHIRImmunizationpatient_patient_Union,
  /** 
 * The visit or admission or other contact between patient and health care
   * provider the immunization was performed as part of.
 */
  encounter?: Maybe<FHIRImmunizationencounter_encounter_Union>,
  /** Date vaccine administered or was to be administered. */
  occurrenceDateTime: Scalars['FHIRDateTime'],
  /** Date vaccine administered or was to be administered. */
  occurrenceString: Scalars['String'],
  /** 
 * The date the occurrence of the immunization was first captured in the record -
   * potentially significantly after the occurrence of the event.
 */
  recorded?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * An indication that the content of the record is based on information from the
   * person who administered the vaccine. This reflects the context under which the
   * data was originally recorded.
 */
  primarySource?: Maybe<Scalars['Boolean']>,
  /** 
 * The source of the data when the report of the immunization event is not based
   * on information from the person who administered the vaccine.
 */
  reportOrigin?: Maybe<FHIRCodeableConcept>,
  /** The service delivery location where the vaccine administration occurred. */
  location?: Maybe<FHIRImmunizationlocation_location_Union>,
  /** Name of vaccine manufacturer. */
  manufacturer?: Maybe<FHIRImmunizationmanufacturer_manufacturer_Union>,
  /** Lot number of the  vaccine product. */
  lotNumber?: Maybe<Scalars['String']>,
  /** Date vaccine batch expires. */
  expirationDate?: Maybe<Scalars['FHIRDate']>,
  /** Body site where vaccine was administered. */
  site?: Maybe<FHIRCodeableConcept>,
  /** The path by which the vaccine product is taken into the body. */
  route?: Maybe<FHIRCodeableConcept>,
  /** The quantity of vaccine product that was administered. */
  doseQuantity?: Maybe<FHIRQuantity>,
  /** Indicates who performed the immunization event. */
  performer?: Maybe<Array<Maybe<FHIRImmunizationperformer>>>,
  /** Extra information about the immunization that is not conveyed by the other attributes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Reasons why the vaccine was administered. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Condition, Observation or DiagnosticReport that supports why the immunization was administered. */
  reasonReference?: Maybe<Array<Maybe<FHIRImmunizationreasonReference_reasonReference_Union>>>,
  /** Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent. */
  isSubpotent?: Maybe<Scalars['Boolean']>,
  /** Reason why a dose is considered to be subpotent. */
  subpotentReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Educational material presented to the patient (or guardian) at the time of vaccine administration. */
  education?: Maybe<Array<Maybe<FHIRImmunizationeducation>>>,
  /** Indicates a patient's eligibility for a funding program. */
  programEligibility?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates the source of the vaccine actually administered. This may be
   * different than the patient eligibility (e.g. the patient may be eligible for a
   * publically purchased vaccine but due to inventory issues, vaccine purchased
   * with private funds was actually administered).
 */
  fundingSource?: Maybe<FHIRCodeableConcept>,
  /** Categorical data indicating that an adverse event is associated in time to an immunization. */
  reaction?: Maybe<Array<Maybe<FHIRImmunizationreaction>>>,
  /** The protocol (set of recommendations) being followed by the provider who administered the dose. */
  protocolApplied?: Maybe<Array<Maybe<FHIRImmunizationprotocolApplied>>>,
};

export enum FHIRImmunization_Enum_schema {
  Immunization = 'Immunization'
}

export type FHIRImmunizationeducation = {
   __typename?: 'FHIRImmunizationeducation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier of the material presented to the patient. */
  documentType?: Maybe<Scalars['String']>,
  /** Reference pointer to the educational material given to the patient if the information was on line. */
  reference?: Maybe<Scalars['FHIRUri']>,
  /** Date the educational material was published. */
  publicationDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Date the educational material was given to the patient. */
  presentationDate?: Maybe<Scalars['FHIRDateTime']>,
};

/** The visit or admission or other contact between patient and health care provider the immunization was performed as part of. */
export type FHIRImmunizationencounter_encounter_Union = FHIREncounter;

/** 
 * Describes a comparison of an immunization event against published
 * recommendations to determine if the administration is 'valid' in relation to
 * those  recommendations.
 */
export type FHIRImmunizationEvaluation = {
   __typename?: 'FHIRImmunizationEvaluation',
  /** Type of resource */
  resourceType: FHIRImmunizationEvaluation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this immunization evaluation record. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the current status of the evaluation of the vaccination administration event. */
  status: Scalars['FHIRCode'],
  /** The individual for whom the evaluation is being done. */
  patient: FHIRImmunizationEvaluationpatient_patient_Union,
  /** The date the evaluation of the vaccine administration event was performed. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates the authority who published the protocol (e.g. ACIP). */
  authority?: Maybe<FHIRImmunizationEvaluationauthority_authority_Union>,
  /** The vaccine preventable disease the dose is being evaluated against. */
  targetDisease: FHIRCodeableConcept,
  /** The vaccine administration event being evaluated. */
  immunizationEvent: FHIRImmunizationEvaluationimmunizationEvent_immunizationEvent_Union,
  /** Indicates if the dose is valid or not valid with respect to the published recommendations. */
  doseStatus: FHIRCodeableConcept,
  /** 
 * Provides an explanation as to why the vaccine administration event is valid or
   * not relative to the published recommendations.
 */
  doseStatusReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Additional information about the evaluation. */
  description?: Maybe<Scalars['String']>,
  /** One possible path to achieve presumed immunity against a disease - within the context of an authority. */
  series?: Maybe<Scalars['String']>,
  /** Nominal position in a series. */
  doseNumberPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Nominal position in a series. */
  doseNumberString?: Maybe<Scalars['String']>,
  /** The recommended number of doses to achieve immunity. */
  seriesDosesPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The recommended number of doses to achieve immunity. */
  seriesDosesString?: Maybe<Scalars['String']>,
};

export enum FHIRImmunizationEvaluation_Enum_schema {
  ImmunizationEvaluation = 'ImmunizationEvaluation'
}

/** Indicates the authority who published the protocol (e.g. ACIP). */
export type FHIRImmunizationEvaluationauthority_authority_Union = FHIROrganization;

/** The vaccine administration event being evaluated. */
export type FHIRImmunizationEvaluationimmunizationEvent_immunizationEvent_Union = FHIRImmunization;

/** The individual for whom the evaluation is being done. */
export type FHIRImmunizationEvaluationpatient_patient_Union = FHIRPatient;

/** The service delivery location where the vaccine administration occurred. */
export type FHIRImmunizationlocation_location_Union = FHIRLocation;

/** Name of vaccine manufacturer. */
export type FHIRImmunizationmanufacturer_manufacturer_Union = FHIROrganization;

/** The patient who either received or did not receive the immunization. */
export type FHIRImmunizationpatient_patient_Union = FHIRPatient;

export type FHIRImmunizationperformer = {
   __typename?: 'FHIRImmunizationperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Describes the type of performance (e.g. ordering provider, administering provider, etc.). */
  function?: Maybe<FHIRCodeableConcept>,
  /** The practitioner or organization who performed the action. */
  actor: FHIRImmunizationperformeractor_actor_Union,
};

/** The practitioner or organization who performed the action. */
export type FHIRImmunizationperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRImmunizationprotocolApplied = {
   __typename?: 'FHIRImmunizationprotocolApplied',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** One possible path to achieve presumed immunity against a disease - within the context of an authority. */
  series?: Maybe<Scalars['String']>,
  /** Indicates the authority who published the protocol (e.g. ACIP) that is being followed. */
  authority?: Maybe<FHIRImmunizationprotocolAppliedauthority_authority_Union>,
  /** The vaccine preventable disease the dose is being administered against. */
  targetDisease?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Nominal position in a series. */
  doseNumberPositiveInt: Scalars['FHIRPositiveInt'],
  /** Nominal position in a series. */
  doseNumberString: Scalars['String'],
  /** The recommended number of doses to achieve immunity. */
  seriesDosesPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The recommended number of doses to achieve immunity. */
  seriesDosesString?: Maybe<Scalars['String']>,
};

/** Indicates the authority who published the protocol (e.g. ACIP) that is being followed. */
export type FHIRImmunizationprotocolAppliedauthority_authority_Union = FHIROrganization;

export type FHIRImmunizationreaction = {
   __typename?: 'FHIRImmunizationreaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Date of reaction to the immunization. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Details of the reaction. */
  detail?: Maybe<FHIRImmunizationreactiondetail_detail_Union>,
  /** Self-reported indicator. */
  reported?: Maybe<Scalars['Boolean']>,
};

/** Details of the reaction. */
export type FHIRImmunizationreactiondetail_detail_Union = FHIRObservation;

/** Condition, Observation or DiagnosticReport that supports why the immunization was administered. */
export type FHIRImmunizationreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport;

/** 
 * A patient's point-in-time set of recommendations (i.e. forecasting) according to
 * a published schedule with optional supporting justification.
 */
export type FHIRImmunizationRecommendation = {
   __typename?: 'FHIRImmunizationRecommendation',
  /** Type of resource */
  resourceType: FHIRImmunizationRecommendation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this particular recommendation record. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The patient the recommendation(s) are for. */
  patient: FHIRImmunizationRecommendationpatient_patient_Union,
  /** The date the immunization recommendation(s) were created. */
  date: Scalars['FHIRDateTime'],
  /** Indicates the authority who published the protocol (e.g. ACIP). */
  authority?: Maybe<FHIRImmunizationRecommendationauthority_authority_Union>,
  /** Vaccine administration recommendations. */
  recommendation?: Maybe<Array<FHIRImmunizationRecommendationrecommendation>>,
};

export enum FHIRImmunizationRecommendation_Enum_schema {
  ImmunizationRecommendation = 'ImmunizationRecommendation'
}

/** Indicates the authority who published the protocol (e.g. ACIP). */
export type FHIRImmunizationRecommendationauthority_authority_Union = FHIROrganization;

/** The patient the recommendation(s) are for. */
export type FHIRImmunizationRecommendationpatient_patient_Union = FHIRPatient;

export type FHIRImmunizationRecommendationrecommendation = {
   __typename?: 'FHIRImmunizationRecommendationrecommendation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Vaccine(s) or vaccine group that pertain to the recommendation. */
  vaccineCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The targeted disease for the recommendation. */
  targetDisease?: Maybe<FHIRCodeableConcept>,
  /** Vaccine(s) which should not be used to fulfill the recommendation. */
  contraindicatedVaccineCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates the patient status with respect to the path to immunity for the target disease. */
  forecastStatus: FHIRCodeableConcept,
  /** The reason for the assigned forecast status. */
  forecastReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc. */
  dateCriterion?: Maybe<Array<Maybe<FHIRImmunizationRecommendationrecommendationdateCriterion>>>,
  /** Contains the description about the protocol under which the vaccine was administered. */
  description?: Maybe<Scalars['String']>,
  /** One possible path to achieve presumed immunity against a disease - within the context of an authority. */
  series?: Maybe<Scalars['String']>,
  /** Nominal position of the recommended dose in a series (e.g. dose 2 is the next recommended dose). */
  doseNumberPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Nominal position of the recommended dose in a series (e.g. dose 2 is the next recommended dose). */
  doseNumberString?: Maybe<Scalars['String']>,
  /** The recommended number of doses to achieve immunity. */
  seriesDosesPositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The recommended number of doses to achieve immunity. */
  seriesDosesString?: Maybe<Scalars['String']>,
  /** Immunization event history and/or evaluation that supports the status and recommendation. */
  supportingImmunization?: Maybe<Array<Maybe<FHIRImmunizationRecommendationrecommendationsupportingImmunization_supportingImmunization_Union>>>,
  /** 
 * Patient Information that supports the status and recommendation.  This
   * includes patient observations, adverse reactions and allergy/intolerance information.
 */
  supportingPatientInformation?: Maybe<Array<Maybe<FHIRImmunizationRecommendationrecommendationsupportingPatientInformation_supportingPatientInformation_Union>>>,
};

export type FHIRImmunizationRecommendationrecommendationdateCriterion = {
   __typename?: 'FHIRImmunizationRecommendationrecommendationdateCriterion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Date classification of recommendation.  For example, earliest date to give, latest date to give, etc. */
  code: FHIRCodeableConcept,
  /** The date whose meaning is specified by dateCriterion.code. */
  value: Scalars['FHIRDateTime'],
};

/** Immunization event history and/or evaluation that supports the status and recommendation. */
export type FHIRImmunizationRecommendationrecommendationsupportingImmunization_supportingImmunization_Union = FHIRImmunization | FHIRImmunizationEvaluation;

/** 
 * Patient Information that supports the status and recommendation.  This includes
 * patient observations, adverse reactions and allergy/intolerance information.
 */
export type FHIRImmunizationRecommendationrecommendationsupportingPatientInformation_supportingPatientInformation_Union = FHIRResource;

/** 
 * A set of rules of how a particular interoperability or standards problem is
 * solved - typically through the use of FHIR resources. This resource is used to
 * gather all the parts of an implementation guide into a logical whole and to
 * publish a computable definition of all the parts.
 */
export type FHIRImplementationGuide = {
   __typename?: 'FHIRImplementationGuide',
  /** Type of resource */
  resourceType: FHIRImplementationGuide_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this implementation guide when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this implementation
   * guide is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the implementation guide is stored on
   * different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * The identifier that is used to identify this version of the implementation
   * guide when it is referenced in a specification, model, design or instance.
   * This is an arbitrary value managed by the implementation guide author and is
   * not expected to be globally unique. For example, it might be a timestamp (e.g.
   * yyyymmdd) if a managed version is not available. There is also no expectation
   * that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the implementation guide. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name: Scalars['String'],
  /** A short, descriptive, user-friendly title for the implementation guide. */
  title?: Maybe<Scalars['String']>,
  /** The status of this implementation guide. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this implementation guide is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the implementation guide was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the implementation guide changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the implementation guide. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the implementation guide from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate
   * implementation guide instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the implementation guide is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the implementation guide and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the implementation guide.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The NPM package name for this Implementation Guide, used in the NPM package
   * distribution, which is the primary mechanism by which FHIR based tooling
   * manages IG dependencies. This value must be globally unique, and should be
   * assigned with care.
 */
  packageId: Scalars['FHIRId'],
  /** The license that applies to this Implementation Guide, using an SPDX license code, or 'not-open-source'. */
  license?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The version(s) of the FHIR specification that this ImplementationGuide targets
   * - e.g. describes how to use. The value of this element is the formal version
   * of the specification, without the revision number, e.g.
   * [publication].[major].[minor], which is 4.0.0. for this version.
 */
  fhirVersion?: Maybe<Array<Scalars['FHIRCode']>>,
  /** 
 * Another implementation guide that this implementation depends on. Typically,
   * an implementation guide uses value sets, profiles etc.defined in other
   * implementation guides.
 */
  dependsOn?: Maybe<Array<Maybe<FHIRImplementationGuidedependsOn>>>,
  /** A set of profiles that all resources covered by this implementation guide must conform to. */
  global?: Maybe<Array<Maybe<FHIRImplementationGuideglobal>>>,
  /** The information needed by an IG publisher tool to publish the whole implementation guide. */
  definition?: Maybe<FHIRImplementationGuidedefinition>,
  /** Information about an assembled implementation guide, created by the publication tooling. */
  manifest?: Maybe<FHIRImplementationGuidemanifest>,
};

export enum FHIRImplementationGuide_Enum_schema {
  ImplementationGuide = 'ImplementationGuide'
}

export type FHIRImplementationGuidedefinition = {
   __typename?: 'FHIRImplementationGuidedefinition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A logical group of resources. Logical groups can be used when building pages. */
  grouping?: Maybe<Array<Maybe<FHIRImplementationGuidedefinitiongrouping>>>,
  /** 
 * A resource that is part of the implementation guide. Conformance resources
   * (value set, structure definition, capability statements etc.) are obvious
   * candidates for inclusion, but any kind of resource can be included as an
   * example resource.
 */
  resource?: Maybe<Array<FHIRImplementationGuidedefinitionresource>>,
  /** A page / section in the implementation guide. The root page is the implementation guide home page. */
  page?: Maybe<FHIRImplementationGuidedefinitionpage>,
  /** Defines how IG is built by tools. */
  parameter?: Maybe<Array<Maybe<FHIRImplementationGuidedefinitionparameter>>>,
  /** A template for building resources. */
  template?: Maybe<Array<Maybe<FHIRImplementationGuidedefinitiontemplate>>>,
};

export type FHIRImplementationGuidedefinitiongrouping = {
   __typename?: 'FHIRImplementationGuidedefinitiongrouping',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The human-readable title to display for the package of resources when rendering the implementation guide. */
  name: Scalars['String'],
  /** Human readable text describing the package. */
  description?: Maybe<Scalars['String']>,
};

export type FHIRImplementationGuidedefinitionpage = {
   __typename?: 'FHIRImplementationGuidedefinitionpage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The source address for the page. */
  nameUrl: Scalars['FHIRUrl'],
  /** The source address for the page. */
  nameReference: FHIRImplementationGuidedefinitionpagenameReference_nameReference_Union,
  /** A short title used to represent this page in navigational structures such as table of contents, bread crumbs, etc. */
  title: Scalars['String'],
  /** A code that indicates how the page is generated. */
  generation: Scalars['FHIRCode'],
};

/** The source address for the page. */
export type FHIRImplementationGuidedefinitionpagenameReference_nameReference_Union = FHIRBinary;

export type FHIRImplementationGuidedefinitionparameter = {
   __typename?: 'FHIRImplementationGuidedefinitionparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * apply | path-resource | path-pages | path-tx-cache | expansion-parameter |
   * rule-broken-links | generate-xml | generate-json | generate-turtle | html-template.
 */
  code: Scalars['FHIRCode'],
  /** Value for named type. */
  value: Scalars['String'],
};

export type FHIRImplementationGuidedefinitionresource = {
   __typename?: 'FHIRImplementationGuidedefinitionresource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Where this resource is found. */
  reference: FHIRImplementationGuidedefinitionresourcereference_reference_Union,
  /** 
 * Indicates the FHIR Version(s) this artifact is intended to apply to. If no
   * versions are specified, the resource is assumed to apply to all the versions
   * stated in ImplementationGuide.fhirVersion.
 */
  fhirVersion?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * A human assigned name for the resource. All resources SHOULD have a name, but
   * the name may be extracted from the resource (e.g. ValueSet.name).
 */
  name?: Maybe<Scalars['String']>,
  /** A description of the reason that a resource has been included in the implementation guide. */
  description?: Maybe<Scalars['String']>,
  /** 
 * If true or a reference, indicates the resource is an example instance.  If a
   * reference is present, indicates that the example is an example of the
   * specified profile.
 */
  exampleBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * If true or a reference, indicates the resource is an example instance.  If a
   * reference is present, indicates that the example is an example of the
   * specified profile.
 */
  exampleCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** Reference to the id of the grouping this resource appears in. */
  groupingId?: Maybe<Scalars['FHIRId']>,
};

/** Where this resource is found. */
export type FHIRImplementationGuidedefinitionresourcereference_reference_Union = FHIRResource;

export type FHIRImplementationGuidedefinitiontemplate = {
   __typename?: 'FHIRImplementationGuidedefinitiontemplate',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of template specified. */
  code: Scalars['FHIRCode'],
  /** The source location for the template. */
  source: Scalars['String'],
  /** The scope in which the template applies. */
  scope?: Maybe<Scalars['String']>,
};

export type FHIRImplementationGuidedependsOn = {
   __typename?: 'FHIRImplementationGuidedependsOn',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A canonical reference to the Implementation guide for the dependency. */
  uri: Scalars['FHIRCanonical'],
  /** The NPM package name for the Implementation Guide that this IG depends on. */
  packageId?: Maybe<Scalars['FHIRId']>,
  /** The version of the IG that is depended on, when the correct version is required to understand the IG correctly. */
  version?: Maybe<Scalars['String']>,
};

export type FHIRImplementationGuideglobal = {
   __typename?: 'FHIRImplementationGuideglobal',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of resource that all instances must conform to. */
  type: Scalars['FHIRCode'],
  /** A reference to the profile that all instances must conform to. */
  profile: Scalars['FHIRCanonical'],
};

export type FHIRImplementationGuidemanifest = {
   __typename?: 'FHIRImplementationGuidemanifest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A pointer to official web page, PDF or other rendering of the implementation guide. */
  rendering?: Maybe<Scalars['FHIRUrl']>,
  /** 
 * A resource that is part of the implementation guide. Conformance resources
   * (value set, structure definition, capability statements etc.) are obvious
   * candidates for inclusion, but any kind of resource can be included as an
   * example resource.
 */
  resource?: Maybe<Array<FHIRImplementationGuidemanifestresource>>,
  /** Information about a page within the IG. */
  page?: Maybe<Array<Maybe<FHIRImplementationGuidemanifestpage>>>,
  /** Indicates a relative path to an image that exists within the IG. */
  image?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Indicates the relative path of an additional non-page, non-image file that is
   * part of the IG - e.g. zip, jar and similar files that could be the target of a
   * hyperlink in a derived IG.
 */
  other?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type FHIRImplementationGuidemanifestpage = {
   __typename?: 'FHIRImplementationGuidemanifestpage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Relative path to the page. */
  name: Scalars['String'],
  /** Label for the page intended for human display. */
  title?: Maybe<Scalars['String']>,
  /** The name of an anchor available on the page. */
  anchor?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type FHIRImplementationGuidemanifestresource = {
   __typename?: 'FHIRImplementationGuidemanifestresource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Where this resource is found. */
  reference: FHIRImplementationGuidemanifestresourcereference_reference_Union,
  /** 
 * If true or a reference, indicates the resource is an example instance.  If a
   * reference is present, indicates that the example is an example of the
   * specified profile.
 */
  exampleBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * If true or a reference, indicates the resource is an example instance.  If a
   * reference is present, indicates that the example is an example of the
   * specified profile.
 */
  exampleCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** The relative path for primary page for this resource within the IG. */
  relativePath?: Maybe<Scalars['FHIRUrl']>,
};

/** Where this resource is found. */
export type FHIRImplementationGuidemanifestresourcereference_reference_Union = FHIRResource;


/** Details of a Health Insurance product/plan provided by an organization. */
export type FHIRInsurancePlan = {
   __typename?: 'FHIRInsurancePlan',
  /** Type of resource */
  resourceType: FHIRInsurancePlan_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this health insurance product which remain
   * constant as the resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The current state of the health insurance product. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** The kind of health insurance product. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Official name of the health insurance product as designated by the owner. */
  name?: Maybe<Scalars['String']>,
  /** A list of alternate names that the product is known as, or was known as in the past. */
  alias?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The period of time that the health insurance product is available. */
  period?: Maybe<FHIRPeriod>,
  /** 
 * The entity that is providing  the health insurance product and underwriting
   * the risk.  This is typically an insurance carriers, other third-party payers,
   * or health plan sponsors comonly referred to as 'payers'.
 */
  ownedBy?: Maybe<FHIRInsurancePlanownedBy_ownedBy_Union>,
  /** 
 * An organization which administer other services such as underwriting, customer
   * service and/or claims processing on behalf of the health insurance product owner.
 */
  administeredBy?: Maybe<FHIRInsurancePlanadministeredBy_administeredBy_Union>,
  /** The geographic region in which a health insurance product's benefits apply. */
  coverageArea?: Maybe<Array<Maybe<FHIRInsurancePlancoverageArea_coverageArea_Union>>>,
  /** The contact for the health insurance product for a certain purpose. */
  contact?: Maybe<Array<Maybe<FHIRInsurancePlancontact>>>,
  /** The technical endpoints providing access to services operated for the health insurance product. */
  endpoint?: Maybe<Array<Maybe<FHIRInsurancePlanendpoint_endpoint_Union>>>,
  /** Reference to the network included in the health insurance product. */
  network?: Maybe<Array<Maybe<FHIRInsurancePlannetwork_network_Union>>>,
  /** Details about the coverage offered by the insurance product. */
  coverage?: Maybe<Array<Maybe<FHIRInsurancePlancoverage>>>,
  /** Details about an insurance plan. */
  plan?: Maybe<Array<Maybe<FHIRInsurancePlanplan>>>,
};

export enum FHIRInsurancePlan_Enum_schema {
  InsurancePlan = 'InsurancePlan'
}

/** 
 * An organization which administer other services such as underwriting, customer
 * service and/or claims processing on behalf of the health insurance product owner.
 */
export type FHIRInsurancePlanadministeredBy_administeredBy_Union = FHIROrganization;

export type FHIRInsurancePlancontact = {
   __typename?: 'FHIRInsurancePlancontact',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates a purpose for which the contact can be reached. */
  purpose?: Maybe<FHIRCodeableConcept>,
  /** A name associated with the contact. */
  name?: Maybe<FHIRHumanName>,
  /** A contact detail (e.g. a telephone number or an email address) by which the party may be contacted. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Visiting or postal addresses for the contact. */
  address?: Maybe<FHIRAddress>,
};

export type FHIRInsurancePlancoverage = {
   __typename?: 'FHIRInsurancePlancoverage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision;
   * Drug; Short Term; Long Term Care; Hospice; Home Health).
 */
  type: FHIRCodeableConcept,
  /** Reference to the network that providing the type of coverage. */
  network?: Maybe<Array<Maybe<FHIRInsurancePlancoveragenetwork_network_Union>>>,
  /** Specific benefits under this type of coverage. */
  benefit?: Maybe<Array<FHIRInsurancePlancoveragebenefit>>,
};

/** The geographic region in which a health insurance product's benefits apply. */
export type FHIRInsurancePlancoverageArea_coverageArea_Union = FHIRLocation;

export type FHIRInsurancePlancoveragebenefit = {
   __typename?: 'FHIRInsurancePlancoveragebenefit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of benefit (primary care; speciality care; inpatient; outpatient). */
  type: FHIRCodeableConcept,
  /** The referral requirements to have access/coverage for this benefit. */
  requirement?: Maybe<Scalars['String']>,
  /** The specific limits on the benefit. */
  limit?: Maybe<Array<Maybe<FHIRInsurancePlancoveragebenefitlimit>>>,
};

export type FHIRInsurancePlancoveragebenefitlimit = {
   __typename?: 'FHIRInsurancePlancoveragebenefitlimit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses. */
  value?: Maybe<FHIRQuantity>,
  /** The specific limit on the benefit. */
  code?: Maybe<FHIRCodeableConcept>,
};

/** Reference to the network that providing the type of coverage. */
export type FHIRInsurancePlancoveragenetwork_network_Union = FHIROrganization;

/** The technical endpoints providing access to services operated for the health insurance product. */
export type FHIRInsurancePlanendpoint_endpoint_Union = FHIREndpoint;

/** Reference to the network included in the health insurance product. */
export type FHIRInsurancePlannetwork_network_Union = FHIROrganization;

/** 
 * The entity that is providing  the health insurance product and underwriting the
 * risk.  This is typically an insurance carriers, other third-party payers, or
 * health plan sponsors comonly referred to as 'payers'.
 */
export type FHIRInsurancePlanownedBy_ownedBy_Union = FHIROrganization;

export type FHIRInsurancePlanplan = {
   __typename?: 'FHIRInsurancePlanplan',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this health insurance plan which remain
   * constant as the resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Type of plan. For example, 'Platinum' or 'High Deductable'. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The geographic region in which a health insurance plan's benefits apply. */
  coverageArea?: Maybe<Array<Maybe<FHIRInsurancePlanplancoverageArea_coverageArea_Union>>>,
  /** Reference to the network that providing the type of coverage. */
  network?: Maybe<Array<Maybe<FHIRInsurancePlanplannetwork_network_Union>>>,
  /** Overall costs associated with the plan. */
  generalCost?: Maybe<Array<Maybe<FHIRInsurancePlanplangeneralCost>>>,
  /** Costs associated with the coverage provided by the product. */
  specificCost?: Maybe<Array<Maybe<FHIRInsurancePlanplanspecificCost>>>,
};

/** The geographic region in which a health insurance plan's benefits apply. */
export type FHIRInsurancePlanplancoverageArea_coverageArea_Union = FHIRLocation;

export type FHIRInsurancePlanplangeneralCost = {
   __typename?: 'FHIRInsurancePlanplangeneralCost',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of cost. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Number of participants enrolled in the plan. */
  groupSize?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Value of the cost. */
  cost?: Maybe<FHIRMoney>,
  /** Additional information about the general costs associated with this plan. */
  comment?: Maybe<Scalars['String']>,
};

/** Reference to the network that providing the type of coverage. */
export type FHIRInsurancePlanplannetwork_network_Union = FHIROrganization;

export type FHIRInsurancePlanplanspecificCost = {
   __typename?: 'FHIRInsurancePlanplanspecificCost',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health). */
  category: FHIRCodeableConcept,
  /** List of the specific benefits under this category of benefit. */
  benefit?: Maybe<Array<Maybe<FHIRInsurancePlanplanspecificCostbenefit>>>,
};

export type FHIRInsurancePlanplanspecificCostbenefit = {
   __typename?: 'FHIRInsurancePlanplanspecificCostbenefit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Type of specific benefit (preventative; primary care office visit; speciality
   * office visit; hospitalization; emergency room; urgent care).
 */
  type: FHIRCodeableConcept,
  /** List of the costs associated with a specific benefit. */
  cost?: Maybe<Array<Maybe<FHIRInsurancePlanplanspecificCostbenefitcost>>>,
};

export type FHIRInsurancePlanplanspecificCostbenefitcost = {
   __typename?: 'FHIRInsurancePlanplanspecificCostbenefitcost',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of cost (copay; individual cap; family cap; coinsurance; deductible). */
  type: FHIRCodeableConcept,
  /** Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other). */
  applicability?: Maybe<FHIRCodeableConcept>,
  /** Additional information about the cost, such as information about funding sources (e.g. HSA, HRA, FSA, RRA). */
  qualifiers?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance). */
  value?: Maybe<FHIRQuantity>,
};

/** Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose. */
export type FHIRInvoice = {
   __typename?: 'FHIRInvoice',
  /** Type of resource */
  resourceType: FHIRInvoice_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier of this Invoice, often used for reference in correspondence about this invoice or for tracking of payments. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The current state of the Invoice. */
  status: Scalars['FHIRCode'],
  /** In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.). */
  cancelledReason?: Maybe<Scalars['String']>,
  /** Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary). */
  type?: Maybe<FHIRCodeableConcept>,
  /** The individual or set of individuals receiving the goods and services billed in this invoice. */
  subject?: Maybe<FHIRInvoicesubject_subject_Union>,
  /** The individual or Organization responsible for balancing of this invoice. */
  recipient?: Maybe<FHIRInvoicerecipient_recipient_Union>,
  /** Date/time(s) of when this Invoice was posted. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates who or what performed or participated in the charged service. */
  participant?: Maybe<Array<Maybe<FHIRInvoiceparticipant>>>,
  /** The organizationissuing the Invoice. */
  issuer?: Maybe<FHIRInvoiceissuer_issuer_Union>,
  /** Account which is supposed to be balanced with this Invoice. */
  account?: Maybe<FHIRInvoiceaccount_account_Union>,
  /** 
 * Each line item represents one charge for goods and services rendered. Details
   * such as date, code and amount are found in the referenced ChargeItem resource.
 */
  lineItem?: Maybe<Array<Maybe<FHIRInvoicelineItem>>>,
  /** Invoice total , taxes excluded. */
  totalNet?: Maybe<FHIRMoney>,
  /** Invoice total, tax included. */
  totalGross?: Maybe<FHIRMoney>,
  /** Payment details such as banking details, period of payment, deductibles, methods of payment. */
  paymentTerms?: Maybe<Scalars['String']>,
  /** Comments made about the invoice by the issuer, subject, or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRInvoice_Enum_schema {
  Invoice = 'Invoice'
}

/** Account which is supposed to be balanced with this Invoice. */
export type FHIRInvoiceaccount_account_Union = FHIRAccount;

/** The organizationissuing the Invoice. */
export type FHIRInvoiceissuer_issuer_Union = FHIROrganization;

export type FHIRInvoicelineItem = {
   __typename?: 'FHIRInvoicelineItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Sequence in which the items appear on the invoice. */
  sequence?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The ChargeItem contains information such as the billing code, date, amount
   * etc. If no further details are required for the lineItem, inline billing codes
   * can be added using the CodeableConcept data type instead of the Reference.
 */
  chargeItemReference: FHIRInvoicelineItemchargeItemReference_chargeItemReference_Union,
  /** 
 * The ChargeItem contains information such as the billing code, date, amount
   * etc. If no further details are required for the lineItem, inline billing codes
   * can be added using the CodeableConcept data type instead of the Reference.
 */
  chargeItemCodeableConcept: FHIRCodeableConcept,
  /** 
 * The price for a ChargeItem may be calculated as a base price with
   * surcharges/deductions that apply in certain conditions. A ChargeItemDefinition
   * resource that defines the prices, factors and conditions that apply to a
   * billing code is currently under development. The priceComponent element can be
   * used to offer transparency to the recipient of the Invoice as to how the
   * prices have been calculated.
 */
  priceComponent?: Maybe<Array<Maybe<FHIRInvoicelineItempriceComponent>>>,
};

/** 
 * The ChargeItem contains information such as the billing code, date, amount etc.
 * If no further details are required for the lineItem, inline billing codes can be
 * added using the CodeableConcept data type instead of the Reference.
 */
export type FHIRInvoicelineItemchargeItemReference_chargeItemReference_Union = FHIRChargeItem;

export type FHIRInvoicelineItempriceComponent = {
   __typename?: 'FHIRInvoicelineItempriceComponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** This code identifies the type of the component. */
  type: Scalars['FHIRCode'],
  /** 
 * A code that identifies the component. Codes may be used to differentiate
   * between kinds of taxes, surcharges, discounts etc.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The factor that has been applied on the base price for calculating this component. */
  factor?: Maybe<Scalars['Float']>,
  /** The amount calculated for this component. */
  amount?: Maybe<FHIRMoney>,
};

export type FHIRInvoiceparticipant = {
   __typename?: 'FHIRInvoiceparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Describes the type of involvement (e.g. transcriptionist, creator etc.). If
   * the invoice has been created automatically, the Participant may be a billing
   * engine or another kind of device.
 */
  role?: Maybe<FHIRCodeableConcept>,
  /** The device, practitioner, etc. who performed or participated in the service. */
  actor: FHIRInvoiceparticipantactor_actor_Union,
};

/** The device, practitioner, etc. who performed or participated in the service. */
export type FHIRInvoiceparticipantactor_actor_Union = FHIRPractitioner | FHIROrganization | FHIRPatient | FHIRPractitionerRole | FHIRDevice | FHIRRelatedPerson;

/** The individual or Organization responsible for balancing of this invoice. */
export type FHIRInvoicerecipient_recipient_Union = FHIROrganization | FHIRPatient | FHIRRelatedPerson;

/** The individual or set of individuals receiving the goods and services billed in this invoice. */
export type FHIRInvoicesubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * The Library resource is a general-purpose container for knowledge asset
 * definitions. It can be used to describe and expose existing knowledge assets
 * such as logic libraries and information model descriptions, as well as to
 * describe a collection of knowledge assets.
 */
export type FHIRLibrary = {
   __typename?: 'FHIRLibrary',
  /** Type of resource */
  resourceType: FHIRLibrary_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this library when it is referenced in
   * a specification, model, design or an instance; also called its canonical
   * identifier. This SHOULD be globally unique and SHOULD be a literal address at
   * which at which an authoritative instance of this library is (or will be)
   * published. This URL can be the target of a canonical reference. It SHALL
   * remain the same when the library is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this library when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance. e.g. CMS or NQF identifiers for a measure artifact. Note that
   * at least one identifier is required for non-experimental active artifacts.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the library when it is
   * referenced in a specification, model, design or instance. This is an arbitrary
   * value managed by the library author and is not expected to be globally unique.
   * For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
   * not available. There is also no expectation that versions can be placed in a
   * lexicographical sequence. To provide a version consistent with the Decision
   * Support Service specification, use the format Major.Minor.Revision (e.g.
   * 1.0.0). For more information on versioning knowledge assets, refer to the
   * Decision Support Service specification. Note that a version is required for
   * non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the library. This name should be usable as
   * an identifier for the module by machine processing applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the library. */
  title?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the library giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this library. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this library is authored for testing purposes
   * (or education/evaluation/marketing) and is not intended to be used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** Identifies the type of library such as a Logic Library, Model Definition, Asset Collection, or Module Definition. */
  type: FHIRCodeableConcept,
  /** A code or group definition that describes the intended subject of the contents of the library. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A code or group definition that describes the intended subject of the contents of the library. */
  subjectReference?: Maybe<FHIRLibrarysubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the library was published. The date must
   * change when the business version changes and it must change if the status code
   * changes. In addition, it should change when the substantive content of the
   * library changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the library. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the library from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate library instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the library is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this library is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description of how the library is used from a clinical perspective. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the library and/or its contents. Copyright
   * statements are generally legal restrictions on the use and publishing of the library.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the library content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the library. Topics provide a
   * high-level categorization of the library that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** The parameter element defines parameters used by the library. */
  parameter?: Maybe<Array<Maybe<FHIRParameterDefinition>>>,
  /** 
 * Describes a set of data that must be provided in order to be able to
   * successfully perform the computations defined by the library.
 */
  dataRequirement?: Maybe<Array<Maybe<FHIRDataRequirement>>>,
  /** 
 * The content of the library as an Attachment. The content may be a reference to
   * a url, or may be directly embedded as a base-64 string. Either way, the
   * contentType of the attachment determines how to interpret the content.
 */
  content?: Maybe<Array<Maybe<FHIRAttachment>>>,
};

export enum FHIRLibrary_Enum_schema {
  Library = 'Library'
}

/** A code or group definition that describes the intended subject of the contents of the library. */
export type FHIRLibrarysubjectReference_subjectReference_Union = FHIRGroup;

/** Identifies two or more records (resource instances) that refer to the same real-world 'occurrence'. */
export type FHIRLinkage = {
   __typename?: 'FHIRLinkage',
  /** Type of resource */
  resourceType: FHIRLinkage_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates whether the asserted set of linkages are considered to be 'in effect'. */
  active?: Maybe<Scalars['Boolean']>,
  /** 
 * Identifies the user or organization responsible for asserting the linkages as
   * well as the user or organization who establishes the context in which the
   * nature of each linkage is evaluated.
 */
  author?: Maybe<FHIRLinkageauthor_author_Union>,
  /** 
 * Identifies which record considered as the reference to the same real-world
   * occurrence as well as how the items should be evaluated within the collection
   * of linked items.
 */
  item?: Maybe<Array<FHIRLinkageitem>>,
};

export enum FHIRLinkage_Enum_schema {
  Linkage = 'Linkage'
}

/** 
 * Identifies the user or organization responsible for asserting the linkages as
 * well as the user or organization who establishes the context in which the nature
 * of each linkage is evaluated.
 */
export type FHIRLinkageauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRLinkageitem = {
   __typename?: 'FHIRLinkageitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Distinguishes which item is 'source of truth' (if any) and which items are no
   * longer considered to be current representations.
 */
  type: Scalars['FHIRCode'],
  /** The resource instance being linked as part of the group. */
  resource: FHIRLinkageitemresource_resource_Union,
};

/** The resource instance being linked as part of the group. */
export type FHIRLinkageitemresource_resource_Union = FHIRResource;

/** A list is a curated collection of resources. */
export type FHIRList = {
   __typename?: 'FHIRList',
  /** Type of resource */
  resourceType: FHIRList_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the List assigned for business purposes outside the context of FHIR. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Indicates the current state of this list. */
  status: Scalars['FHIRCode'],
  /** 
 * How this list was prepared - whether it is a working list that is suitable for
   * being maintained on an ongoing basis, or if it represents a snapshot of a list
   * of items from another source, or whether it is a prepared list where items may
   * be marked as added, modified or deleted.
 */
  mode: Scalars['FHIRCode'],
  /** A label for the list assigned by the author. */
  title?: Maybe<Scalars['String']>,
  /** This code defines the purpose of the list - why it was created. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The common subject (or patient) of the resources that are in the list if there is one. */
  subject?: Maybe<FHIRListsubject_subject_Union>,
  /** The encounter that is the context in which this list was created. */
  encounter?: Maybe<FHIRListencounter_encounter_Union>,
  /** The date that the list was prepared. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The entity responsible for deciding what the contents of the list were. Where
   * the list was created by a human, this is the same as the author of the list.
 */
  source?: Maybe<FHIRListsource_source_Union>,
  /** What order applies to the items in the list. */
  orderedBy?: Maybe<FHIRCodeableConcept>,
  /** Comments that apply to the overall list. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Entries in this list. */
  entry?: Maybe<Array<Maybe<FHIRListentry>>>,
  /** If the list is empty, why the list is empty. */
  emptyReason?: Maybe<FHIRCodeableConcept>,
};

export enum FHIRList_Enum_schema {
  List = 'List'
}

/** The encounter that is the context in which this list was created. */
export type FHIRListencounter_encounter_Union = FHIREncounter;

export type FHIRListentry = {
   __typename?: 'FHIRListentry',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The flag allows the system constructing the list to indicate the role and significance of the item in the list. */
  flag?: Maybe<FHIRCodeableConcept>,
  /** True if this item is marked as deleted in the list. */
  deleted?: Maybe<Scalars['Boolean']>,
  /** When this item was added to the list. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** A reference to the actual resource from which data was derived. */
  item: FHIRListentryitem_item_Union,
};

/** A reference to the actual resource from which data was derived. */
export type FHIRListentryitem_item_Union = FHIRResource;

export type FHIRListInfo = {
   __typename?: 'FHIRListInfo',
  totalCount?: Maybe<Scalars['Int']>,
  /** 
 * Pass the value of this as `after` to the relevant field in order to
   * fetch the next page of results.
 */
  nextPageToken?: Maybe<Scalars['String']>,
};

/** 
 * The entity responsible for deciding what the contents of the list were. Where
 * the list was created by a human, this is the same as the author of the list.
 */
export type FHIRListsource_source_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRDevice;

/** The common subject (or patient) of the resources that are in the list if there is one. */
export type FHIRListsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRDevice | FHIRLocation;

/** 
 * Details and position information for a physical place where services are
 * provided and resources and participants may be stored, found, contained, or accommodated.
 */
export type FHIRLocation = {
   __typename?: 'FHIRLocation',
  /** Type of resource */
  resourceType: FHIRLocation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique code or number identifying the location to its users. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The status property covers the general availability of the resource, not the
   * current value which may be covered by the operationStatus, or by a
   * schedule/slots if they are configured for the location.
 */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The operational status covers operation values most relevant to beds (but can
   * also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis
   * chair). This typically covers concepts such as contamination, housekeeping,
   * and other activities like maintenance.
 */
  operationalStatus?: Maybe<FHIRCoding>,
  /** Name of the location as used by humans. Does not need to be unique. */
  name?: Maybe<Scalars['String']>,
  /** A list of alternate names that the location is known as, or was known as, in the past. */
  alias?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Description of the Location, which helps in finding or referencing the place. */
  description?: Maybe<Scalars['String']>,
  /** Indicates whether a resource instance represents a specific location or a class of locations. */
  mode?: Maybe<Scalars['FHIRCode']>,
  /** Indicates the type of function performed at the location. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The contact details of communication devices available at the location. This
   * can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
 */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Physical location. */
  address?: Maybe<FHIRAddress>,
  /** Physical form of the location, e.g. building, room, vehicle, road. */
  physicalType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The absolute geographic location of the Location, expressed using the WGS84
   * datum (This is the same co-ordinate system used in KML).
 */
  position?: Maybe<FHIRLocationposition>,
  /** The organization responsible for the provisioning and upkeep of the location. */
  managingOrganization?: Maybe<FHIRLocationmanagingOrganization_managingOrganization_Union>,
  /** Another Location of which this Location is physically a part of. */
  partOf?: Maybe<FHIRLocationpartOf_partOf_Union>,
  /** What days/times during a week is this location usually open. */
  hoursOfOperation?: Maybe<Array<Maybe<FHIRLocationhoursOfOperation>>>,
  /** 
 * A description of when the locations opening ours are different to normal, e.g.
   * public holiday availability. Succinctly describing all possible exceptions to
   * normal site availability as detailed in the opening hours Times.
 */
  availabilityExceptions?: Maybe<Scalars['String']>,
  /** Technical endpoints providing access to services operated for the location. */
  endpoint?: Maybe<Array<Maybe<FHIRLocationendpoint_endpoint_Union>>>,
};

export enum FHIRLocation_Enum_schema {
  Location = 'Location'
}

/** Technical endpoints providing access to services operated for the location. */
export type FHIRLocationendpoint_endpoint_Union = FHIREndpoint;

export type FHIRLocationhoursOfOperation = {
   __typename?: 'FHIRLocationhoursOfOperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates which days of the week are available between the start and end Times. */
  daysOfWeek?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** The Location is open all day. */
  allDay?: Maybe<Scalars['Boolean']>,
  /** Time that the Location opens. */
  openingTime?: Maybe<Scalars['FHIRTime']>,
  /** Time that the Location closes. */
  closingTime?: Maybe<Scalars['FHIRTime']>,
};

/** The organization responsible for the provisioning and upkeep of the location. */
export type FHIRLocationmanagingOrganization_managingOrganization_Union = FHIROrganization;

/** Another Location of which this Location is physically a part of. */
export type FHIRLocationpartOf_partOf_Union = FHIRLocation;

export type FHIRLocationposition = {
   __typename?: 'FHIRLocationposition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Longitude. The value domain and the interpretation are the same as for the
   * text of the longitude element in KML (see notes below).
 */
  longitude: Scalars['Float'],
  /** 
 * Latitude. The value domain and the interpretation are the same as for the text
   * of the latitude element in KML (see notes below).
 */
  latitude: Scalars['Float'],
  /** 
 * Altitude. The value domain and the interpretation are the same as for the text
   * of the altitude element in KML (see notes below).
 */
  altitude?: Maybe<Scalars['Float']>,
};

/** 
 * Base StructureDefinition for MarketingStatus Type: The marketing status
 * describes the date when a medicinal product is actually put on the market or the
 * date as of which it is no longer available.
 */
export type FHIRMarketingStatus = {
   __typename?: 'FHIRMarketingStatus',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The country in which the marketing authorisation has been granted shall be
   * specified It should be specified using the ISO 3166 ‑ 1 alpha-2 code elements.
 */
  country: FHIRCodeableConcept,
  /** 
 * Where a Medicines Regulatory Agency has granted a marketing authorisation for
   * which specific provisions within a jurisdiction apply, the jurisdiction can be
   * specified using an appropriate controlled terminology The controlled term and
   * the controlled term identifier shall be specified.
 */
  jurisdiction?: Maybe<FHIRCodeableConcept>,
  /** 
 * This attribute provides information on the status of the marketing of the
   * medicinal product See ISO/TS 20443 for more information and examples.
 */
  status: FHIRCodeableConcept,
  /** 
 * The date when the Medicinal Product is placed on the market by the Marketing
   * Authorisation Holder (or where applicable, the manufacturer/distributor) in a
   * country and/or jurisdiction shall be provided A complete date consisting of
   * day, month and year shall be specified using the ISO 8601 date format NOTE
   * “Placed on the market” refers to the release of the Medicinal Product into the
   * distribution chain.
 */
  dateRange: FHIRPeriod,
  /** 
 * The date when the Medicinal Product is placed on the market by the Marketing
   * Authorisation Holder (or where applicable, the manufacturer/distributor) in a
   * country and/or jurisdiction shall be provided A complete date consisting of
   * day, month and year shall be specified using the ISO 8601 date format NOTE
   * “Placed on the market” refers to the release of the Medicinal Product into the
   * distribution chain.
 */
  restoreDate?: Maybe<Scalars['FHIRDateTime']>,
};

/** The Measure resource provides the definition of a quality measure. */
export type FHIRMeasure = {
   __typename?: 'FHIRMeasure',
  /** Type of resource */
  resourceType: FHIRMeasure_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this measure when it is referenced in
   * a specification, model, design or an instance; also called its canonical
   * identifier. This SHOULD be globally unique and SHOULD be a literal address at
   * which at which an authoritative instance of this measure is (or will be)
   * published. This URL can be the target of a canonical reference. It SHALL
   * remain the same when the measure is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this measure when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the measure when it is
   * referenced in a specification, model, design or instance. This is an arbitrary
   * value managed by the measure author and is not expected to be globally unique.
   * For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is
   * not available. There is also no expectation that versions can be placed in a
   * lexicographical sequence. To provide a version consistent with the Decision
   * Support Service specification, use the format Major.Minor.Revision (e.g.
   * 1.0.0). For more information on versioning knowledge assets, refer to the
   * Decision Support Service specification. Note that a version is required for
   * non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the measure. This name should be usable as
   * an identifier for the module by machine processing applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the measure. */
  title?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the measure giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this measure. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this measure is authored for testing purposes
   * (or education/evaluation/marketing) and is not intended to be used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The intended subjects for the measure. If this element is not provided, a
   * Patient subject is assumed, but the subject of the measure can be anything.
 */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * The intended subjects for the measure. If this element is not provided, a
   * Patient subject is assumed, but the subject of the measure can be anything.
 */
  subjectReference?: Maybe<FHIRMeasuresubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the measure was published. The date must
   * change when the business version changes and it must change if the status code
   * changes. In addition, it should change when the substantive content of the
   * measure changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the measure. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the measure from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate measure instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the measure is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this measure is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description, from a clinical perspective, of how the measure is used. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the measure and/or its contents. Copyright
   * statements are generally legal restrictions on the use and publishing of the measure.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the measure content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the measure. Topics provide a
   * high-level categorization grouping types of measures that can be useful for
   * filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a Library resource containing the formal logic used by the measure. */
  library?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Notices and disclaimers regarding the use of the measure or related to
   * intellectual property (such as code systems) referenced by the measure.
 */
  disclaimer?: Maybe<Scalars['String']>,
  /** 
 * Indicates how the calculation is performed for the measure, including
   * proportion, ratio, continuous-variable, and cohort. The value set is
   * extensible, allowing additional measure scoring types to be represented.
 */
  scoring?: Maybe<FHIRCodeableConcept>,
  /** 
 * If this is a composite measure, the scoring method used to combine the
   * component measures to determine the composite score.
 */
  compositeScoring?: Maybe<FHIRCodeableConcept>,
  /** 
 * Indicates whether the measure is used to examine a process, an outcome over
   * time, a patient-reported outcome, or a structure measure such as utilization.
 */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A description of the risk adjustment factors that may impact the resulting
   * score for the measure and how they may be accounted for when computing and
   * reporting measure results.
 */
  riskAdjustment?: Maybe<Scalars['String']>,
  /** 
 * Describes how to combine the information calculated, based on logic in each of
   * several populations, into one summarized result.
 */
  rateAggregation?: Maybe<Scalars['String']>,
  /** 
 * Provides a succinct statement of the need for the measure. Usually includes
   * statements pertaining to importance criterion: impact, gap in care, and evidence.
 */
  rationale?: Maybe<Scalars['String']>,
  /** Provides a summary of relevant clinical guidelines or other clinical recommendations supporting the measure. */
  clinicalRecommendationStatement?: Maybe<Scalars['String']>,
  /** 
 * Information on whether an increase or decrease in score is the preferred
   * result (e.g., a higher score indicates better quality OR a lower score
   * indicates better quality OR quality is within a range).
 */
  improvementNotation?: Maybe<FHIRCodeableConcept>,
  /** Provides a description of an individual term used within the measure. */
  definition?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Additional guidance for the measure including how it can be used in a clinical context, and the intent of the measure. */
  guidance?: Maybe<Scalars['String']>,
  /** A group of population criteria for the measure. */
  group?: Maybe<Array<Maybe<FHIRMeasuregroup>>>,
  /** 
 * The supplemental data criteria for the measure report, specified as either the
   * name of a valid CQL expression within a referenced library, or a valid FHIR Resource Path.
 */
  supplementalData?: Maybe<Array<Maybe<FHIRMeasuresupplementalData>>>,
};

export enum FHIRMeasure_Enum_schema {
  Measure = 'Measure'
}

export type FHIRMeasuregroup = {
   __typename?: 'FHIRMeasuregroup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates a meaning for the group. This can be as simple as a unique
   * identifier, or it can establish meaning in a broader context by drawing from a
   * terminology, allowing groups to be correlated across measures.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The human readable description of this population group. */
  description?: Maybe<Scalars['String']>,
  /** A population criteria for the measure. */
  population?: Maybe<Array<Maybe<FHIRMeasuregrouppopulation>>>,
  /** 
 * The stratifier criteria for the measure report, specified as either the name
   * of a valid CQL expression defined within a referenced library or a valid FHIR Resource Path.
 */
  stratifier?: Maybe<Array<Maybe<FHIRMeasuregroupstratifier>>>,
};

export type FHIRMeasuregrouppopulation = {
   __typename?: 'FHIRMeasuregrouppopulation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of population criteria. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The human readable description of this population criteria. */
  description?: Maybe<Scalars['String']>,
  /** An expression that specifies the criteria for the population, typically the name of an expression in a library. */
  criteria: FHIRExpression,
};

export type FHIRMeasuregroupstratifier = {
   __typename?: 'FHIRMeasuregroupstratifier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates a meaning for the stratifier. This can be as simple as a unique
   * identifier, or it can establish meaning in a broader context by drawing from a
   * terminology, allowing stratifiers to be correlated across measures.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The human readable description of this stratifier criteria. */
  description?: Maybe<Scalars['String']>,
  /** 
 * An expression that specifies the criteria for the stratifier. This is
   * typically the name of an expression defined within a referenced library, but
   * it may also be a path to a stratifier element.
 */
  criteria?: Maybe<FHIRExpression>,
  /** 
 * A component of the stratifier criteria for the measure report, specified as
   * either the name of a valid CQL expression defined within a referenced library
   * or a valid FHIR Resource Path.
 */
  component?: Maybe<Array<Maybe<FHIRMeasuregroupstratifiercomponent>>>,
};

export type FHIRMeasuregroupstratifiercomponent = {
   __typename?: 'FHIRMeasuregroupstratifiercomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates a meaning for the stratifier component. This can be as simple as a
   * unique identifier, or it can establish meaning in a broader context by drawing
   * from a terminology, allowing stratifiers to be correlated across measures.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The human readable description of this stratifier criteria component. */
  description?: Maybe<Scalars['String']>,
  /** 
 * An expression that specifies the criteria for this component of the
   * stratifier. This is typically the name of an expression defined within a
   * referenced library, but it may also be a path to a stratifier element.
 */
  criteria: FHIRExpression,
};

/** 
 * The MeasureReport resource contains the results of the calculation of a measure;
 * and optionally a reference to the resources involved in that calculation.
 */
export type FHIRMeasureReport = {
   __typename?: 'FHIRMeasureReport',
  /** Type of resource */
  resourceType: FHIRMeasureReport_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A formal identifier that is used to identify this MeasureReport when it is
   * represented in other formats or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The MeasureReport status. No data will be available until the MeasureReport status is complete. */
  status: Scalars['FHIRCode'],
  /** 
 * The type of measure report. This may be an individual report, which provides
   * the score for the measure for an individual member of the population; a
   * subject-listing, which returns the list of members that meet the various
   * criteria in the measure; a summary report, which returns a population count
   * for each of the criteria in the measure; or a data-collection, which enables
   * the MeasureReport to be used to exchange the data-of-interest for a quality measure.
 */
  type: Scalars['FHIRCode'],
  /** A reference to the Measure that was calculated to produce this report. */
  measure: Scalars['FHIRCanonical'],
  /** Optional subject identifying the individual or individuals the report is for. */
  subject?: Maybe<FHIRMeasureReportsubject_subject_Union>,
  /** The date this measure report was generated. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The individual, location, or organization that is reporting the data. */
  reporter?: Maybe<FHIRMeasureReportreporter_reporter_Union>,
  /** The reporting period for which the report was calculated. */
  period: FHIRPeriod,
  /** Whether improvement in the measure is noted by an increase or decrease in the measure score. */
  improvementNotation?: Maybe<FHIRCodeableConcept>,
  /** The results of the calculation, one for each population group in the measure. */
  group?: Maybe<Array<Maybe<FHIRMeasureReportgroup>>>,
  /** A reference to a Bundle containing the Resources that were used in the calculation of this measure. */
  evaluatedResource?: Maybe<Array<Maybe<FHIRMeasureReportevaluatedResource_evaluatedResource_Union>>>,
};

export enum FHIRMeasureReport_Enum_schema {
  MeasureReport = 'MeasureReport'
}

/** A reference to a Bundle containing the Resources that were used in the calculation of this measure. */
export type FHIRMeasureReportevaluatedResource_evaluatedResource_Union = FHIRResource;

export type FHIRMeasureReportgroup = {
   __typename?: 'FHIRMeasureReportgroup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The meaning of the population group as defined in the measure definition. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The populations that make up the population group, one for each type of population appropriate for the measure. */
  population?: Maybe<Array<Maybe<FHIRMeasureReportgrouppopulation>>>,
  /** 
 * The measure score for this population group, calculated as appropriate for the
   * measure type and scoring method, and based on the contents of the populations
   * defined in the group.
 */
  measureScore?: Maybe<FHIRQuantity>,
  /** When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure. */
  stratifier?: Maybe<Array<Maybe<FHIRMeasureReportgroupstratifier>>>,
};

export type FHIRMeasureReportgrouppopulation = {
   __typename?: 'FHIRMeasureReportgrouppopulation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of the population. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The number of members of the population. */
  count?: Maybe<Scalars['Int']>,
  /** This element refers to a List of subject level MeasureReport resources, one for each subject in this population. */
  subjectResults?: Maybe<FHIRMeasureReportgrouppopulationsubjectResults_subjectResults_Union>,
};

/** This element refers to a List of subject level MeasureReport resources, one for each subject in this population. */
export type FHIRMeasureReportgrouppopulationsubjectResults_subjectResults_Union = FHIRList;

export type FHIRMeasureReportgroupstratifier = {
   __typename?: 'FHIRMeasureReportgroupstratifier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The meaning of this stratifier, as defined in the measure definition. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * This element contains the results for a single stratum within the stratifier.
   * For example, when stratifying on administrative gender, there will be four
   * strata, one for each possible gender value.
 */
  stratum?: Maybe<Array<Maybe<FHIRMeasureReportgroupstratifierstratum>>>,
};

export type FHIRMeasureReportgroupstratifierstratum = {
   __typename?: 'FHIRMeasureReportgroupstratifierstratum',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The value for this stratum, expressed as a CodeableConcept. When defining
   * stratifiers on complex values, the value must be rendered such that the value
   * for each stratum within the stratifier is unique.
 */
  value?: Maybe<FHIRCodeableConcept>,
  /** A stratifier component value. */
  component?: Maybe<Array<Maybe<FHIRMeasureReportgroupstratifierstratumcomponent>>>,
  /** The populations that make up the stratum, one for each type of population appropriate to the measure. */
  population?: Maybe<Array<Maybe<FHIRMeasureReportgroupstratifierstratumpopulation>>>,
  /** 
 * The measure score for this stratum, calculated as appropriate for the measure
   * type and scoring method, and based on only the members of this stratum.
 */
  measureScore?: Maybe<FHIRQuantity>,
};

export type FHIRMeasureReportgroupstratifierstratumcomponent = {
   __typename?: 'FHIRMeasureReportgroupstratifierstratumcomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The code for the stratum component value. */
  code: FHIRCodeableConcept,
  /** The stratum component value. */
  value: FHIRCodeableConcept,
};

export type FHIRMeasureReportgroupstratifierstratumpopulation = {
   __typename?: 'FHIRMeasureReportgroupstratifierstratumpopulation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of the population. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The number of members of the population in this stratum. */
  count?: Maybe<Scalars['Int']>,
  /** 
 * This element refers to a List of subject level MeasureReport resources, one
   * for each subject in this population in this stratum.
 */
  subjectResults?: Maybe<FHIRMeasureReportgroupstratifierstratumpopulationsubjectResults_subjectResults_Union>,
};

/** 
 * This element refers to a List of subject level MeasureReport resources, one for
 * each subject in this population in this stratum.
 */
export type FHIRMeasureReportgroupstratifierstratumpopulationsubjectResults_subjectResults_Union = FHIRList;

/** The individual, location, or organization that is reporting the data. */
export type FHIRMeasureReportreporter_reporter_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRLocation | FHIROrganization;

/** Optional subject identifying the individual or individuals the report is for. */
export type FHIRMeasureReportsubject_subject_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRLocation | FHIRDevice | FHIRRelatedPerson | FHIRGroup;

/** 
 * The intended subjects for the measure. If this element is not provided, a
 * Patient subject is assumed, but the subject of the measure can be anything.
 */
export type FHIRMeasuresubjectReference_subjectReference_Union = FHIRGroup;

export type FHIRMeasuresupplementalData = {
   __typename?: 'FHIRMeasuresupplementalData',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates a meaning for the supplemental data. This can be as simple as a
   * unique identifier, or it can establish meaning in a broader context by drawing
   * from a terminology, allowing supplemental data to be correlated across measures.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * An indicator of the intended usage for the supplemental data element.
   * Supplemental data indicates the data is additional information requested to
   * augment the measure information. Risk adjustment factor indicates the data is
   * additional information used to calculate risk adjustment factors when applying
   * a risk model to the measure calculation.
 */
  usage?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The human readable description of this supplemental data. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The criteria for the supplemental data. This is typically the name of a valid
   * expression defined within a referenced library, but it may also be a path to a
   * specific data element. The criteria defines the data to be returned for this element.
 */
  criteria: FHIRExpression,
};

/** 
 * A photo, video, or audio recording acquired or used in healthcare. The actual
 * content may be inline or provided by direct reference.
 */
export type FHIRMedia = {
   __typename?: 'FHIRMedia',
  /** Type of resource */
  resourceType: FHIRMedia_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifiers associated with the image - these may include identifiers for the
   * image itself, identifiers for the context of its collection (e.g. series ids)
   * and context ids such as accession numbers or other workflow identifiers.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A procedure that is fulfilled in whole or in part by the creation of this media. */
  basedOn?: Maybe<Array<Maybe<FHIRMediabasedOn_basedOn_Union>>>,
  /** A larger event of which this particular event is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRMediapartOf_partOf_Union>>>,
  /** The current state of the {{title}}. */
  status: Scalars['FHIRCode'],
  /** A code that classifies whether the media is an image, video or audio recording or some other media category. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Details of the type of the media - usually, how it was acquired (what type of
   * device). If images sourced from a DICOM system, are wrapped in a Media
   * resource, then this is the modality.
 */
  modality?: Maybe<FHIRCodeableConcept>,
  /** The name of the imaging view e.g. Lateral or Antero-posterior (AP). */
  view?: Maybe<FHIRCodeableConcept>,
  /** Who/What this Media is a record of. */
  subject?: Maybe<FHIRMediasubject_subject_Union>,
  /** The encounter that establishes the context for this media. */
  encounter?: Maybe<FHIRMediaencounter_encounter_Union>,
  /** The date and time(s) at which the media was collected. */
  createdDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The date and time(s) at which the media was collected. */
  createdPeriod?: Maybe<FHIRPeriod>,
  /** The date and time this version of the media was made available to providers, typically after having been reviewed. */
  issued?: Maybe<Scalars['FHIRInstant']>,
  /** The person who administered the collection of the image. */
  operator?: Maybe<FHIRMediaoperator_operator_Union>,
  /** Describes why the event occurred in coded or textual form. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates the site on the subject's body where the observation was made (i.e. the target site). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** The name of the device / manufacturer of the device  that was used to make the recording. */
  deviceName?: Maybe<Scalars['String']>,
  /** The device used to collect the media. */
  device?: Maybe<FHIRMediadevice_device_Union>,
  /** Height of the image in pixels (photo/video). */
  height?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Width of the image in pixels (photo/video). */
  width?: Maybe<Scalars['FHIRPositiveInt']>,
  /** 
 * The number of frames in a photo. This is used with a multi-page fax, or an
   * imaging acquisition context that takes multiple slices in a single image, or
   * an animated gif. If there is more than one frame, this SHALL have a value in
   * order to alert interface software that a multi-frame capable rendering widget is required.
 */
  frames?: Maybe<Scalars['FHIRPositiveInt']>,
  /** The duration of the recording in seconds - for audio and video. */
  duration?: Maybe<Scalars['Float']>,
  /** The actual content of the media - inline or by direct reference to the media source file. */
  content: FHIRAttachment,
  /** Comments made about the media by the performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRMedia_Enum_schema {
  Media = 'Media'
}

/** A procedure that is fulfilled in whole or in part by the creation of this media. */
export type FHIRMediabasedOn_basedOn_Union = FHIRServiceRequest | FHIRCarePlan;

/** The device used to collect the media. */
export type FHIRMediadevice_device_Union = FHIRDevice | FHIRDeviceMetric;

/** The encounter that establishes the context for this media. */
export type FHIRMediaencounter_encounter_Union = FHIREncounter;

/** The person who administered the collection of the image. */
export type FHIRMediaoperator_operator_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** A larger event of which this particular event is a component or step. */
export type FHIRMediapartOf_partOf_Union = FHIRResource;

/** Who/What this Media is a record of. */
export type FHIRMediasubject_subject_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRGroup | FHIRDevice | FHIRSpecimen | FHIRLocation;

/** 
 * This resource is primarily used for the identification and definition of a
 * medication for the purposes of prescribing, dispensing, and administering a
 * medication as well as for making statements about medication use.
 */
export type FHIRMedication = {
   __typename?: 'FHIRMedication',
  /** Type of resource */
  resourceType: FHIRMedication_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifier for this medication. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * A code (or set of codes) that specify this medication, or a textual
   * description if no code is available. Usage note: This could be a standard
   * medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also
   * be a national or local formulary code, optionally with translations to other code systems.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** A code to indicate if the medication is in active use. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Describes the details of the manufacturer of the medication product.  This is
   * not intended to represent the distributor of a medication product.
 */
  manufacturer?: Maybe<FHIRMedicationmanufacturer_manufacturer_Union>,
  /** Describes the form of the item.  Powder; tablets; capsule. */
  form?: Maybe<FHIRCodeableConcept>,
  /** 
 * Specific amount of the drug in the packaged product.  For example, when
   * specifying a product that has the same strength (For example, Insulin glargine
   * 100 unit per mL solution for injection), this attribute provides additional
   * clarification of the package amount (For example, 3 mL, 10mL, etc.).
 */
  amount?: Maybe<FHIRRatio>,
  /** Identifies a particular constituent of interest in the product. */
  ingredient?: Maybe<Array<Maybe<FHIRMedicationingredient>>>,
  /** Information that only applies to packages (not products). */
  batch?: Maybe<FHIRMedicationbatch>,
};

export enum FHIRMedication_Enum_schema {
  Medication = 'Medication'
}

/** 
 * Describes the event of a patient consuming or otherwise being administered a
 * medication.  This may be as simple as swallowing a tablet or it may be a long
 * running infusion.  Related resources tie this event to the authorizing
 * prescription, and the specific encounter between patient and health care practitioner.
 */
export type FHIRMedicationAdministration = {
   __typename?: 'FHIRMedicationAdministration',
  /** Type of resource */
  resourceType: FHIRMedicationAdministration_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifiers associated with this Medication Administration that are defined by
   * business processes and/or used to refer to it when a direct URL reference to
   * the resource itself is not appropriate. They are business identifiers assigned
   * to this resource by the performer or other systems and remain constant as the
   * resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A protocol, guideline, orderset, or other definition that was adhered to in whole or in part by this event. */
  instantiates?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A larger event of which this particular event is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRMedicationAdministrationpartOf_partOf_Union>>>,
  /** 
 * Will generally be set to show that the administration has been completed.  For
   * some long running administrations such as infusions, it is possible for an
   * administration to be started but not completed or it may be paused while some
   * other process is under way.
 */
  status: Scalars['FHIRCode'],
  /** A code indicating why the administration was not performed. */
  statusReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates where the medication is expected to be consumed or administered. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * Identifies the medication that was administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Identifies the medication that was administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationReference: FHIRMedicationAdministrationmedicationReference_medicationReference_Union,
  /** The person or animal or group receiving the medication. */
  subject: FHIRMedicationAdministrationsubject_subject_Union,
  /** 
 * The visit, admission, or other contact between patient and health care
   * provider during which the medication administration was performed.
 */
  context?: Maybe<FHIRMedicationAdministrationcontext_context_Union>,
  /** Additional information (for example, patient height and weight) that supports the administration of the medication. */
  supportingInformation?: Maybe<Array<Maybe<FHIRMedicationAdministrationsupportingInformation_supportingInformation_Union>>>,
  /** 
 * A specific date/time or interval of time during which the administration took
   * place (or did not take place, when the 'notGiven' attribute is true). For many
   * administrations, such as swallowing a tablet the use of dateTime is more appropriate.
 */
  effectiveDateTime: Scalars['FHIRDateTime'],
  /** 
 * A specific date/time or interval of time during which the administration took
   * place (or did not take place, when the 'notGiven' attribute is true). For many
   * administrations, such as swallowing a tablet the use of dateTime is more appropriate.
 */
  effectivePeriod: FHIRPeriod,
  /** Indicates who or what performed the medication administration and how they were involved. */
  performer?: Maybe<Array<Maybe<FHIRMedicationAdministrationperformer>>>,
  /** A code indicating why the medication was given. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Condition or observation that supports why the medication was administered. */
  reasonReference?: Maybe<Array<Maybe<FHIRMedicationAdministrationreasonReference_reasonReference_Union>>>,
  /** The original request, instruction or authority to perform the administration. */
  request?: Maybe<FHIRMedicationAdministrationrequest_request_Union>,
  /** The device used in administering the medication to the patient.  For example, a particular infusion pump. */
  device?: Maybe<Array<Maybe<FHIRMedicationAdministrationdevice_device_Union>>>,
  /** Extra information about the medication administration that is not conveyed by the other attributes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Describes the medication dosage information details e.g. dose, rate, site, route, etc. */
  dosage?: Maybe<FHIRMedicationAdministrationdosage>,
  /** A summary of the events of interest that have occurred, such as when the administration was verified. */
  eventHistory?: Maybe<Array<Maybe<FHIRMedicationAdministrationeventHistory_eventHistory_Union>>>,
};

export enum FHIRMedicationAdministration_Enum_schema {
  MedicationAdministration = 'MedicationAdministration'
}

/** 
 * The visit, admission, or other contact between patient and health care provider
 * during which the medication administration was performed.
 */
export type FHIRMedicationAdministrationcontext_context_Union = FHIREncounter | FHIREpisodeOfCare;

/** The device used in administering the medication to the patient.  For example, a particular infusion pump. */
export type FHIRMedicationAdministrationdevice_device_Union = FHIRDevice;

export type FHIRMedicationAdministrationdosage = {
   __typename?: 'FHIRMedicationAdministrationdosage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Free text dosage can be used for cases where the dosage administered is too
   * complex to code. When coded dosage is present, the free text dosage may still
   * be present for display to humans.  The dosage instructions should reflect the
   * dosage of the medication that was administered.
 */
  text?: Maybe<Scalars['String']>,
  /** A coded specification of the anatomic site where the medication first entered the body.  For example, 'left arm'. */
  site?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code specifying the route or physiological path of administration of a
   * therapeutic agent into or onto the patient.  For example, topical,
   * intravenous, etc.
 */
  route?: Maybe<FHIRCodeableConcept>,
  /** 
 * A coded value indicating the method by which the medication is intended to be
   * or was introduced into or on the body.  This attribute will most often NOT be
   * populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
 */
  method?: Maybe<FHIRCodeableConcept>,
  /** 
 * The amount of the medication given at one administration event.   Use this
   * value when the administration is essentially an instantaneous event such as a
   * swallowing a tablet or giving an injection.
 */
  dose?: Maybe<FHIRQuantity>,
  /** 
 * Identifies the speed with which the medication was or will be introduced into
   * the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or
   * 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per
   * 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
 */
  rateRatio?: Maybe<FHIRRatio>,
  /** 
 * Identifies the speed with which the medication was or will be introduced into
   * the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or
   * 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per
   * 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
 */
  rateQuantity?: Maybe<FHIRQuantity>,
};

/** A summary of the events of interest that have occurred, such as when the administration was verified. */
export type FHIRMedicationAdministrationeventHistory_eventHistory_Union = FHIRProvenance;

/** 
 * Identifies the medication that was administered. This is either a link to a
 * resource representing the details of the medication or a simple attribute
 * carrying a code that identifies the medication from a known list of medications.
 */
export type FHIRMedicationAdministrationmedicationReference_medicationReference_Union = FHIRMedication;

/** A larger event of which this particular event is a component or step. */
export type FHIRMedicationAdministrationpartOf_partOf_Union = FHIRMedicationAdministration | FHIRProcedure;

export type FHIRMedicationAdministrationperformer = {
   __typename?: 'FHIRMedicationAdministrationperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Distinguishes the type of involvement of the performer in the medication administration. */
  function?: Maybe<FHIRCodeableConcept>,
  /** Indicates who or what performed the medication administration. */
  actor: FHIRMedicationAdministrationperformeractor_actor_Union,
};

/** Indicates who or what performed the medication administration. */
export type FHIRMedicationAdministrationperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** Condition or observation that supports why the medication was administered. */
export type FHIRMedicationAdministrationreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport;

/** The original request, instruction or authority to perform the administration. */
export type FHIRMedicationAdministrationrequest_request_Union = FHIRMedicationRequest;

/** The person or animal or group receiving the medication. */
export type FHIRMedicationAdministrationsubject_subject_Union = FHIRPatient | FHIRGroup;

/** Additional information (for example, patient height and weight) that supports the administration of the medication. */
export type FHIRMedicationAdministrationsupportingInformation_supportingInformation_Union = FHIRResource;

export type FHIRMedicationbatch = {
   __typename?: 'FHIRMedicationbatch',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The assigned lot number of a batch of the specified product. */
  lotNumber?: Maybe<Scalars['String']>,
  /** When this specific batch of product will expire. */
  expirationDate?: Maybe<Scalars['FHIRDateTime']>,
};

/** 
 * Indicates that a medication product is to be or has been dispensed for a named
 * person/patient.  This includes a description of the medication product (supply)
 * provided and the instructions for administering the medication.  The medication
 * dispense is the result of a pharmacy system responding to a medication order.
 */
export type FHIRMedicationDispense = {
   __typename?: 'FHIRMedicationDispense',
  /** Type of resource */
  resourceType: FHIRMedicationDispense_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifiers associated with this Medication Dispense that are defined by
   * business processes and/or used to refer to it when a direct URL reference to
   * the resource itself is not appropriate. They are business identifiers assigned
   * to this resource by the performer or other systems and remain constant as the
   * resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The procedure that trigger the dispense. */
  partOf?: Maybe<Array<Maybe<FHIRMedicationDispensepartOf_partOf_Union>>>,
  /** A code specifying the state of the set of dispense events. */
  status: Scalars['FHIRCode'],
  /** Indicates the reason why a dispense was not performed. */
  statusReasonCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Indicates the reason why a dispense was not performed. */
  statusReasonReference?: Maybe<FHIRMedicationDispensestatusReasonReference_statusReasonReference_Union>,
  /** 
 * Indicates the type of medication dispense (for example, where the medication
   * is expected to be consumed or administered (i.e. inpatient or outpatient)).
 */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * Identifies the medication being administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Identifies the medication being administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationReference: FHIRMedicationDispensemedicationReference_medicationReference_Union,
  /** A link to a resource representing the person or the group to whom the medication will be given. */
  subject?: Maybe<FHIRMedicationDispensesubject_subject_Union>,
  /** The encounter or episode of care that establishes the context for this event. */
  context?: Maybe<FHIRMedicationDispensecontext_context_Union>,
  /** Additional information that supports the medication being dispensed. */
  supportingInformation?: Maybe<Array<Maybe<FHIRMedicationDispensesupportingInformation_supportingInformation_Union>>>,
  /** Indicates who or what performed the event. */
  performer?: Maybe<Array<Maybe<FHIRMedicationDispenseperformer>>>,
  /** The principal physical location where the dispense was performed. */
  location?: Maybe<FHIRMedicationDispenselocation_location_Union>,
  /** Indicates the medication order that is being dispensed against. */
  authorizingPrescription?: Maybe<Array<Maybe<FHIRMedicationDispenseauthorizingPrescription_authorizingPrescription_Union>>>,
  /** 
 * Indicates the type of dispensing event that is performed. For example, Trial
   * Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The amount of medication that has been dispensed. Includes unit of measure. */
  quantity?: Maybe<FHIRQuantity>,
  /** The amount of medication expressed as a timing amount. */
  daysSupply?: Maybe<FHIRQuantity>,
  /** The time when the dispensed product was packaged and reviewed. */
  whenPrepared?: Maybe<Scalars['FHIRDateTime']>,
  /** The time the dispensed product was provided to the patient or their representative. */
  whenHandedOver?: Maybe<Scalars['FHIRDateTime']>,
  /** Identification of the facility/location where the medication was shipped to, as part of the dispense event. */
  destination?: Maybe<FHIRMedicationDispensedestination_destination_Union>,
  /** 
 * Identifies the person who picked up the medication.  This will usually be a
   * patient or their caregiver, but some cases exist where it can be a healthcare professional.
 */
  receiver?: Maybe<Array<Maybe<FHIRMedicationDispensereceiver_receiver_Union>>>,
  /** Extra information about the dispense that could not be conveyed in the other attributes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Indicates how the medication is to be used by the patient. */
  dosageInstruction?: Maybe<Array<Maybe<FHIRDosage>>>,
  /** 
 * Indicates whether or not substitution was made as part of the dispense.  In
   * some cases, substitution will be expected but does not happen, in other cases
   * substitution is not expected but does happen.  This block explains what
   * substitution did or did not happen and why.  If nothing is specified,
   * substitution was not done.
 */
  substitution?: Maybe<FHIRMedicationDispensesubstitution>,
  /** 
 * Indicates an actual or potential clinical issue with or between one or more
   * active or proposed clinical actions for a patient; e.g. drug-drug interaction,
   * duplicate therapy, dosage alert etc.
 */
  detectedIssue?: Maybe<Array<Maybe<FHIRMedicationDispensedetectedIssue_detectedIssue_Union>>>,
  /** A summary of the events of interest that have occurred, such as when the dispense was verified. */
  eventHistory?: Maybe<Array<Maybe<FHIRMedicationDispenseeventHistory_eventHistory_Union>>>,
};

export enum FHIRMedicationDispense_Enum_schema {
  MedicationDispense = 'MedicationDispense'
}

/** Indicates the medication order that is being dispensed against. */
export type FHIRMedicationDispenseauthorizingPrescription_authorizingPrescription_Union = FHIRMedicationRequest;

/** The encounter or episode of care that establishes the context for this event. */
export type FHIRMedicationDispensecontext_context_Union = FHIREncounter | FHIREpisodeOfCare;

/** Identification of the facility/location where the medication was shipped to, as part of the dispense event. */
export type FHIRMedicationDispensedestination_destination_Union = FHIRLocation;

/** 
 * Indicates an actual or potential clinical issue with or between one or more
 * active or proposed clinical actions for a patient; e.g. drug-drug interaction,
 * duplicate therapy, dosage alert etc.
 */
export type FHIRMedicationDispensedetectedIssue_detectedIssue_Union = FHIRDetectedIssue;

/** A summary of the events of interest that have occurred, such as when the dispense was verified. */
export type FHIRMedicationDispenseeventHistory_eventHistory_Union = FHIRProvenance;

/** The principal physical location where the dispense was performed. */
export type FHIRMedicationDispenselocation_location_Union = FHIRLocation;

/** 
 * Identifies the medication being administered. This is either a link to a
 * resource representing the details of the medication or a simple attribute
 * carrying a code that identifies the medication from a known list of medications.
 */
export type FHIRMedicationDispensemedicationReference_medicationReference_Union = FHIRMedication;

/** The procedure that trigger the dispense. */
export type FHIRMedicationDispensepartOf_partOf_Union = FHIRProcedure;

export type FHIRMedicationDispenseperformer = {
   __typename?: 'FHIRMedicationDispenseperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Distinguishes the type of performer in the dispense.  For example, date enterer, packager, final checker. */
  function?: Maybe<FHIRCodeableConcept>,
  /** 
 * The device, practitioner, etc. who performed the action.  It should be assumed
   * that the actor is the dispenser of the medication.
 */
  actor: FHIRMedicationDispenseperformeractor_actor_Union,
};

/** 
 * The device, practitioner, etc. who performed the action.  It should be assumed
 * that the actor is the dispenser of the medication.
 */
export type FHIRMedicationDispenseperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** 
 * Identifies the person who picked up the medication.  This will usually be a
 * patient or their caregiver, but some cases exist where it can be a healthcare professional.
 */
export type FHIRMedicationDispensereceiver_receiver_Union = FHIRPatient | FHIRPractitioner;

/** Indicates the reason why a dispense was not performed. */
export type FHIRMedicationDispensestatusReasonReference_statusReasonReference_Union = FHIRDetectedIssue;

/** A link to a resource representing the person or the group to whom the medication will be given. */
export type FHIRMedicationDispensesubject_subject_Union = FHIRPatient | FHIRGroup;

export type FHIRMedicationDispensesubstitution = {
   __typename?: 'FHIRMedicationDispensesubstitution',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** True if the dispenser dispensed a different drug or product from what was prescribed. */
  wasSubstituted: Scalars['Boolean'],
  /** A code signifying whether a different drug was dispensed from what was prescribed. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Indicates the reason for the substitution (or lack of substitution) from what was prescribed. */
  reason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The person or organization that has primary responsibility for the substitution. */
  responsibleParty?: Maybe<Array<Maybe<FHIRMedicationDispensesubstitutionresponsibleParty_responsibleParty_Union>>>,
};

/** The person or organization that has primary responsibility for the substitution. */
export type FHIRMedicationDispensesubstitutionresponsibleParty_responsibleParty_Union = FHIRPractitioner | FHIRPractitionerRole;

/** Additional information that supports the medication being dispensed. */
export type FHIRMedicationDispensesupportingInformation_supportingInformation_Union = FHIRResource;

export type FHIRMedicationingredient = {
   __typename?: 'FHIRMedicationingredient',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The actual ingredient - either a substance (simple ingredient) or another medication of a medication. */
  itemCodeableConcept: FHIRCodeableConcept,
  /** The actual ingredient - either a substance (simple ingredient) or another medication of a medication. */
  itemReference: FHIRMedicationingredientitemReference_itemReference_Union,
  /** Indication of whether this ingredient affects the therapeutic action of the drug. */
  isActive?: Maybe<Scalars['Boolean']>,
  /** 
 * Specifies how many (or how much) of the items there are in this Medication. 
   * For example, 250 mg per tablet.  This is expressed as a ratio where the
   * numerator is 250mg and the denominator is 1 tablet.
 */
  strength?: Maybe<FHIRRatio>,
};

/** The actual ingredient - either a substance (simple ingredient) or another medication of a medication. */
export type FHIRMedicationingredientitemReference_itemReference_Union = FHIRSubstance | FHIRMedication;

/** Information about a medication that is used to support knowledge. */
export type FHIRMedicationKnowledge = {
   __typename?: 'FHIRMedicationKnowledge',
  /** Type of resource */
  resourceType: FHIRMedicationKnowledge_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code that specifies this medication, or a textual description if no code is
   * available. Usage note: This could be a standard medication code such as a code
   * from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local
   * formulary code, optionally with translations to other code systems.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * A code to indicate if the medication is in active use.  The status refers to
   * the validity about the information of the medication and not to its medicinal properties.
 */
  status?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Describes the details of the manufacturer of the medication product.  This is
   * not intended to represent the distributor of a medication product.
 */
  manufacturer?: Maybe<FHIRMedicationKnowledgemanufacturer_manufacturer_Union>,
  /** Describes the form of the item.  Powder; tablets; capsule. */
  doseForm?: Maybe<FHIRCodeableConcept>,
  /** 
 * Specific amount of the drug in the packaged product.  For example, when
   * specifying a product that has the same strength (For example, Insulin glargine
   * 100 unit per mL solution for injection), this attribute provides additional
   * clarification of the package amount (For example, 3 mL, 10mL, etc.).
 */
  amount?: Maybe<FHIRQuantity>,
  /** 
 * Additional names for a medication, for example, the name(s) given to a
   * medication in different countries.  For example, acetaminophen and paracetamol
   * or salbutamol and albuterol.
 */
  synonym?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Associated or related knowledge about a medication. */
  relatedMedicationKnowledge?: Maybe<Array<Maybe<FHIRMedicationKnowledgerelatedMedicationKnowledge>>>,
  /** 
 * Associated or related medications.  For example, if the medication is a
   * branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g.
   * Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this
   * would link to a branded product (e.g. Crestor).
 */
  associatedMedication?: Maybe<Array<Maybe<FHIRMedicationKnowledgeassociatedMedication_associatedMedication_Union>>>,
  /** 
 * Category of the medication or product (e.g. branded product, therapeutic
   * moeity, generic product, innovator product, etc.).
 */
  productType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Associated documentation about the medication. */
  monograph?: Maybe<Array<Maybe<FHIRMedicationKnowledgemonograph>>>,
  /** Identifies a particular constituent of interest in the product. */
  ingredient?: Maybe<Array<Maybe<FHIRMedicationKnowledgeingredient>>>,
  /** The instructions for preparing the medication. */
  preparationInstruction?: Maybe<Scalars['String']>,
  /** The intended or approved route of administration. */
  intendedRoute?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The price of the medication. */
  cost?: Maybe<Array<Maybe<FHIRMedicationKnowledgecost>>>,
  /** The program under which the medication is reviewed. */
  monitoringProgram?: Maybe<Array<Maybe<FHIRMedicationKnowledgemonitoringProgram>>>,
  /** Guidelines for the administration of the medication. */
  administrationGuidelines?: Maybe<Array<Maybe<FHIRMedicationKnowledgeadministrationGuidelines>>>,
  /** Categorization of the medication within a formulary or classification system. */
  medicineClassification?: Maybe<Array<Maybe<FHIRMedicationKnowledgemedicineClassification>>>,
  /** Information that only applies to packages (not products). */
  packaging?: Maybe<FHIRMedicationKnowledgepackaging>,
  /** Specifies descriptive properties of the medicine, such as color, shape, imprints, etc. */
  drugCharacteristic?: Maybe<Array<Maybe<FHIRMedicationKnowledgedrugCharacteristic>>>,
  /** 
 * Potential clinical issue with or between medication(s) (for example, drug-drug
   * interaction, drug-disease contraindication, drug-allergy interaction, etc.).
 */
  contraindication?: Maybe<Array<Maybe<FHIRMedicationKnowledgecontraindication_contraindication_Union>>>,
  /** Regulatory information about a medication. */
  regulatory?: Maybe<Array<Maybe<FHIRMedicationKnowledgeregulatory>>>,
  /** The time course of drug absorption, distribution, metabolism and excretion of a medication from the body. */
  kinetics?: Maybe<Array<Maybe<FHIRMedicationKnowledgekinetics>>>,
};

export enum FHIRMedicationKnowledge_Enum_schema {
  MedicationKnowledge = 'MedicationKnowledge'
}

export type FHIRMedicationKnowledgeadministrationGuidelines = {
   __typename?: 'FHIRMedicationKnowledgeadministrationGuidelines',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Dosage for the medication for the specific guidelines. */
  dosage?: Maybe<Array<Maybe<FHIRMedicationKnowledgeadministrationGuidelinesdosage>>>,
  /** Indication for use that apply to the specific administration guidelines. */
  indicationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Indication for use that apply to the specific administration guidelines. */
  indicationReference?: Maybe<FHIRMedicationKnowledgeadministrationGuidelinesindicationReference_indicationReference_Union>,
  /** 
 * Characteristics of the patient that are relevant to the administration
   * guidelines (for example, height, weight, gender, etc.).
 */
  patientCharacteristics?: Maybe<Array<Maybe<FHIRMedicationKnowledgeadministrationGuidelinespatientCharacteristics>>>,
};

export type FHIRMedicationKnowledgeadministrationGuidelinesdosage = {
   __typename?: 'FHIRMedicationKnowledgeadministrationGuidelinesdosage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of dosage (for example, prophylaxis, maintenance, therapeutic, etc.). */
  type: FHIRCodeableConcept,
  /** Dosage for the medication for the specific guidelines. */
  dosage?: Maybe<Array<FHIRDosage>>,
};

/** Indication for use that apply to the specific administration guidelines. */
export type FHIRMedicationKnowledgeadministrationGuidelinesindicationReference_indicationReference_Union = FHIRObservationDefinition;

export type FHIRMedicationKnowledgeadministrationGuidelinespatientCharacteristics = {
   __typename?: 'FHIRMedicationKnowledgeadministrationGuidelinespatientCharacteristics',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). */
  characteristicCodeableConcept: FHIRCodeableConcept,
  /** Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). */
  characteristicQuantity: FHIRQuantity,
  /** The specific characteristic (e.g. height, weight, gender, etc.). */
  value?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** 
 * Associated or related medications.  For example, if the medication is a branded
 * product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if
 * this is a generic medication (e.g. Rosuvastatin), this would link to a branded
 * product (e.g. Crestor).
 */
export type FHIRMedicationKnowledgeassociatedMedication_associatedMedication_Union = FHIRMedication;

/** 
 * Potential clinical issue with or between medication(s) (for example, drug-drug
 * interaction, drug-disease contraindication, drug-allergy interaction, etc.).
 */
export type FHIRMedicationKnowledgecontraindication_contraindication_Union = FHIRDetectedIssue;

export type FHIRMedicationKnowledgecost = {
   __typename?: 'FHIRMedicationKnowledgecost',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The category of the cost information.  For example, manufacturers' cost,
   * patient cost, claim reimbursement cost, actual acquisition cost.
 */
  type: FHIRCodeableConcept,
  /** The source or owner that assigns the price to the medication. */
  source?: Maybe<Scalars['String']>,
  /** The price of the medication. */
  cost: FHIRMoney,
};

export type FHIRMedicationKnowledgedrugCharacteristic = {
   __typename?: 'FHIRMedicationKnowledgedrugCharacteristic',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint). */
  type?: Maybe<FHIRCodeableConcept>,
  /** Description of the characteristic. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Description of the characteristic. */
  valueString?: Maybe<Scalars['String']>,
  /** Description of the characteristic. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** Description of the characteristic. */
  valueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
};

export type FHIRMedicationKnowledgeingredient = {
   __typename?: 'FHIRMedicationKnowledgeingredient',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The actual ingredient - either a substance (simple ingredient) or another medication. */
  itemCodeableConcept: FHIRCodeableConcept,
  /** The actual ingredient - either a substance (simple ingredient) or another medication. */
  itemReference: FHIRMedicationKnowledgeingredientitemReference_itemReference_Union,
  /** Indication of whether this ingredient affects the therapeutic action of the drug. */
  isActive?: Maybe<Scalars['Boolean']>,
  /** 
 * Specifies how many (or how much) of the items there are in this Medication. 
   * For example, 250 mg per tablet.  This is expressed as a ratio where the
   * numerator is 250mg and the denominator is 1 tablet.
 */
  strength?: Maybe<FHIRRatio>,
};

/** The actual ingredient - either a substance (simple ingredient) or another medication. */
export type FHIRMedicationKnowledgeingredientitemReference_itemReference_Union = FHIRSubstance;

export type FHIRMedicationKnowledgekinetics = {
   __typename?: 'FHIRMedicationKnowledgekinetics',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The drug concentration measured at certain discrete points in time. */
  areaUnderCurve?: Maybe<Array<Maybe<FHIRQuantity>>>,
  /** The median lethal dose of a drug. */
  lethalDose50?: Maybe<Array<Maybe<FHIRQuantity>>>,
  /** The time required for any specified property (e.g., the concentration of a substance in the body) to decrease by half. */
  halfLifePeriod?: Maybe<FHIRDuration>,
};

/** 
 * Describes the details of the manufacturer of the medication product.  This is
 * not intended to represent the distributor of a medication product.
 */
export type FHIRMedicationKnowledgemanufacturer_manufacturer_Union = FHIROrganization;

export type FHIRMedicationKnowledgemedicineClassification = {
   __typename?: 'FHIRMedicationKnowledgemedicineClassification',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification). */
  type: FHIRCodeableConcept,
  /** Specific category assigned to the medication (e.g. anti-infective, anti-hypertensive, antibiotic, etc.). */
  classification?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export type FHIRMedicationKnowledgemonitoringProgram = {
   __typename?: 'FHIRMedicationKnowledgemonitoringProgram',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of program under which the medication is monitored. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Name of the reviewing program. */
  name?: Maybe<Scalars['String']>,
};

export type FHIRMedicationKnowledgemonograph = {
   __typename?: 'FHIRMedicationKnowledgemonograph',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The category of documentation about the medication. (e.g. professional monograph, patient education monograph). */
  type?: Maybe<FHIRCodeableConcept>,
  /** Associated documentation about the medication. */
  source?: Maybe<FHIRMedicationKnowledgemonographsource_source_Union>,
};

/** Associated documentation about the medication. */
export type FHIRMedicationKnowledgemonographsource_source_Union = FHIRDocumentReference | FHIRMedia;

export type FHIRMedicationKnowledgepackaging = {
   __typename?: 'FHIRMedicationKnowledgepackaging',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A code that defines the specific type of packaging that the medication can be
   * found in (e.g. blister sleeve, tube, bottle).
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The number of product units the package would contain if fully loaded. */
  quantity?: Maybe<FHIRQuantity>,
};

export type FHIRMedicationKnowledgeregulatory = {
   __typename?: 'FHIRMedicationKnowledgeregulatory',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The authority that is specifying the regulations. */
  regulatoryAuthority: FHIRMedicationKnowledgeregulatoryregulatoryAuthority_regulatoryAuthority_Union,
  /** Specifies if changes are allowed when dispensing a medication from a regulatory perspective. */
  substitution?: Maybe<Array<Maybe<FHIRMedicationKnowledgeregulatorysubstitution>>>,
  /** Specifies the schedule of a medication in jurisdiction. */
  schedule?: Maybe<Array<Maybe<FHIRMedicationKnowledgeregulatoryschedule>>>,
  /** The maximum number of units of the medication that can be dispensed in a period. */
  maxDispense?: Maybe<FHIRMedicationKnowledgeregulatorymaxDispense>,
};

export type FHIRMedicationKnowledgeregulatorymaxDispense = {
   __typename?: 'FHIRMedicationKnowledgeregulatorymaxDispense',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The maximum number of units of the medication that can be dispensed. */
  quantity: FHIRQuantity,
  /** The period that applies to the maximum number of units. */
  period?: Maybe<FHIRDuration>,
};

/** The authority that is specifying the regulations. */
export type FHIRMedicationKnowledgeregulatoryregulatoryAuthority_regulatoryAuthority_Union = FHIROrganization;

export type FHIRMedicationKnowledgeregulatoryschedule = {
   __typename?: 'FHIRMedicationKnowledgeregulatoryschedule',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specifies the specific drug schedule. */
  schedule: FHIRCodeableConcept,
};

export type FHIRMedicationKnowledgeregulatorysubstitution = {
   __typename?: 'FHIRMedicationKnowledgeregulatorysubstitution',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specifies the type of substitution allowed. */
  type: FHIRCodeableConcept,
  /** Specifies if regulation allows for changes in the medication when dispensing. */
  allowed: Scalars['Boolean'],
};

export type FHIRMedicationKnowledgerelatedMedicationKnowledge = {
   __typename?: 'FHIRMedicationKnowledgerelatedMedicationKnowledge',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The category of the associated medication knowledge reference. */
  type: FHIRCodeableConcept,
  /** Associated documentation about the associated medication knowledge. */
  reference?: Maybe<Array<FHIRMedicationKnowledgerelatedMedicationKnowledgereference_reference_Union>>,
};

/** Associated documentation about the associated medication knowledge. */
export type FHIRMedicationKnowledgerelatedMedicationKnowledgereference_reference_Union = FHIRMedicationKnowledge;

/** 
 * Describes the details of the manufacturer of the medication product.  This is
 * not intended to represent the distributor of a medication product.
 */
export type FHIRMedicationmanufacturer_manufacturer_Union = FHIROrganization;

/** 
 * An order or request for both supply of the medication and the instructions for
 * administration of the medication to a patient. The resource is called
 * 'MedicationRequest' rather than 'MedicationPrescription' or 'MedicationOrder' to
 * generalize the use across inpatient and outpatient settings, including care
 * plans, etc., and to harmonize with workflow patterns.
 */
export type FHIRMedicationRequest = {
   __typename?: 'FHIRMedicationRequest',
  /** Type of resource */
  resourceType: FHIRMedicationRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifiers associated with this medication request that are defined by
   * business processes and/or used to refer to it when a direct URL reference to
   * the resource itself is not appropriate. They are business identifiers assigned
   * to this resource by the performer or other systems and remain constant as the
   * resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A code specifying the current state of the order.  Generally, this will be active or completed state. */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the MedicationRequest. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** Whether the request is a proposal, plan, or an original order. */
  intent: Scalars['FHIRCode'],
  /** 
 * Indicates the type of medication request (for example, where the medication is
   * expected to be consumed or administered (i.e. inpatient or outpatient)).
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates how quickly the Medication Request should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** If true indicates that the provider is asking for the medication request not to occur. */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** 
 * Indicates if this record was captured as a secondary 'reported' record rather
   * than as an original primary source-of-truth record.  It may also indicate the
   * source of the report.
 */
  reportedBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * Indicates if this record was captured as a secondary 'reported' record rather
   * than as an original primary source-of-truth record.  It may also indicate the
   * source of the report.
 */
  reportedReference?: Maybe<FHIRMedicationRequestreportedReference_reportedReference_Union>,
  /** 
 * Identifies the medication being requested. This is a link to a resource that
   * represents the medication which may be the details of the medication or simply
   * an attribute carrying a code that identifies the medication from a known list
   * of medications.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Identifies the medication being requested. This is a link to a resource that
   * represents the medication which may be the details of the medication or simply
   * an attribute carrying a code that identifies the medication from a known list
   * of medications.
 */
  medicationReference: FHIRMedicationRequestmedicationReference_medicationReference_Union,
  /** A link to a resource representing the person or set of individuals to whom the medication will be given. */
  subject: FHIRMedicationRequestsubject_subject_Union,
  /** The Encounter during which this [x] was created or to which the creation of this record is tightly associated. */
  encounter?: Maybe<FHIRMedicationRequestencounter_encounter_Union>,
  /** Include additional information (for example, patient height and weight) that supports the ordering of the medication. */
  supportingInformation?: Maybe<Array<Maybe<FHIRMedicationRequestsupportingInformation_supportingInformation_Union>>>,
  /** The date (and perhaps time) when the prescription was initially written or authored on. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The individual, organization, or device that initiated the request and has responsibility for its activation. */
  requester?: Maybe<FHIRMedicationRequestrequester_requester_Union>,
  /** The specified desired performer of the medication treatment (e.g. the performer of the medication administration). */
  performer?: Maybe<FHIRMedicationRequestperformer_performer_Union>,
  /** Indicates the type of performer of the administration of the medication. */
  performerType?: Maybe<FHIRCodeableConcept>,
  /** The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order. */
  recorder?: Maybe<FHIRMedicationRequestrecorder_recorder_Union>,
  /** The reason or the indication for ordering or not ordering the medication. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Condition or observation that supports why the medication was ordered. */
  reasonReference?: Maybe<Array<Maybe<FHIRMedicationRequestreasonReference_reasonReference_Union>>>,
  /** 
 * The URL pointing to a protocol, guideline, orderset, or other definition that
   * is adhered to in whole or in part by this MedicationRequest.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * MedicationRequest.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A plan or request that is fulfilled in whole or in part by this medication request. */
  basedOn?: Maybe<Array<Maybe<FHIRMedicationRequestbasedOn_basedOn_Union>>>,
  /** 
 * A shared identifier common to all requests that were authorized more or less
   * simultaneously by a single author, representing the identifier of the
   * requisition or prescription.
 */
  groupIdentifier?: Maybe<FHIRIdentifier>,
  /** The description of the overall patte3rn of the administration of the medication to the patient. */
  courseOfTherapyType?: Maybe<FHIRCodeableConcept>,
  /** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
   * pre-determinations that may be required for delivering the requested service.
 */
  insurance?: Maybe<Array<Maybe<FHIRMedicationRequestinsurance_insurance_Union>>>,
  /** Extra information about the prescription that could not be conveyed by the other attributes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Indicates how the medication is to be used by the patient. */
  dosageInstruction?: Maybe<Array<Maybe<FHIRDosage>>>,
  /** 
 * Indicates the specific details for the dispense or medication supply part of a
   * medication request (also known as a Medication Prescription or Medication
   * Order).  Note that this information is not always sent with the order.  There
   * may be in some settings (e.g. hospitals) institutional or system support for
   * completing the dispense details in the pharmacy department.
 */
  dispenseRequest?: Maybe<FHIRMedicationRequestdispenseRequest>,
  /** 
 * Indicates whether or not substitution can or should be part of the dispense.
   * In some cases, substitution must happen, in other cases substitution must not
   * happen. This block explains the prescriber's intent. If nothing is specified
   * substitution may be done.
 */
  substitution?: Maybe<FHIRMedicationRequestsubstitution>,
  /** A link to a resource representing an earlier order related order or prescription. */
  priorPrescription?: Maybe<FHIRMedicationRequestpriorPrescription_priorPrescription_Union>,
  /** 
 * Indicates an actual or potential clinical issue with or between one or more
   * active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
   * duplicate therapy, dosage alert etc.
 */
  detectedIssue?: Maybe<Array<Maybe<FHIRMedicationRequestdetectedIssue_detectedIssue_Union>>>,
  /** 
 * Links to Provenance records for past versions of this resource or fulfilling
   * request or event resources that identify key state transitions or updates that
   * are likely to be relevant to a user looking at the current version of the resource.
 */
  eventHistory?: Maybe<Array<Maybe<FHIRMedicationRequesteventHistory_eventHistory_Union>>>,
};

export enum FHIRMedicationRequest_Enum_schema {
  MedicationRequest = 'MedicationRequest'
}

/** A plan or request that is fulfilled in whole or in part by this medication request. */
export type FHIRMedicationRequestbasedOn_basedOn_Union = FHIRCarePlan | FHIRMedicationRequest | FHIRServiceRequest | FHIRImmunizationRecommendation;

/** 
 * Indicates an actual or potential clinical issue with or between one or more
 * active or proposed clinical actions for a patient; e.g. Drug-drug interaction,
 * duplicate therapy, dosage alert etc.
 */
export type FHIRMedicationRequestdetectedIssue_detectedIssue_Union = FHIRDetectedIssue;

export type FHIRMedicationRequestdispenseRequest = {
   __typename?: 'FHIRMedicationRequestdispenseRequest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates the quantity or duration for the first dispense of the medication. */
  initialFill?: Maybe<FHIRMedicationRequestdispenseRequestinitialFill>,
  /** The minimum period of time that must occur between dispenses of the medication. */
  dispenseInterval?: Maybe<FHIRDuration>,
  /** This indicates the validity period of a prescription (stale dating the Prescription). */
  validityPeriod?: Maybe<FHIRPeriod>,
  /** 
 * An integer indicating the number of times, in addition to the original
   * dispense, (aka refills or repeats) that the patient can receive the prescribed
   * medication. Usage Notes: This integer does not include the original order
   * dispense. This means that if an order indicates dispense 30 tablets plus '3
   * repeats', then the order can be dispensed a total of 4 times and the patient
   * can receive a total of 120 tablets.  A prescriber may explicitly say that zero
   * refills are permitted after the initial dispense.
 */
  numberOfRepeatsAllowed?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** The amount that is to be dispensed for one fill. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * Identifies the period time over which the supplied product is expected to be
   * used, or the length of time the dispense is expected to last.
 */
  expectedSupplyDuration?: Maybe<FHIRDuration>,
  /** Indicates the intended dispensing Organization specified by the prescriber. */
  performer?: Maybe<FHIRMedicationRequestdispenseRequestperformer_performer_Union>,
};

export type FHIRMedicationRequestdispenseRequestinitialFill = {
   __typename?: 'FHIRMedicationRequestdispenseRequestinitialFill',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The amount or quantity to provide as part of the first dispense. */
  quantity?: Maybe<FHIRQuantity>,
  /** The length of time that the first dispense is expected to last. */
  duration?: Maybe<FHIRDuration>,
};

/** Indicates the intended dispensing Organization specified by the prescriber. */
export type FHIRMedicationRequestdispenseRequestperformer_performer_Union = FHIROrganization;

/** The Encounter during which this [x] was created or to which the creation of this record is tightly associated. */
export type FHIRMedicationRequestencounter_encounter_Union = FHIREncounter;

/** 
 * Links to Provenance records for past versions of this resource or fulfilling
 * request or event resources that identify key state transitions or updates that
 * are likely to be relevant to a user looking at the current version of the resource.
 */
export type FHIRMedicationRequesteventHistory_eventHistory_Union = FHIRProvenance;

/** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
 * pre-determinations that may be required for delivering the requested service.
 */
export type FHIRMedicationRequestinsurance_insurance_Union = FHIRCoverage | FHIRClaimResponse;

/** 
 * Identifies the medication being requested. This is a link to a resource that
 * represents the medication which may be the details of the medication or simply
 * an attribute carrying a code that identifies the medication from a known list of medications.
 */
export type FHIRMedicationRequestmedicationReference_medicationReference_Union = FHIRMedication;

/** The specified desired performer of the medication treatment (e.g. the performer of the medication administration). */
export type FHIRMedicationRequestperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRDevice | FHIRRelatedPerson | FHIRCareTeam;

/** A link to a resource representing an earlier order related order or prescription. */
export type FHIRMedicationRequestpriorPrescription_priorPrescription_Union = FHIRMedicationRequest;

/** Condition or observation that supports why the medication was ordered. */
export type FHIRMedicationRequestreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation;

/** The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order. */
export type FHIRMedicationRequestrecorder_recorder_Union = FHIRPractitioner | FHIRPractitionerRole;

/** 
 * Indicates if this record was captured as a secondary 'reported' record rather
 * than as an original primary source-of-truth record.  It may also indicate the
 * source of the report.
 */
export type FHIRMedicationRequestreportedReference_reportedReference_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIROrganization;

/** The individual, organization, or device that initiated the request and has responsibility for its activation. */
export type FHIRMedicationRequestrequester_requester_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** A link to a resource representing the person or set of individuals to whom the medication will be given. */
export type FHIRMedicationRequestsubject_subject_Union = FHIRPatient | FHIRGroup;

export type FHIRMedicationRequestsubstitution = {
   __typename?: 'FHIRMedicationRequestsubstitution',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** True if the prescriber allows a different drug to be dispensed from what was prescribed. */
  allowedBoolean: Scalars['Boolean'],
  /** True if the prescriber allows a different drug to be dispensed from what was prescribed. */
  allowedCodeableConcept: FHIRCodeableConcept,
  /** Indicates the reason for the substitution, or why substitution must or must not be performed. */
  reason?: Maybe<FHIRCodeableConcept>,
};

/** Include additional information (for example, patient height and weight) that supports the ordering of the medication. */
export type FHIRMedicationRequestsupportingInformation_supportingInformation_Union = FHIRResource;

/** 
 * A record of a medication that is being consumed by a patient.   A
 * MedicationStatement may indicate that the patient may be taking the medication
 * now or has taken the medication in the past or will be taking the medication in
 * the future.  The source of this information can be the patient, significant
 * other (such as a family member or spouse), or a clinician.  A common scenario
 * where this information is captured is during the history taking process during a
 * patient visit or stay.   The medication information may come from sources such
 * as the patient's memory, from a prescription bottle,  or from a list of
 * medications the patient, clinician or other party maintains.   The primary
 * difference between a medication statement and a medication administration is
 * that the medication administration has complete administration information and
 * is based on actual administration information from the person who administered
 * the medication.  A medication statement is often, if not always, less specific. 
 * There is no required date/time when the medication was administered, in fact we
 * only know that a source has reported the patient is taking this medication,
 * where details such as time, quantity, or rate or even medication product may be
 * incomplete or missing or less precise.  As stated earlier, the medication
 * statement information may come from the patient's memory, from a prescription
 * bottle or from a list of medications the patient, clinician or other party
 * maintains.  Medication administration is more formal and is not missing detailed information.
 */
export type FHIRMedicationStatement = {
   __typename?: 'FHIRMedicationStatement',
  /** Type of resource */
  resourceType: FHIRMedicationStatement_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Identifiers associated with this Medication Statement that are defined by
   * business processes and/or used to refer to it when a direct URL reference to
   * the resource itself is not appropriate. They are business identifiers assigned
   * to this resource by the performer or other systems and remain constant as the
   * resource is updated and propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A plan, proposal or order that is fulfilled in whole or in part by this event. */
  basedOn?: Maybe<Array<Maybe<FHIRMedicationStatementbasedOn_basedOn_Union>>>,
  /** A larger event of which this particular event is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRMedicationStatementpartOf_partOf_Union>>>,
  /** 
 * A code representing the patient or other source's judgment about the state of
   * the medication used that this statement is about.  Generally, this will be
   * active or completed.
 */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the MedicationStatement. */
  statusReason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates where the medication is expected to be consumed or administered. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * Identifies the medication being administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Identifies the medication being administered. This is either a link to a
   * resource representing the details of the medication or a simple attribute
   * carrying a code that identifies the medication from a known list of medications.
 */
  medicationReference: FHIRMedicationStatementmedicationReference_medicationReference_Union,
  /** The person, animal or group who is/was taking the medication. */
  subject: FHIRMedicationStatementsubject_subject_Union,
  /** The encounter or episode of care that establishes the context for this MedicationStatement. */
  context?: Maybe<FHIRMedicationStatementcontext_context_Union>,
  /** 
 * The interval of time during which it is being asserted that the patient
   * is/was/will be taking the medication (or was not taking, when the
   * MedicationStatement.taken element is No).
 */
  effectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The interval of time during which it is being asserted that the patient
   * is/was/will be taking the medication (or was not taking, when the
   * MedicationStatement.taken element is No).
 */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** The date when the medication statement was asserted by the information source. */
  dateAsserted?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The person or organization that provided the information about the taking of
   * this medication. Note: Use derivedFrom when a MedicationStatement is derived
   * from other resources, e.g. Claim or MedicationRequest.
 */
  informationSource?: Maybe<FHIRMedicationStatementinformationSource_informationSource_Union>,
  /** 
 * Allows linking the MedicationStatement to the underlying MedicationRequest, or
   * to other information that supports or is used to derive the
   * MedicationStatement.
 */
  derivedFrom?: Maybe<Array<Maybe<FHIRMedicationStatementderivedFrom_derivedFrom_Union>>>,
  /** A reason for why the medication is being/was taken. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Condition or observation that supports why the medication is being/was taken. */
  reasonReference?: Maybe<Array<Maybe<FHIRMedicationStatementreasonReference_reasonReference_Union>>>,
  /** Provides extra information about the medication statement that is not conveyed by the other attributes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Indicates how the medication is/was or should be taken by the patient. */
  dosage?: Maybe<Array<Maybe<FHIRDosage>>>,
};

export enum FHIRMedicationStatement_Enum_schema {
  MedicationStatement = 'MedicationStatement'
}

/** A plan, proposal or order that is fulfilled in whole or in part by this event. */
export type FHIRMedicationStatementbasedOn_basedOn_Union = FHIRMedicationRequest | FHIRCarePlan | FHIRServiceRequest;

/** The encounter or episode of care that establishes the context for this MedicationStatement. */
export type FHIRMedicationStatementcontext_context_Union = FHIREncounter | FHIREpisodeOfCare;

/** 
 * Allows linking the MedicationStatement to the underlying MedicationRequest, or
 * to other information that supports or is used to derive the MedicationStatement.
 */
export type FHIRMedicationStatementderivedFrom_derivedFrom_Union = FHIRResource;

/** 
 * The person or organization that provided the information about the taking of
 * this medication. Note: Use derivedFrom when a MedicationStatement is derived
 * from other resources, e.g. Claim or MedicationRequest.
 */
export type FHIRMedicationStatementinformationSource_informationSource_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIROrganization;

/** 
 * Identifies the medication being administered. This is either a link to a
 * resource representing the details of the medication or a simple attribute
 * carrying a code that identifies the medication from a known list of medications.
 */
export type FHIRMedicationStatementmedicationReference_medicationReference_Union = FHIRMedication;

/** A larger event of which this particular event is a component or step. */
export type FHIRMedicationStatementpartOf_partOf_Union = FHIRMedicationAdministration | FHIRMedicationDispense | FHIRMedicationStatement | FHIRProcedure | FHIRObservation;

/** Condition or observation that supports why the medication is being/was taken. */
export type FHIRMedicationStatementreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport;

/** The person, animal or group who is/was taking the medication. */
export type FHIRMedicationStatementsubject_subject_Union = FHIRPatient | FHIRGroup;

/** Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use). */
export type FHIRMedicinalProduct = {
   __typename?: 'FHIRMedicinalProduct',
  /** Type of resource */
  resourceType: FHIRMedicinalProduct_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifier for this product. Could be an MPID. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Regulatory type, e.g. Investigational or Authorized. */
  type?: Maybe<FHIRCodeableConcept>,
  /** If this medicine applies to human or veterinary uses. */
  domain?: Maybe<FHIRCoding>,
  /** The dose form for a single part product, or combined form of a multiple part product. */
  combinedPharmaceuticalDoseForm?: Maybe<FHIRCodeableConcept>,
  /** The legal status of supply of the medicinal product as classified by the regulator. */
  legalStatusOfSupply?: Maybe<FHIRCodeableConcept>,
  /** Whether the Medicinal Product is subject to additional monitoring for regulatory reasons. */
  additionalMonitoringIndicator?: Maybe<FHIRCodeableConcept>,
  /** Whether the Medicinal Product is subject to special measures for regulatory reasons. */
  specialMeasures?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** If authorised for use in children. */
  paediatricUseIndicator?: Maybe<FHIRCodeableConcept>,
  /** Allows the product to be classified by various systems. */
  productClassification?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Marketing status of the medicinal product, in contrast to marketing authorizaton. */
  marketingStatus?: Maybe<Array<Maybe<FHIRMarketingStatus>>>,
  /** Pharmaceutical aspects of product. */
  pharmaceuticalProduct?: Maybe<Array<Maybe<FHIRMedicinalProductpharmaceuticalProduct_pharmaceuticalProduct_Union>>>,
  /** Package representation for the product. */
  packagedMedicinalProduct?: Maybe<Array<Maybe<FHIRMedicinalProductpackagedMedicinalProduct_packagedMedicinalProduct_Union>>>,
  /** Supporting documentation, typically for regulatory submission. */
  attachedDocument?: Maybe<Array<Maybe<FHIRMedicinalProductattachedDocument_attachedDocument_Union>>>,
  /** A master file for to the medicinal product (e.g. Pharmacovigilance System Master File). */
  masterFile?: Maybe<Array<Maybe<FHIRMedicinalProductmasterFile_masterFile_Union>>>,
  /** A product specific contact, person (in a role), or an organization. */
  contact?: Maybe<Array<Maybe<FHIRMedicinalProductcontact_contact_Union>>>,
  /** Clinical trials or studies that this product is involved in. */
  clinicalTrial?: Maybe<Array<Maybe<FHIRMedicinalProductclinicalTrial_clinicalTrial_Union>>>,
  /** The product's name, including full name and possibly coded parts. */
  name?: Maybe<Array<FHIRMedicinalProductname>>,
  /** Reference to another product, e.g. for linking authorised to investigational product. */
  crossReference?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** An operation applied to the product, for manufacturing or adminsitrative purpose. */
  manufacturingBusinessOperation?: Maybe<Array<Maybe<FHIRMedicinalProductmanufacturingBusinessOperation>>>,
  /** Indicates if the medicinal product has an orphan designation for the treatment of a rare disease. */
  specialDesignation?: Maybe<Array<Maybe<FHIRMedicinalProductspecialDesignation>>>,
};

export enum FHIRMedicinalProduct_Enum_schema {
  MedicinalProduct = 'MedicinalProduct'
}

/** Supporting documentation, typically for regulatory submission. */
export type FHIRMedicinalProductattachedDocument_attachedDocument_Union = FHIRDocumentReference;

/** The regulatory authorization of a medicinal product. */
export type FHIRMedicinalProductAuthorization = {
   __typename?: 'FHIRMedicinalProductAuthorization',
  /** Type of resource */
  resourceType: FHIRMedicinalProductAuthorization_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifier for the marketing authorization, as assigned by a regulator. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The medicinal product that is being authorized. */
  subject?: Maybe<FHIRMedicinalProductAuthorizationsubject_subject_Union>,
  /** The country in which the marketing authorization has been granted. */
  country?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Jurisdiction within a country. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The status of the marketing authorization. */
  status?: Maybe<FHIRCodeableConcept>,
  /** The date at which the given status has become applicable. */
  statusDate?: Maybe<Scalars['FHIRDateTime']>,
  /** The date when a suspended the marketing or the marketing authorization of the product is anticipated to be restored. */
  restoreDate?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The beginning of the time period in which the marketing authorization is in
   * the specific status shall be specified A complete date consisting of day,
   * month and year shall be specified using the ISO 8601 date format.
 */
  validityPeriod?: Maybe<FHIRPeriod>,
  /** A period of time after authorization before generic product applicatiosn can be submitted. */
  dataExclusivityPeriod?: Maybe<FHIRPeriod>,
  /** The date when the first authorization was granted by a Medicines Regulatory Agency. */
  dateOfFirstAuthorization?: Maybe<Scalars['FHIRDateTime']>,
  /** Date of first marketing authorization for a company's new medicinal product in any country in the World. */
  internationalBirthDate?: Maybe<Scalars['FHIRDateTime']>,
  /** The legal framework against which this authorization is granted. */
  legalBasis?: Maybe<FHIRCodeableConcept>,
  /** Authorization in areas within a country. */
  jurisdictionalAuthorization?: Maybe<Array<Maybe<FHIRMedicinalProductAuthorizationjurisdictionalAuthorization>>>,
  /** Marketing Authorization Holder. */
  holder?: Maybe<FHIRMedicinalProductAuthorizationholder_holder_Union>,
  /** Medicines Regulatory Agency. */
  regulator?: Maybe<FHIRMedicinalProductAuthorizationregulator_regulator_Union>,
  /** The regulatory procedure for granting or amending a marketing authorization. */
  procedure?: Maybe<FHIRMedicinalProductAuthorizationprocedure>,
};

export enum FHIRMedicinalProductAuthorization_Enum_schema {
  MedicinalProductAuthorization = 'MedicinalProductAuthorization'
}

/** Marketing Authorization Holder. */
export type FHIRMedicinalProductAuthorizationholder_holder_Union = FHIROrganization;

export type FHIRMedicinalProductAuthorizationjurisdictionalAuthorization = {
   __typename?: 'FHIRMedicinalProductAuthorizationjurisdictionalAuthorization',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The assigned number for the marketing authorization. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Country of authorization. */
  country?: Maybe<FHIRCodeableConcept>,
  /** Jurisdiction within a country. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The legal status of supply in a jurisdiction or region. */
  legalStatusOfSupply?: Maybe<FHIRCodeableConcept>,
  /** The start and expected end date of the authorization. */
  validityPeriod?: Maybe<FHIRPeriod>,
};

export type FHIRMedicinalProductAuthorizationprocedure = {
   __typename?: 'FHIRMedicinalProductAuthorizationprocedure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for this procedure. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Type of procedure. */
  type: FHIRCodeableConcept,
  /** Date of procedure. */
  datePeriod?: Maybe<FHIRPeriod>,
  /** Date of procedure. */
  dateDateTime?: Maybe<Scalars['FHIRDateTime']>,
};

/** Medicines Regulatory Agency. */
export type FHIRMedicinalProductAuthorizationregulator_regulator_Union = FHIROrganization;

/** The medicinal product that is being authorized. */
export type FHIRMedicinalProductAuthorizationsubject_subject_Union = FHIRMedicinalProduct | FHIRMedicinalProductPackaged;

/** Clinical trials or studies that this product is involved in. */
export type FHIRMedicinalProductclinicalTrial_clinicalTrial_Union = FHIRResearchStudy;

/** A product specific contact, person (in a role), or an organization. */
export type FHIRMedicinalProductcontact_contact_Union = FHIROrganization | FHIRPractitionerRole;

/** The clinical particulars - indications, contraindications etc. of a medicinal product, including for regulatory purposes. */
export type FHIRMedicinalProductContraindication = {
   __typename?: 'FHIRMedicinalProductContraindication',
  /** Type of resource */
  resourceType: FHIRMedicinalProductContraindication_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The medication for which this is an indication. */
  subject?: Maybe<Array<Maybe<FHIRMedicinalProductContraindicationsubject_subject_Union>>>,
  /** The disease, symptom or procedure for the contraindication. */
  disease?: Maybe<FHIRCodeableConcept>,
  /** The status of the disease or symptom for the contraindication. */
  diseaseStatus?: Maybe<FHIRCodeableConcept>,
  /** A comorbidity (concurrent condition) or coinfection. */
  comorbidity?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Information about the use of the medicinal product in relation to other therapies as part of the indication. */
  therapeuticIndication?: Maybe<Array<Maybe<FHIRMedicinalProductContraindicationtherapeuticIndication_therapeuticIndication_Union>>>,
  /** Information about the use of the medicinal product in relation to other therapies described as part of the indication. */
  otherTherapy?: Maybe<Array<Maybe<FHIRMedicinalProductContraindicationotherTherapy>>>,
  /** The population group to which this applies. */
  population?: Maybe<Array<Maybe<FHIRPopulation>>>,
};

export enum FHIRMedicinalProductContraindication_Enum_schema {
  MedicinalProductContraindication = 'MedicinalProductContraindication'
}

export type FHIRMedicinalProductContraindicationotherTherapy = {
   __typename?: 'FHIRMedicinalProductContraindicationotherTherapy',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relationship between the medicinal product indication or contraindication and another therapy. */
  therapyRelationshipType: FHIRCodeableConcept,
  /** 
 * Reference to a specific medication (active substance, medicinal product or
   * class of products) as part of an indication or contraindication.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Reference to a specific medication (active substance, medicinal product or
   * class of products) as part of an indication or contraindication.
 */
  medicationReference: FHIRMedicinalProductContraindicationotherTherapymedicationReference_medicationReference_Union,
};

/** 
 * Reference to a specific medication (active substance, medicinal product or class
 * of products) as part of an indication or contraindication.
 */
export type FHIRMedicinalProductContraindicationotherTherapymedicationReference_medicationReference_Union = FHIRMedicinalProduct | FHIRMedication | FHIRSubstance | FHIRSubstanceSpecification;

/** The medication for which this is an indication. */
export type FHIRMedicinalProductContraindicationsubject_subject_Union = FHIRMedicinalProduct | FHIRMedication;

/** Information about the use of the medicinal product in relation to other therapies as part of the indication. */
export type FHIRMedicinalProductContraindicationtherapeuticIndication_therapeuticIndication_Union = FHIRMedicinalProductIndication;

/** Indication for the Medicinal Product. */
export type FHIRMedicinalProductIndication = {
   __typename?: 'FHIRMedicinalProductIndication',
  /** Type of resource */
  resourceType: FHIRMedicinalProductIndication_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The medication for which this is an indication. */
  subject?: Maybe<Array<Maybe<FHIRMedicinalProductIndicationsubject_subject_Union>>>,
  /** The disease, symptom or procedure that is the indication for treatment. */
  diseaseSymptomProcedure?: Maybe<FHIRCodeableConcept>,
  /** The status of the disease or symptom for which the indication applies. */
  diseaseStatus?: Maybe<FHIRCodeableConcept>,
  /** Comorbidity (concurrent condition) or co-infection as part of the indication. */
  comorbidity?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The intended effect, aim or strategy to be achieved by the indication. */
  intendedEffect?: Maybe<FHIRCodeableConcept>,
  /** Timing or duration information as part of the indication. */
  duration?: Maybe<FHIRQuantity>,
  /** Information about the use of the medicinal product in relation to other therapies described as part of the indication. */
  otherTherapy?: Maybe<Array<Maybe<FHIRMedicinalProductIndicationotherTherapy>>>,
  /** Describe the undesirable effects of the medicinal product. */
  undesirableEffect?: Maybe<Array<Maybe<FHIRMedicinalProductIndicationundesirableEffect_undesirableEffect_Union>>>,
  /** The population group to which this applies. */
  population?: Maybe<Array<Maybe<FHIRPopulation>>>,
};

export enum FHIRMedicinalProductIndication_Enum_schema {
  MedicinalProductIndication = 'MedicinalProductIndication'
}

export type FHIRMedicinalProductIndicationotherTherapy = {
   __typename?: 'FHIRMedicinalProductIndicationotherTherapy',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relationship between the medicinal product indication or contraindication and another therapy. */
  therapyRelationshipType: FHIRCodeableConcept,
  /** 
 * Reference to a specific medication (active substance, medicinal product or
   * class of products) as part of an indication or contraindication.
 */
  medicationCodeableConcept: FHIRCodeableConcept,
  /** 
 * Reference to a specific medication (active substance, medicinal product or
   * class of products) as part of an indication or contraindication.
 */
  medicationReference: FHIRMedicinalProductIndicationotherTherapymedicationReference_medicationReference_Union,
};

/** 
 * Reference to a specific medication (active substance, medicinal product or class
 * of products) as part of an indication or contraindication.
 */
export type FHIRMedicinalProductIndicationotherTherapymedicationReference_medicationReference_Union = FHIRMedicinalProduct | FHIRMedication | FHIRSubstance | FHIRSubstanceSpecification;

/** The medication for which this is an indication. */
export type FHIRMedicinalProductIndicationsubject_subject_Union = FHIRMedicinalProduct | FHIRMedication;

/** Describe the undesirable effects of the medicinal product. */
export type FHIRMedicinalProductIndicationundesirableEffect_undesirableEffect_Union = FHIRMedicinalProductUndesirableEffect;

/** An ingredient of a manufactured item or pharmaceutical product. */
export type FHIRMedicinalProductIngredient = {
   __typename?: 'FHIRMedicinalProductIngredient',
  /** Type of resource */
  resourceType: FHIRMedicinalProductIngredient_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The identifier(s) of this Ingredient that are assigned by business processes
   * and/or used to refer to it when a direct URL reference to the resource itself
   * is not appropriate.
 */
  identifier?: Maybe<FHIRIdentifier>,
  /** Ingredient role e.g. Active ingredient, excipient. */
  role: FHIRCodeableConcept,
  /** If the ingredient is a known or suspected allergen. */
  allergenicIndicator?: Maybe<Scalars['Boolean']>,
  /** Manufacturer of this Ingredient. */
  manufacturer?: Maybe<Array<Maybe<FHIRMedicinalProductIngredientmanufacturer_manufacturer_Union>>>,
  /** A specified substance that comprises this ingredient. */
  specifiedSubstance?: Maybe<Array<Maybe<FHIRMedicinalProductIngredientspecifiedSubstance>>>,
  /** The ingredient substance. */
  substance?: Maybe<FHIRMedicinalProductIngredientsubstance>,
};

export enum FHIRMedicinalProductIngredient_Enum_schema {
  MedicinalProductIngredient = 'MedicinalProductIngredient'
}

/** Manufacturer of this Ingredient. */
export type FHIRMedicinalProductIngredientmanufacturer_manufacturer_Union = FHIROrganization;

export type FHIRMedicinalProductIngredientspecifiedSubstance = {
   __typename?: 'FHIRMedicinalProductIngredientspecifiedSubstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The specified substance. */
  code: FHIRCodeableConcept,
  /** The group of specified substance, e.g. group 1 to 4. */
  group: FHIRCodeableConcept,
  /** Confidentiality level of the specified substance as the ingredient. */
  confidentiality?: Maybe<FHIRCodeableConcept>,
  /** Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product. */
  strength?: Maybe<Array<Maybe<FHIRMedicinalProductIngredientspecifiedSubstancestrength>>>,
};

export type FHIRMedicinalProductIngredientspecifiedSubstancestrength = {
   __typename?: 'FHIRMedicinalProductIngredientspecifiedSubstancestrength',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The quantity of substance in the unit of presentation, or in the volume (or
   * mass) of the single pharmaceutical product or manufactured item.
 */
  presentation: FHIRRatio,
  /** 
 * A lower limit for the quantity of substance in the unit of presentation. For
   * use when there is a range of strengths, this is the lower limit, with the
   * presentation attribute becoming the upper limit.
 */
  presentationLowLimit?: Maybe<FHIRRatio>,
  /** The strength per unitary volume (or mass). */
  concentration?: Maybe<FHIRRatio>,
  /** 
 * A lower limit for the strength per unitary volume (or mass), for when there is
   * a range. The concentration attribute then becomes the upper limit.
 */
  concentrationLowLimit?: Maybe<FHIRRatio>,
  /** For when strength is measured at a particular point or distance. */
  measurementPoint?: Maybe<Scalars['String']>,
  /** The country or countries for which the strength range applies. */
  country?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Strength expressed in terms of a reference substance. */
  referenceStrength?: Maybe<Array<Maybe<FHIRMedicinalProductIngredientspecifiedSubstancestrengthreferenceStrength>>>,
};

export type FHIRMedicinalProductIngredientspecifiedSubstancestrengthreferenceStrength = {
   __typename?: 'FHIRMedicinalProductIngredientspecifiedSubstancestrengthreferenceStrength',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Relevant reference substance. */
  substance?: Maybe<FHIRCodeableConcept>,
  /** Strength expressed in terms of a reference substance. */
  strength: FHIRRatio,
  /** Strength expressed in terms of a reference substance. */
  strengthLowLimit?: Maybe<FHIRRatio>,
  /** For when strength is measured at a particular point or distance. */
  measurementPoint?: Maybe<Scalars['String']>,
  /** The country or countries for which the strength range applies. */
  country?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export type FHIRMedicinalProductIngredientsubstance = {
   __typename?: 'FHIRMedicinalProductIngredientsubstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The ingredient substance. */
  code: FHIRCodeableConcept,
};

/** The interactions of the medicinal product with other medicinal products, or other forms of interactions. */
export type FHIRMedicinalProductInteraction = {
   __typename?: 'FHIRMedicinalProductInteraction',
  /** Type of resource */
  resourceType: FHIRMedicinalProductInteraction_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The medication for which this is a described interaction. */
  subject?: Maybe<Array<Maybe<FHIRMedicinalProductInteractionsubject_subject_Union>>>,
  /** The interaction described. */
  description?: Maybe<Scalars['String']>,
  /** The specific medication, food or laboratory test that interacts. */
  interactant?: Maybe<Array<Maybe<FHIRMedicinalProductInteractioninteractant>>>,
  /** The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The effect of the interaction, for example 'reduced gastric absorption of primary medication'. */
  effect?: Maybe<FHIRCodeableConcept>,
  /** The incidence of the interaction, e.g. theoretical, observed. */
  incidence?: Maybe<FHIRCodeableConcept>,
  /** Actions for managing the interaction. */
  management?: Maybe<FHIRCodeableConcept>,
};

export enum FHIRMedicinalProductInteraction_Enum_schema {
  MedicinalProductInteraction = 'MedicinalProductInteraction'
}

export type FHIRMedicinalProductInteractioninteractant = {
   __typename?: 'FHIRMedicinalProductInteractioninteractant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The specific medication, food or laboratory test that interacts. */
  itemReference: FHIRMedicinalProductInteractioninteractantitemReference_itemReference_Union,
  /** The specific medication, food or laboratory test that interacts. */
  itemCodeableConcept: FHIRCodeableConcept,
};

/** The specific medication, food or laboratory test that interacts. */
export type FHIRMedicinalProductInteractioninteractantitemReference_itemReference_Union = FHIRMedicinalProduct | FHIRMedication | FHIRSubstance | FHIRObservationDefinition;

/** The medication for which this is a described interaction. */
export type FHIRMedicinalProductInteractionsubject_subject_Union = FHIRMedicinalProduct | FHIRMedication | FHIRSubstance;

/** The manufactured item as contained in the packaged medicinal product. */
export type FHIRMedicinalProductManufactured = {
   __typename?: 'FHIRMedicinalProductManufactured',
  /** Type of resource */
  resourceType: FHIRMedicinalProductManufactured_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Dose form as manufactured and before any transformation into the pharmaceutical product. */
  manufacturedDoseForm: FHIRCodeableConcept,
  /** The “real world” units in which the quantity of the manufactured item is described. */
  unitOfPresentation?: Maybe<FHIRCodeableConcept>,
  /** The quantity or 'count number' of the manufactured item. */
  quantity: FHIRQuantity,
  /** Manufacturer of the item (Note that this should be named 'manufacturer' but it currently causes technical issues). */
  manufacturer?: Maybe<Array<Maybe<FHIRMedicinalProductManufacturedmanufacturer_manufacturer_Union>>>,
  /** Ingredient. */
  ingredient?: Maybe<Array<Maybe<FHIRMedicinalProductManufacturedingredient_ingredient_Union>>>,
  /** Dimensions, color etc. */
  physicalCharacteristics?: Maybe<FHIRProdCharacteristic>,
  /** Other codeable characteristics. */
  otherCharacteristics?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export enum FHIRMedicinalProductManufactured_Enum_schema {
  MedicinalProductManufactured = 'MedicinalProductManufactured'
}

/** Ingredient. */
export type FHIRMedicinalProductManufacturedingredient_ingredient_Union = FHIRMedicinalProductIngredient;

/** Manufacturer of the item (Note that this should be named 'manufacturer' but it currently causes technical issues). */
export type FHIRMedicinalProductManufacturedmanufacturer_manufacturer_Union = FHIROrganization;

export type FHIRMedicinalProductmanufacturingBusinessOperation = {
   __typename?: 'FHIRMedicinalProductmanufacturingBusinessOperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of manufacturing operation. */
  operationType?: Maybe<FHIRCodeableConcept>,
  /** Regulatory authorization reference number. */
  authorisationReferenceNumber?: Maybe<FHIRIdentifier>,
  /** Regulatory authorization date. */
  effectiveDate?: Maybe<Scalars['FHIRDateTime']>,
  /** To indicate if this proces is commercially confidential. */
  confidentialityIndicator?: Maybe<FHIRCodeableConcept>,
  /** The manufacturer or establishment associated with the process. */
  manufacturer?: Maybe<Array<Maybe<FHIRMedicinalProductmanufacturingBusinessOperationmanufacturer_manufacturer_Union>>>,
  /** A regulator which oversees the operation. */
  regulator?: Maybe<FHIRMedicinalProductmanufacturingBusinessOperationregulator_regulator_Union>,
};

/** The manufacturer or establishment associated with the process. */
export type FHIRMedicinalProductmanufacturingBusinessOperationmanufacturer_manufacturer_Union = FHIROrganization;

/** A regulator which oversees the operation. */
export type FHIRMedicinalProductmanufacturingBusinessOperationregulator_regulator_Union = FHIROrganization;

/** A master file for to the medicinal product (e.g. Pharmacovigilance System Master File). */
export type FHIRMedicinalProductmasterFile_masterFile_Union = FHIRDocumentReference;

export type FHIRMedicinalProductname = {
   __typename?: 'FHIRMedicinalProductname',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The full product name. */
  productName: Scalars['String'],
  /** Coding words or phrases of the name. */
  namePart?: Maybe<Array<Maybe<FHIRMedicinalProductnamenamePart>>>,
  /** Country where the name applies. */
  countryLanguage?: Maybe<Array<Maybe<FHIRMedicinalProductnamecountryLanguage>>>,
};

export type FHIRMedicinalProductnamecountryLanguage = {
   __typename?: 'FHIRMedicinalProductnamecountryLanguage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Country code for where this name applies. */
  country: FHIRCodeableConcept,
  /** Jurisdiction code for where this name applies. */
  jurisdiction?: Maybe<FHIRCodeableConcept>,
  /** Language code for this name. */
  language: FHIRCodeableConcept,
};

export type FHIRMedicinalProductnamenamePart = {
   __typename?: 'FHIRMedicinalProductnamenamePart',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A fragment of a product name. */
  part: Scalars['String'],
  /** Idenifying type for this part of the name (e.g. strength part). */
  type: FHIRCoding,
};

/** A medicinal product in a container or package. */
export type FHIRMedicinalProductPackaged = {
   __typename?: 'FHIRMedicinalProductPackaged',
  /** Type of resource */
  resourceType: FHIRMedicinalProductPackaged_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The product with this is a pack for. */
  subject?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedsubject_subject_Union>>>,
  /** Textual description. */
  description?: Maybe<Scalars['String']>,
  /** The legal status of supply of the medicinal product as classified by the regulator. */
  legalStatusOfSupply?: Maybe<FHIRCodeableConcept>,
  /** Marketing information. */
  marketingStatus?: Maybe<Array<Maybe<FHIRMarketingStatus>>>,
  /** Manufacturer of this Package Item. */
  marketingAuthorization?: Maybe<FHIRMedicinalProductPackagedmarketingAuthorization_marketingAuthorization_Union>,
  /** Manufacturer of this Package Item. */
  manufacturer?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedmanufacturer_manufacturer_Union>>>,
  /** Batch numbering. */
  batchIdentifier?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedbatchIdentifier>>>,
  /** A packaging item, as a contained for medicine, possibly with other packaging items within. */
  packageItem?: Maybe<Array<FHIRMedicinalProductPackagedpackageItem>>,
};

export enum FHIRMedicinalProductPackaged_Enum_schema {
  MedicinalProductPackaged = 'MedicinalProductPackaged'
}

export type FHIRMedicinalProductPackagedbatchIdentifier = {
   __typename?: 'FHIRMedicinalProductPackagedbatchIdentifier',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A number appearing on the outer packaging of a specific batch. */
  outerPackaging: FHIRIdentifier,
  /** A number appearing on the immediate packaging (and not the outer packaging). */
  immediatePackaging?: Maybe<FHIRIdentifier>,
};

/** Manufacturer of this Package Item. */
export type FHIRMedicinalProductPackagedmanufacturer_manufacturer_Union = FHIROrganization;

/** Manufacturer of this Package Item. */
export type FHIRMedicinalProductPackagedmarketingAuthorization_marketingAuthorization_Union = FHIRMedicinalProductAuthorization;

/** Package representation for the product. */
export type FHIRMedicinalProductpackagedMedicinalProduct_packagedMedicinalProduct_Union = FHIRMedicinalProductPackaged;

export type FHIRMedicinalProductPackagedpackageItem = {
   __typename?: 'FHIRMedicinalProductPackagedpackageItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Including possibly Data Carrier Identifier. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The physical type of the container of the medicine. */
  type: FHIRCodeableConcept,
  /** The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1. */
  quantity: FHIRQuantity,
  /** Material type of the package item. */
  material?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A possible alternate material for the packaging. */
  alternateMaterial?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A device accompanying a medicinal product. */
  device?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedpackageItemdevice_device_Union>>>,
  /** The manufactured item as contained in the packaged medicinal product. */
  manufacturedItem?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedpackageItemmanufacturedItem_manufacturedItem_Union>>>,
  /** Dimensions, color etc. */
  physicalCharacteristics?: Maybe<FHIRProdCharacteristic>,
  /** Other codeable characteristics. */
  otherCharacteristics?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Shelf Life and storage information. */
  shelfLifeStorage?: Maybe<Array<Maybe<FHIRProductShelfLife>>>,
  /** Manufacturer of this Package Item. */
  manufacturer?: Maybe<Array<Maybe<FHIRMedicinalProductPackagedpackageItemmanufacturer_manufacturer_Union>>>,
};

/** A device accompanying a medicinal product. */
export type FHIRMedicinalProductPackagedpackageItemdevice_device_Union = FHIRDeviceDefinition;

/** The manufactured item as contained in the packaged medicinal product. */
export type FHIRMedicinalProductPackagedpackageItemmanufacturedItem_manufacturedItem_Union = FHIRMedicinalProductManufactured;

/** Manufacturer of this Package Item. */
export type FHIRMedicinalProductPackagedpackageItemmanufacturer_manufacturer_Union = FHIROrganization;

/** The product with this is a pack for. */
export type FHIRMedicinalProductPackagedsubject_subject_Union = FHIRMedicinalProduct;

/** A pharmaceutical product described in terms of its composition and dose form. */
export type FHIRMedicinalProductPharmaceutical = {
   __typename?: 'FHIRMedicinalProductPharmaceutical',
  /** Type of resource */
  resourceType: FHIRMedicinalProductPharmaceutical_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An identifier for the pharmaceutical medicinal product. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The administrable dose form, after necessary reconstitution. */
  administrableDoseForm: FHIRCodeableConcept,
  /** Todo. */
  unitOfPresentation?: Maybe<FHIRCodeableConcept>,
  /** Ingredient. */
  ingredient?: Maybe<Array<Maybe<FHIRMedicinalProductPharmaceuticalingredient_ingredient_Union>>>,
  /** Accompanying device. */
  device?: Maybe<Array<Maybe<FHIRMedicinalProductPharmaceuticaldevice_device_Union>>>,
  /** Characteristics e.g. a products onset of action. */
  characteristics?: Maybe<Array<Maybe<FHIRMedicinalProductPharmaceuticalcharacteristics>>>,
  /** The path by which the pharmaceutical product is taken into or makes contact with the body. */
  routeOfAdministration?: Maybe<Array<FHIRMedicinalProductPharmaceuticalrouteOfAdministration>>,
};

export enum FHIRMedicinalProductPharmaceutical_Enum_schema {
  MedicinalProductPharmaceutical = 'MedicinalProductPharmaceutical'
}

export type FHIRMedicinalProductPharmaceuticalcharacteristics = {
   __typename?: 'FHIRMedicinalProductPharmaceuticalcharacteristics',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A coded characteristic. */
  code: FHIRCodeableConcept,
  /** The status of characteristic e.g. assigned or pending. */
  status?: Maybe<FHIRCodeableConcept>,
};

/** Accompanying device. */
export type FHIRMedicinalProductPharmaceuticaldevice_device_Union = FHIRDeviceDefinition;

/** Ingredient. */
export type FHIRMedicinalProductPharmaceuticalingredient_ingredient_Union = FHIRMedicinalProductIngredient;

/** Pharmaceutical aspects of product. */
export type FHIRMedicinalProductpharmaceuticalProduct_pharmaceuticalProduct_Union = FHIRMedicinalProductPharmaceutical;

export type FHIRMedicinalProductPharmaceuticalrouteOfAdministration = {
   __typename?: 'FHIRMedicinalProductPharmaceuticalrouteOfAdministration',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Coded expression for the route. */
  code: FHIRCodeableConcept,
  /** 
 * The first dose (dose quantity) administered in humans can be specified, for a
   * product under investigation, using a numerical value and its unit of measurement.
 */
  firstDose?: Maybe<FHIRQuantity>,
  /** 
 * The maximum single dose that can be administered as per the protocol of a
   * clinical trial can be specified using a numerical value and its unit of measurement.
 */
  maxSingleDose?: Maybe<FHIRQuantity>,
  /** 
 * The maximum dose per day (maximum dose quantity to be administered in any one
   * 24-h period) that can be administered as per the protocol referenced in the
   * clinical trial authorisation.
 */
  maxDosePerDay?: Maybe<FHIRQuantity>,
  /** 
 * The maximum dose per treatment period that can be administered as per the
   * protocol referenced in the clinical trial authorisation.
 */
  maxDosePerTreatmentPeriod?: Maybe<FHIRRatio>,
  /** 
 * The maximum treatment period during which an Investigational Medicinal Product
   * can be administered as per the protocol referenced in the clinical trial authorisation.
 */
  maxTreatmentPeriod?: Maybe<FHIRDuration>,
  /** A species for which this route applies. */
  targetSpecies?: Maybe<Array<Maybe<FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecies>>>,
};

export type FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecies = {
   __typename?: 'FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecies',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Coded expression for the species. */
  code: FHIRCodeableConcept,
  /** A species specific time during which consumption of animal product is not appropriate. */
  withdrawalPeriod?: Maybe<Array<Maybe<FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecieswithdrawalPeriod>>>,
};

export type FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecieswithdrawalPeriod = {
   __typename?: 'FHIRMedicinalProductPharmaceuticalrouteOfAdministrationtargetSpecieswithdrawalPeriod',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk. */
  tissue: FHIRCodeableConcept,
  /** A value for the time. */
  value: FHIRQuantity,
  /** Extra information about the withdrawal period. */
  supportingInformation?: Maybe<Scalars['String']>,
};

export type FHIRMedicinalProductspecialDesignation = {
   __typename?: 'FHIRMedicinalProductspecialDesignation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the designation, or procedure number. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The type of special designation, e.g. orphan drug, minor use. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The intended use of the product, e.g. prevention, treatment. */
  intendedUse?: Maybe<FHIRCodeableConcept>,
  /** Condition for which the medicinal use applies. */
  indicationCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Condition for which the medicinal use applies. */
  indicationReference?: Maybe<FHIRMedicinalProductspecialDesignationindicationReference_indicationReference_Union>,
  /** For example granted, pending, expired or withdrawn. */
  status?: Maybe<FHIRCodeableConcept>,
  /** Date when the designation was granted. */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** Animal species for which this applies. */
  species?: Maybe<FHIRCodeableConcept>,
};

/** Condition for which the medicinal use applies. */
export type FHIRMedicinalProductspecialDesignationindicationReference_indicationReference_Union = FHIRMedicinalProductIndication;

/** Describe the undesirable effects of the medicinal product. */
export type FHIRMedicinalProductUndesirableEffect = {
   __typename?: 'FHIRMedicinalProductUndesirableEffect',
  /** Type of resource */
  resourceType: FHIRMedicinalProductUndesirableEffect_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The medication for which this is an indication. */
  subject?: Maybe<Array<Maybe<FHIRMedicinalProductUndesirableEffectsubject_subject_Union>>>,
  /** The symptom, condition or undesirable effect. */
  symptomConditionEffect?: Maybe<FHIRCodeableConcept>,
  /** Classification of the effect. */
  classification?: Maybe<FHIRCodeableConcept>,
  /** The frequency of occurrence of the effect. */
  frequencyOfOccurrence?: Maybe<FHIRCodeableConcept>,
  /** The population group to which this applies. */
  population?: Maybe<Array<Maybe<FHIRPopulation>>>,
};

export enum FHIRMedicinalProductUndesirableEffect_Enum_schema {
  MedicinalProductUndesirableEffect = 'MedicinalProductUndesirableEffect'
}

/** The medication for which this is an indication. */
export type FHIRMedicinalProductUndesirableEffectsubject_subject_Union = FHIRMedicinalProduct | FHIRMedication;

/** 
 * Defines the characteristics of a message that can be shared between systems,
 * including the type of event that initiates the message, the content to be
 * transmitted and what response(s), if any, are permitted.
 */
export type FHIRMessageDefinition = {
   __typename?: 'FHIRMessageDefinition',
  /** Type of resource */
  resourceType: FHIRMessageDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The business identifier that is used to reference the MessageDefinition and
   * *is* expected to be consistent from server to server.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this message definition when it
   * is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the message definition
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the message definition author and is not
   * expected to be globally unique. For example, it might be a timestamp (e.g.
   * yyyymmdd) if a managed version is not available. There is also no expectation
   * that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the message definition. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the message definition. */
  title?: Maybe<Scalars['String']>,
  /** A MessageDefinition that is superseded by this definition. */
  replaces?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The status of this message definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this message definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the message definition was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the message definition changes.
 */
  date: Scalars['FHIRDateTime'],
  /** The name of the organization or individual that published the message definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the message definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate message
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the message definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this message definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the message definition and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the message definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** The MessageDefinition that is the basis for the contents of this resource. */
  base?: Maybe<Scalars['FHIRCanonical']>,
  /** Identifies a protocol or workflow that this MessageDefinition represents a step in. */
  parent?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** Event code or link to the EventDefinition. */
  eventCoding: FHIRCoding,
  /** Event code or link to the EventDefinition. */
  eventUri: Scalars['FHIRUri'],
  /** The impact of the content of the message. */
  category?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Identifies the resource (or resources) that are being addressed by the event. 
   * For example, the Encounter for an admit message or two Account records for a merge.
 */
  focus?: Maybe<Array<Maybe<FHIRMessageDefinitionfocus>>>,
  /** Declare at a message definition level whether a response is required or only upon error or success, or never. */
  responseRequired?: Maybe<Scalars['FHIRCode']>,
  /** Indicates what types of messages may be sent as an application-level response to this message. */
  allowedResponse?: Maybe<Array<Maybe<FHIRMessageDefinitionallowedResponse>>>,
  /** 
 * Canonical reference to a GraphDefinition. If a URL is provided, it is the
   * canonical reference to a [GraphDefinition](graphdefinition.html) that it
   * controls what resources are to be added to the bundle when building the
   * document. The GraphDefinition can also specify profiles that apply to the
   * various resources.
 */
  graph?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
};

export enum FHIRMessageDefinition_Enum_schema {
  MessageDefinition = 'MessageDefinition'
}

export type FHIRMessageDefinitionallowedResponse = {
   __typename?: 'FHIRMessageDefinitionallowedResponse',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A reference to the message definition that must be adhered to by this supported response. */
  message: Scalars['FHIRCanonical'],
  /** 
 * Provides a description of the circumstances in which this response should be
   * used (as opposed to one of the alternative responses).
 */
  situation?: Maybe<Scalars['String']>,
};

export type FHIRMessageDefinitionfocus = {
   __typename?: 'FHIRMessageDefinitionfocus',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of resource that must be the focus for this message. */
  code: Scalars['FHIRCode'],
  /** A profile that reflects constraints for the focal resource (and potentially for related resources). */
  profile?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Identifies the minimum number of resources of this type that must be pointed
   * to by a message in order for it to be valid against this MessageDefinition.
 */
  min: Scalars['FHIRUnsignedInt'],
  /** 
 * Identifies the maximum number of resources of this type that must be pointed
   * to by a message in order for it to be valid against this MessageDefinition.
 */
  max?: Maybe<Scalars['String']>,
};

/** 
 * The header for a message exchange that is either requesting or responding to an
 * action.  The reference(s) that are the subject of the action as well as other
 * information related to the action are typically transmitted in a bundle in which
 * the MessageHeader resource instance is the first resource in the bundle.
 */
export type FHIRMessageHeader = {
   __typename?: 'FHIRMessageHeader',
  /** Type of resource */
  resourceType: FHIRMessageHeader_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Code that identifies the event this message represents and connects it with
   * its definition. Events defined as part of the FHIR specification have the
   * system value 'http://terminology.hl7.org/CodeSystem/message-events'. 
   * Alternatively uri to the EventDefinition.
 */
  eventCoding: FHIRCoding,
  /** 
 * Code that identifies the event this message represents and connects it with
   * its definition. Events defined as part of the FHIR specification have the
   * system value 'http://terminology.hl7.org/CodeSystem/message-events'. 
   * Alternatively uri to the EventDefinition.
 */
  eventUri: Scalars['FHIRUri'],
  /** The destination application which the message is intended for. */
  destination?: Maybe<Array<Maybe<FHIRMessageHeaderdestination>>>,
  /** Identifies the sending system to allow the use of a trust relationship. */
  sender?: Maybe<FHIRMessageHeadersender_sender_Union>,
  /** 
 * The person or device that performed the data entry leading to this message.
   * When there is more than one candidate, pick the most proximal to the message.
   * Can provide other enterers in extensions.
 */
  enterer?: Maybe<FHIRMessageHeaderenterer_enterer_Union>,
  /** 
 * The logical author of the message - the person or device that decided the
   * described event should happen. When there is more than one candidate, pick the
   * most proximal to the MessageHeader. Can provide other authors in extensions.
 */
  author?: Maybe<FHIRMessageHeaderauthor_author_Union>,
  /** The source application from which this message originated. */
  source: FHIRMessageHeadersource,
  /** 
 * The person or organization that accepts overall responsibility for the
   * contents of the message. The implication is that the message event happened
   * under the policies of the responsible party.
 */
  responsible?: Maybe<FHIRMessageHeaderresponsible_responsible_Union>,
  /** 
 * Coded indication of the cause for the event - indicates  a reason for the
   * occurrence of the event that is a focus of this message.
 */
  reason?: Maybe<FHIRCodeableConcept>,
  /** Information about the message that this message is a response to.  Only present if this message is a response. */
  response?: Maybe<FHIRMessageHeaderresponse>,
  /** The actual data of the message - a reference to the root/focus class of the event. */
  focus?: Maybe<Array<Maybe<FHIRMessageHeaderfocus_focus_Union>>>,
  /** Permanent link to the MessageDefinition for this message. */
  definition?: Maybe<Scalars['FHIRCanonical']>,
};

export enum FHIRMessageHeader_Enum_schema {
  MessageHeader = 'MessageHeader'
}

/** 
 * The logical author of the message - the person or device that decided the
 * described event should happen. When there is more than one candidate, pick the
 * most proximal to the MessageHeader. Can provide other authors in extensions.
 */
export type FHIRMessageHeaderauthor_author_Union = FHIRPractitioner | FHIRPractitionerRole;

export type FHIRMessageHeaderdestination = {
   __typename?: 'FHIRMessageHeaderdestination',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable name for the target system. */
  name?: Maybe<Scalars['String']>,
  /** Identifies the target end system in situations where the initial message transmission is to an intermediary system. */
  target?: Maybe<FHIRMessageHeaderdestinationtarget_target_Union>,
  /** Indicates where the message should be routed to. */
  endpoint: Scalars['FHIRUrl'],
  /** 
 * Allows data conveyed by a message to be addressed to a particular person or
   * department when routing to a specific application isn't sufficient.
 */
  receiver?: Maybe<FHIRMessageHeaderdestinationreceiver_receiver_Union>,
};

/** 
 * Allows data conveyed by a message to be addressed to a particular person or
 * department when routing to a specific application isn't sufficient.
 */
export type FHIRMessageHeaderdestinationreceiver_receiver_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Identifies the target end system in situations where the initial message transmission is to an intermediary system. */
export type FHIRMessageHeaderdestinationtarget_target_Union = FHIRDevice;

/** 
 * The person or device that performed the data entry leading to this message. When
 * there is more than one candidate, pick the most proximal to the message. Can
 * provide other enterers in extensions.
 */
export type FHIRMessageHeaderenterer_enterer_Union = FHIRPractitioner | FHIRPractitionerRole;

/** The actual data of the message - a reference to the root/focus class of the event. */
export type FHIRMessageHeaderfocus_focus_Union = FHIRResource;

export type FHIRMessageHeaderresponse = {
   __typename?: 'FHIRMessageHeaderresponse',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The MessageHeader.id of the message to which this message is a response. */
  identifier: Scalars['FHIRId'],
  /** 
 * Code that identifies the type of response to the message - whether it was
   * successful or not, and whether it should be resent or not.
 */
  code: Scalars['FHIRCode'],
  /** Full details of any issues found in the message. */
  details?: Maybe<FHIRMessageHeaderresponsedetails_details_Union>,
};

/** Full details of any issues found in the message. */
export type FHIRMessageHeaderresponsedetails_details_Union = FHIROperationOutcome;

/** 
 * The person or organization that accepts overall responsibility for the contents
 * of the message. The implication is that the message event happened under the
 * policies of the responsible party.
 */
export type FHIRMessageHeaderresponsible_responsible_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Identifies the sending system to allow the use of a trust relationship. */
export type FHIRMessageHeadersender_sender_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRMessageHeadersource = {
   __typename?: 'FHIRMessageHeadersource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable name for the source system. */
  name?: Maybe<Scalars['String']>,
  /** May include configuration or other information useful in debugging. */
  software?: Maybe<Scalars['String']>,
  /** Can convey versions of multiple systems in situations where a message passes through multiple hands. */
  version?: Maybe<Scalars['String']>,
  /** An e-mail, phone, website or other contact point to use to resolve issues with message communications. */
  contact?: Maybe<FHIRContactPoint>,
  /** Identifies the routing target to send acknowledgements to. */
  endpoint: Scalars['FHIRUrl'],
};

/** 
 * Base StructureDefinition for Meta Type: The metadata about a resource. This is
 * content in the resource that is maintained by the infrastructure. Changes to the
 * content might not always be associated with version changes to the resource.
 */
export type FHIRMeta = {
   __typename?: 'FHIRMeta',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The version specific identifier, as it appears in the version portion of the
   * URL. This value changes when the resource is created, updated, or deleted.
 */
  versionId?: Maybe<Scalars['FHIRId']>,
  /** When the resource last changed - e.g. when the version changed. */
  lastUpdated?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * A uri that identifies the source system of the resource. This provides a
   * minimal amount of [Provenance](provenance.html#) information that can be used
   * to track or differentiate the source of information in the resource. The
   * source may identify another FHIR server, document, message, database, etc.
 */
  source?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A list of profiles (references to
   * [StructureDefinition](structuredefinition.html#) resources) that this resource
   * claims to conform to. The URL is a reference to [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
 */
  profile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Security labels applied to this resource. These tags connect specific
   * resources to the overall security policy and infrastructure.
 */
  security?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * Tags applied to this resource. Tags are intended to be used to identify and
   * relate resources to process and workflow, and applications are not required to
   * consider the tags when interpreting the meaning of a resource.
 */
  tag?: Maybe<Array<Maybe<FHIRCoding>>>,
};

/** 
 * Base StructureDefinition for Meta Type: The metadata about a resource. This is
 * content in the resource that is maintained by the infrastructure. Changes to the
 * content might not always be associated with version changes to the resource.
 */
export type FHIRMeta_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * The version specific identifier, as it appears in the version portion of the
   * URL. This value changes when the resource is created, updated, or deleted.
 */
  _versionId?: Maybe<FHIRElement_Input>,
  /** 
 * The version specific identifier, as it appears in the version portion of the
   * URL. This value changes when the resource is created, updated, or deleted.
 */
  versionId?: Maybe<Scalars['FHIRId']>,
  /** When the resource last changed - e.g. when the version changed. */
  _lastUpdated?: Maybe<FHIRElement_Input>,
  /** When the resource last changed - e.g. when the version changed. */
  lastUpdated?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * A uri that identifies the source system of the resource. This provides a
   * minimal amount of [Provenance](provenance.html#) information that can be used
   * to track or differentiate the source of information in the resource. The
   * source may identify another FHIR server, document, message, database, etc.
 */
  _source?: Maybe<FHIRElement_Input>,
  /** 
 * A uri that identifies the source system of the resource. This provides a
   * minimal amount of [Provenance](provenance.html#) information that can be used
   * to track or differentiate the source of information in the resource. The
   * source may identify another FHIR server, document, message, database, etc.
 */
  source?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A list of profiles (references to
   * [StructureDefinition](structuredefinition.html#) resources) that this resource
   * claims to conform to. The URL is a reference to [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
 */
  _profile?: Maybe<FHIRElement_Input>,
  /** 
 * A list of profiles (references to
   * [StructureDefinition](structuredefinition.html#) resources) that this resource
   * claims to conform to. The URL is a reference to [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
 */
  profile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Security labels applied to this resource. These tags connect specific
   * resources to the overall security policy and infrastructure.
 */
  security?: Maybe<Array<Maybe<FHIRCoding_Input>>>,
  /** 
 * Tags applied to this resource. Tags are intended to be used to identify and
   * relate resources to process and workflow, and applications are not required to
   * consider the tags when interpreting the meaning of a resource.
 */
  tag?: Maybe<Array<Maybe<FHIRCoding_Input>>>,
};

/** Raw data describing a biological sequence. */
export type FHIRMolecularSequence = {
   __typename?: 'FHIRMolecularSequence',
  /** Type of resource */
  resourceType: FHIRMolecularSequence_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier for this particular sequence instance. This is a FHIR-defined id. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Amino Acid Sequence/ DNA Sequence / RNA Sequence. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Whether the sequence is numbered starting at 0 (0-based numbering or
   * coordinates, inclusive start, exclusive end) or starting at 1 (1-based
   * numbering, inclusive start and inclusive end).
 */
  coordinateSystem: Scalars['Int'],
  /** The patient whose sequencing results are described by this resource. */
  patient?: Maybe<FHIRMolecularSequencepatient_patient_Union>,
  /** Specimen used for sequencing. */
  specimen?: Maybe<FHIRMolecularSequencespecimen_specimen_Union>,
  /** The method for sequencing, for example, chip information. */
  device?: Maybe<FHIRMolecularSequencedevice_device_Union>,
  /** The organization or lab that should be responsible for this result. */
  performer?: Maybe<FHIRMolecularSequenceperformer_performer_Union>,
  /** The number of copies of the sequence of interest. (RNASeq). */
  quantity?: Maybe<FHIRQuantity>,
  /** A sequence that is used as a reference to describe variants that are present in a sequence analyzed. */
  referenceSeq?: Maybe<FHIRMolecularSequencereferenceSeq>,
  /** 
 * The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)).
   * This element can represent amino acid or nucleic sequence change(including
   * insertion,deletion,SNP,etc.)  It can represent some complex mutation or
   * segment variation with the assist of CIGAR string.
 */
  variant?: Maybe<Array<Maybe<FHIRMolecularSequencevariant>>>,
  /** 
 * Sequence that was observed. It is the result marked by referenceSeq along with
   * variant records on referenceSeq. This shall start from
   * referenceSeq.windowStart and end by referenceSeq.windowEnd.
 */
  observedSeq?: Maybe<Scalars['String']>,
  /** 
 * An experimental feature attribute that defines the quality of the feature in a
   * quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
 */
  quality?: Maybe<Array<Maybe<FHIRMolecularSequencequality>>>,
  /** 
 * Coverage (read depth or depth) is the average number of reads representing a
   * given nucleotide in the reconstructed sequence.
 */
  readCoverage?: Maybe<Scalars['Int']>,
  /** 
 * Configurations of the external repository. The repository shall store target's
   * observedSeq or records related with target's observedSeq.
 */
  repository?: Maybe<Array<Maybe<FHIRMolecularSequencerepository>>>,
  /** Pointer to next atomic sequence which at most contains one variant. */
  pointer?: Maybe<Array<Maybe<FHIRMolecularSequencepointer_pointer_Union>>>,
  /** Information about chromosome structure variation. */
  structureVariant?: Maybe<Array<Maybe<FHIRMolecularSequencestructureVariant>>>,
};

export enum FHIRMolecularSequence_Enum_schema {
  MolecularSequence = 'MolecularSequence'
}

/** The method for sequencing, for example, chip information. */
export type FHIRMolecularSequencedevice_device_Union = FHIRDevice;

/** The patient whose sequencing results are described by this resource. */
export type FHIRMolecularSequencepatient_patient_Union = FHIRPatient;

/** The organization or lab that should be responsible for this result. */
export type FHIRMolecularSequenceperformer_performer_Union = FHIROrganization;

/** Pointer to next atomic sequence which at most contains one variant. */
export type FHIRMolecularSequencepointer_pointer_Union = FHIRMolecularSequence;

export type FHIRMolecularSequencequality = {
   __typename?: 'FHIRMolecularSequencequality',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** INDEL / SNP / Undefined variant. */
  type: Scalars['FHIRCode'],
  /** Gold standard sequence used for comparing against. */
  standardSequence?: Maybe<FHIRCodeableConcept>,
  /** Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive. */
  start?: Maybe<Scalars['Int']>,
  /** 
 * End position of the sequence. If the coordinate system is 0-based then end is
   * exclusive and does not include the last position. If the coordinate system is
   * 1-base, then end is inclusive and includes the last position.
 */
  end?: Maybe<Scalars['Int']>,
  /** The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)). */
  score?: Maybe<FHIRQuantity>,
  /** Which method is used to get sequence quality. */
  method?: Maybe<FHIRCodeableConcept>,
  /** 
 * True positives, from the perspective of the truth data, i.e. the number of
   * sites in the Truth Call Set for which there are paths through the Query Call
   * Set that are consistent with all of the alleles at this site, and for which
   * there is an accurate genotype call for the event.
 */
  truthTP?: Maybe<Scalars['Float']>,
  /** 
 * True positives, from the perspective of the query data, i.e. the number of
   * sites in the Query Call Set for which there are paths through the Truth Call
   * Set that are consistent with all of the alleles at this site, and for which
   * there is an accurate genotype call for the event.
 */
  queryTP?: Maybe<Scalars['Float']>,
  /** 
 * False negatives, i.e. the number of sites in the Truth Call Set for which
   * there is no path through the Query Call Set that is consistent with all of the
   * alleles at this site, or sites for which there is an inaccurate genotype call
   * for the event. Sites with correct variant but incorrect genotype are counted here.
 */
  truthFN?: Maybe<Scalars['Float']>,
  /** 
 * False positives, i.e. the number of sites in the Query Call Set for which
   * there is no path through the Truth Call Set that is consistent with this site.
   * Sites with correct variant but incorrect genotype are counted here.
 */
  queryFP?: Maybe<Scalars['Float']>,
  /** 
 * The number of false positives where the non-REF alleles in the Truth and Query
   * Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
 */
  gtFP?: Maybe<Scalars['Float']>,
  /** QUERY.TP / (QUERY.TP + QUERY.FP). */
  precision?: Maybe<Scalars['Float']>,
  /** TRUTH.TP / (TRUTH.TP + TRUTH.FN). */
  recall?: Maybe<Scalars['Float']>,
  /** Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall). */
  fScore?: Maybe<Scalars['Float']>,
  /** Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff. */
  roc?: Maybe<FHIRMolecularSequencequalityroc>,
};

export type FHIRMolecularSequencequalityroc = {
   __typename?: 'FHIRMolecularSequencequalityroc',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Invidual data point representing the GQ (genotype quality) score threshold. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>,
  /** The number of true positives if the GQ score threshold was set to 'score' field value. */
  numTP?: Maybe<Array<Maybe<Scalars['Int']>>>,
  /** The number of false positives if the GQ score threshold was set to 'score' field value. */
  numFP?: Maybe<Array<Maybe<Scalars['Int']>>>,
  /** The number of false negatives if the GQ score threshold was set to 'score' field value. */
  numFN?: Maybe<Array<Maybe<Scalars['Int']>>>,
  /** Calculated precision if the GQ score threshold was set to 'score' field value. */
  precision?: Maybe<Array<Maybe<Scalars['Float']>>>,
  /** Calculated sensitivity if the GQ score threshold was set to 'score' field value. */
  sensitivity?: Maybe<Array<Maybe<Scalars['Float']>>>,
  /** Calculated fScore if the GQ score threshold was set to 'score' field value. */
  fMeasure?: Maybe<Array<Maybe<Scalars['Float']>>>,
};

export type FHIRMolecularSequencereferenceSeq = {
   __typename?: 'FHIRMolecularSequencereferenceSeq',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Structural unit composed of a nucleic acid molecule which controls its own
   * replication through the interaction of specific proteins at one or more
   * origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
 */
  chromosome?: Maybe<FHIRCodeableConcept>,
  /** 
 * The Genome Build used for reference, following GRCh build versions e.g. 'GRCh
   * 37'.  Version number must be included if a versioned release of a primary
   * build was used.
 */
  genomeBuild?: Maybe<Scalars['String']>,
  /** 
 * A relative reference to a DNA strand based on gene orientation. The strand
   * that contains the open reading frame of the gene is the 'sense' strand, and
   * the opposite complementary strand is the 'antisense' strand.
 */
  orientation?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Reference identifier of reference sequence submitted to NCBI. It must match
   * the type in the MolecularSequence.type field. For example, the prefix, “NG_”
   * identifies reference sequence for genes, “NM_” for messenger RNA transcripts,
   * and “NP_” for amino acid sequences.
 */
  referenceSeqId?: Maybe<FHIRCodeableConcept>,
  /** A pointer to another MolecularSequence entity as reference sequence. */
  referenceSeqPointer?: Maybe<FHIRMolecularSequencereferenceSeqreferenceSeqPointer_referenceSeqPointer_Union>,
  /** A string like 'ACGT'. */
  referenceSeqString?: Maybe<Scalars['String']>,
  /** 
 * An absolute reference to a strand. The Watson strand is the strand whose
   * 5'-end is on the short arm of the chromosome, and the Crick strand as the one
   * whose 5'-end is on the long arm.
 */
  strand?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Start position of the window on the reference sequence. If the coordinate
   * system is either 0-based or 1-based, then start position is inclusive.
 */
  windowStart?: Maybe<Scalars['Int']>,
  /** 
 * End position of the window on the reference sequence. If the coordinate system
   * is 0-based then end is exclusive and does not include the last position. If
   * the coordinate system is 1-base, then end is inclusive and includes the last position.
 */
  windowEnd?: Maybe<Scalars['Int']>,
};

/** A pointer to another MolecularSequence entity as reference sequence. */
export type FHIRMolecularSequencereferenceSeqreferenceSeqPointer_referenceSeqPointer_Union = FHIRMolecularSequence;

export type FHIRMolecularSequencerepository = {
   __typename?: 'FHIRMolecularSequencerepository',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Click and see / RESTful API / Need login to see / RESTful API with authentication / Other ways to see resource. */
  type: Scalars['FHIRCode'],
  /** URI of an external repository which contains further details about the genetics data. */
  url?: Maybe<Scalars['FHIRUri']>,
  /** URI of an external repository which contains further details about the genetics data. */
  name?: Maybe<Scalars['String']>,
  /** 
 * Id of the variant in this external repository. The server will understand how
   * to use this id to call for more info about datasets in external repository.
 */
  datasetId?: Maybe<Scalars['String']>,
  /** 
 * Id of the variantset in this external repository. The server will understand
   * how to use this id to call for more info about variantsets in external repository.
 */
  variantsetId?: Maybe<Scalars['String']>,
  /** Id of the read in this external repository. */
  readsetId?: Maybe<Scalars['String']>,
};

/** Specimen used for sequencing. */
export type FHIRMolecularSequencespecimen_specimen_Union = FHIRSpecimen;

export type FHIRMolecularSequencestructureVariant = {
   __typename?: 'FHIRMolecularSequencestructureVariant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Information about chromosome structure variation DNA change type. */
  variantType?: Maybe<FHIRCodeableConcept>,
  /** Used to indicate if the outer and inner start-end values have the same meaning. */
  exact?: Maybe<Scalars['Boolean']>,
  /** Length of the variant chromosome. */
  length?: Maybe<Scalars['Int']>,
  /** Structural variant outer. */
  outer?: Maybe<FHIRMolecularSequencestructureVariantouter>,
  /** Structural variant inner. */
  inner?: Maybe<FHIRMolecularSequencestructureVariantinner>,
};

export type FHIRMolecularSequencestructureVariantinner = {
   __typename?: 'FHIRMolecularSequencestructureVariantinner',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Structural variant inner start. If the coordinate system is either 0-based or 1-based, then start position is inclusive. */
  start?: Maybe<Scalars['Int']>,
  /** 
 * Structural variant inner end. If the coordinate system is 0-based then end is
   * exclusive and does not include the last position. If the coordinate system is
   * 1-base, then end is inclusive and includes the last position.
 */
  end?: Maybe<Scalars['Int']>,
};

export type FHIRMolecularSequencestructureVariantouter = {
   __typename?: 'FHIRMolecularSequencestructureVariantouter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Structural variant outer start. If the coordinate system is either 0-based or 1-based, then start position is inclusive. */
  start?: Maybe<Scalars['Int']>,
  /** 
 * Structural variant outer end. If the coordinate system is 0-based then end is
   * exclusive and does not include the last position. If the coordinate system is
   * 1-base, then end is inclusive and includes the last position.
 */
  end?: Maybe<Scalars['Int']>,
};

export type FHIRMolecularSequencevariant = {
   __typename?: 'FHIRMolecularSequencevariant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Start position of the variant on the  reference sequence. If the coordinate
   * system is either 0-based or 1-based, then start position is inclusive.
 */
  start?: Maybe<Scalars['Int']>,
  /** 
 * End position of the variant on the reference sequence. If the coordinate
   * system is 0-based then end is exclusive and does not include the last
   * position. If the coordinate system is 1-base, then end is inclusive and
   * includes the last position.
 */
  end?: Maybe<Scalars['Int']>,
  /** 
 * An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
   *  Nucleotide(s)/amino acids from start position of sequence to stop position of
   * sequence on the positive (+) strand of the observed  sequence. When the
   * sequence  type is DNA, it should be the sequence on the positive (+) strand.
   * This will lay in the range between variant.start and variant.end.
 */
  observedAllele?: Maybe<Scalars['String']>,
  /** 
 * An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
   * Nucleotide(s)/amino acids from start position of sequence to stop position of
   * sequence on the positive (+) strand of the reference sequence. When the
   * sequence  type is DNA, it should be the sequence on the positive (+) strand.
   * This will lay in the range between variant.start and variant.end.
 */
  referenceAllele?: Maybe<Scalars['String']>,
  /** 
 * Extended CIGAR string for aligning the sequence with reference bases. See
   * detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
 */
  cigar?: Maybe<Scalars['String']>,
  /** A pointer to an Observation containing variant information. */
  variantPointer?: Maybe<FHIRMolecularSequencevariantvariantPointer_variantPointer_Union>,
};

/** A pointer to an Observation containing variant information. */
export type FHIRMolecularSequencevariantvariantPointer_variantPointer_Union = FHIRObservation;

/** Base StructureDefinition for Money Type: An amount of economic utility in some recognized currency. */
export type FHIRMoney = {
   __typename?: 'FHIRMoney',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Numerical value (with implicit precision). */
  value?: Maybe<Scalars['Float']>,
  /** ISO 4217 Currency Code. */
  currency?: Maybe<Scalars['FHIRCode']>,
};

/** Base StructureDefinition for Money Type: An amount of economic utility in some recognized currency. */
export type FHIRMoney_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Numerical value (with implicit precision). */
  _value?: Maybe<FHIRElement_Input>,
  /** Numerical value (with implicit precision). */
  value?: Maybe<Scalars['Float']>,
  /** ISO 4217 Currency Code. */
  _currency?: Maybe<FHIRElement_Input>,
  /** ISO 4217 Currency Code. */
  currency?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * A curated namespace that issues unique symbols within that namespace for the
 * identification of concepts, people, devices, etc.  Represents a 'System' used
 * within the Identifier and Coding data types.
 */
export type FHIRNamingSystem = {
   __typename?: 'FHIRNamingSystem',
  /** Type of resource */
  resourceType: FHIRNamingSystem_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * A natural language name identifying the naming system. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name: Scalars['String'],
  /** The status of this naming system. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** Indicates the purpose for the naming system - what kinds of things does it make unique? */
  kind: Scalars['FHIRCode'],
  /** 
 * The date  (and optionally time) when the naming system was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the naming system changes.
 */
  date: Scalars['FHIRDateTime'],
  /** The name of the organization or individual that published the naming system. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** 
 * The name of the organization that is responsible for issuing identifiers or
   * codes for this namespace and ensuring their non-collision.
 */
  responsible?: Maybe<Scalars['String']>,
  /** Categorizes a naming system for easier search by grouping related naming systems. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * A free text natural language description of the naming system from a
   * consumer's perspective. Details about what the namespace identifies including
   * scope, granularity, version labeling, etc.
 */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate naming
   * system instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the naming system is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Provides guidance on the use of the namespace, including the handling of
   * formatting characters, use of upper vs. lower case, etc.
 */
  usage?: Maybe<Scalars['String']>,
  /** Indicates how the system may be identified when referenced in electronic exchange. */
  uniqueId?: Maybe<Array<FHIRNamingSystemuniqueId>>,
};

export enum FHIRNamingSystem_Enum_schema {
  NamingSystem = 'NamingSystem'
}

export type FHIRNamingSystemuniqueId = {
   __typename?: 'FHIRNamingSystemuniqueId',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies the unique identifier scheme used for this particular identifier. */
  type: Scalars['FHIRCode'],
  /** The string that should be sent over the wire to identify the code system or identifier system. */
  value: Scalars['String'],
  /** Indicates whether this identifier is the 'preferred' identifier of this type. */
  preferred?: Maybe<Scalars['Boolean']>,
  /** Notes about the past or intended usage of this identifier. */
  comment?: Maybe<Scalars['String']>,
  /** 
 * Identifies the period of time over which this identifier is considered
   * appropriate to refer to the naming system.  Outside of this window, the
   * identifier might be non-deterministic.
 */
  period?: Maybe<FHIRPeriod>,
};

/** 
 * Base StructureDefinition for Narrative Type: A human-readable summary of the
 * resource conveying the essential clinical and business information for the resource.
 */
export type FHIRNarrative = {
   __typename?: 'FHIRNarrative',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The status of the narrative - whether it's entirely generated (from just the
   * defined data or the extensions too), or whether a human authored it and it may
   * contain additional data.
 */
  status: Scalars['FHIRCode'],
  /** The actual narrative content, a stripped down version of XHTML. */
  div: Scalars['FHIRXhtml'],
};

/** 
 * Base StructureDefinition for Narrative Type: A human-readable summary of the
 * resource conveying the essential clinical and business information for the resource.
 */
export type FHIRNarrative_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * The status of the narrative - whether it's entirely generated (from just the
   * defined data or the extensions too), or whether a human authored it and it may
   * contain additional data.
 */
  _status?: Maybe<FHIRElement_Input>,
  /** 
 * The status of the narrative - whether it's entirely generated (from just the
   * defined data or the extensions too), or whether a human authored it and it may
   * contain additional data.
 */
  status: Scalars['FHIRCode'],
  /** The actual narrative content, a stripped down version of XHTML. */
  _div?: Maybe<FHIRElement_Input>,
  /** The actual narrative content, a stripped down version of XHTML. */
  div: Scalars['FHIRXhtml'],
};

/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident. */
export type FHIRNutritionOrder = {
   __typename?: 'FHIRNutritionOrder',
  /** Type of resource */
  resourceType: FHIRNutritionOrder_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this order by the order sender or by the order receiver. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this NutritionOrder.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * NutritionOrder.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** 
 * The URL pointing to a protocol, guideline, orderset or other definition that
   * is adhered to in whole or in part by this NutritionOrder.
 */
  instantiates?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** The workflow status of the nutrition order/request. */
  status: Scalars['FHIRCode'],
  /** 
 * Indicates the level of authority/intentionality associated with the
   * NutrionOrder and where the request fits into the workflow chain.
 */
  intent: Scalars['FHIRCode'],
  /** 
 * The person (patient) who needs the nutrition order for an oral diet,
   * nutritional supplement and/or enteral or formula feeding.
 */
  patient: FHIRNutritionOrderpatient_patient_Union,
  /** An encounter that provides additional information about the healthcare context in which this request is made. */
  encounter?: Maybe<FHIRNutritionOrderencounter_encounter_Union>,
  /** The date and time that this nutrition order was requested. */
  dateTime: Scalars['FHIRDateTime'],
  /** The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. */
  orderer?: Maybe<FHIRNutritionOrderorderer_orderer_Union>,
  /** A link to a record of allergies or intolerances  which should be included in the nutrition order. */
  allergyIntolerance?: Maybe<Array<Maybe<FHIRNutritionOrderallergyIntolerance_allergyIntolerance_Union>>>,
  /** 
 * This modifier is used to convey order-specific modifiers about the type of
   * food that should be given. These can be derived from patient allergies,
   * intolerances, or preferences such as Halal, Vegan or Kosher. This modifier
   * applies to the entire nutrition order inclusive of the oral diet, nutritional
   * supplements and enteral formula feedings.
 */
  foodPreferenceModifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * This modifier is used to convey Order-specific modifier about the type of oral
   * food or oral fluids that should not be given. These can be derived from
   * patient allergies, intolerances, or preferences such as No Red Meat, No Soy or
   * No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy
   * or intolerance information captured in the referenced AllergyIntolerance
   * resource in the excludeFoodModifier, this element may be used to convey
   * additional specificity related to foods that should be eliminated from the
   * patient’s diet for any reason.  This modifier applies to the entire nutrition
   * order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
 */
  excludeFoodModifier?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Diet given orally in contrast to enteral (tube) feeding. */
  oralDiet?: Maybe<FHIRNutritionOrderoralDiet>,
  /** Oral nutritional products given in order to add further nutritional value to the patient's diet. */
  supplement?: Maybe<Array<Maybe<FHIRNutritionOrdersupplement>>>,
  /** 
 * Feeding provided through the gastrointestinal tract via a tube, catheter, or
   * stoma that delivers nutrition distal to the oral cavity.
 */
  enteralFormula?: Maybe<FHIRNutritionOrderenteralFormula>,
  /** Comments made about the {{title}} by the requester, performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRNutritionOrder_Enum_input {
  NutritionOrder = 'NutritionOrder'
}

export enum FHIRNutritionOrder_Enum_schema {
  NutritionOrder = 'NutritionOrder'
}

/** A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident. */
export type FHIRNutritionOrder_Input = {
  /** Type of resource */
  resourceType: FHIRNutritionOrder_Enum_input,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  _id?: Maybe<FHIRElement_Input>,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta_Input>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  _implicitRules?: Maybe<FHIRElement_Input>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  _language?: Maybe<FHIRElement_Input>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative_Input>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Identifiers assigned to this order by the order sender or by the order receiver. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier_Input>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this NutritionOrder.
 */
  _instantiatesCanonical?: Maybe<FHIRElement_Input>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this NutritionOrder.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * NutritionOrder.
 */
  _instantiatesUri?: Maybe<FHIRElement_Input>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * NutritionOrder.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** 
 * The URL pointing to a protocol, guideline, orderset or other definition that
   * is adhered to in whole or in part by this NutritionOrder.
 */
  _instantiates?: Maybe<FHIRElement_Input>,
  /** 
 * The URL pointing to a protocol, guideline, orderset or other definition that
   * is adhered to in whole or in part by this NutritionOrder.
 */
  instantiates?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** The workflow status of the nutrition order/request. */
  _status?: Maybe<FHIRElement_Input>,
  /** The workflow status of the nutrition order/request. */
  status: Scalars['FHIRCode'],
  /** 
 * Indicates the level of authority/intentionality associated with the
   * NutrionOrder and where the request fits into the workflow chain.
 */
  _intent?: Maybe<FHIRElement_Input>,
  /** 
 * Indicates the level of authority/intentionality associated with the
   * NutrionOrder and where the request fits into the workflow chain.
 */
  intent: Scalars['FHIRCode'],
  /** 
 * The person (patient) who needs the nutrition order for an oral diet,
   * nutritional supplement and/or enteral or formula feeding.
 */
  patient: Scalars['String'],
  /** An encounter that provides additional information about the healthcare context in which this request is made. */
  encounter?: Maybe<Scalars['String']>,
  /** The date and time that this nutrition order was requested. */
  _dateTime?: Maybe<FHIRElement_Input>,
  /** The date and time that this nutrition order was requested. */
  dateTime: Scalars['FHIRDateTime'],
  /** The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. */
  orderer?: Maybe<Scalars['String']>,
  /** A link to a record of allergies or intolerances  which should be included in the nutrition order. */
  allergyIntolerance?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * This modifier is used to convey order-specific modifiers about the type of
   * food that should be given. These can be derived from patient allergies,
   * intolerances, or preferences such as Halal, Vegan or Kosher. This modifier
   * applies to the entire nutrition order inclusive of the oral diet, nutritional
   * supplements and enteral formula feedings.
 */
  foodPreferenceModifier?: Maybe<Array<Maybe<FHIRCodeableConcept_Input>>>,
  /** 
 * This modifier is used to convey Order-specific modifier about the type of oral
   * food or oral fluids that should not be given. These can be derived from
   * patient allergies, intolerances, or preferences such as No Red Meat, No Soy or
   * No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy
   * or intolerance information captured in the referenced AllergyIntolerance
   * resource in the excludeFoodModifier, this element may be used to convey
   * additional specificity related to foods that should be eliminated from the
   * patient’s diet for any reason.  This modifier applies to the entire nutrition
   * order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
 */
  excludeFoodModifier?: Maybe<Array<Maybe<FHIRCodeableConcept_Input>>>,
  /** Diet given orally in contrast to enteral (tube) feeding. */
  oralDiet?: Maybe<FHIRNutritionOrderoralDiet_Input>,
  /** Oral nutritional products given in order to add further nutritional value to the patient's diet. */
  supplement?: Maybe<Array<Maybe<FHIRNutritionOrdersupplement_Input>>>,
  /** 
 * Feeding provided through the gastrointestinal tract via a tube, catheter, or
   * stoma that delivers nutrition distal to the oral cavity.
 */
  enteralFormula?: Maybe<FHIRNutritionOrderenteralFormula_Input>,
  /** Comments made about the {{title}} by the requester, performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation_Input>>>,
};

/** A link to a record of allergies or intolerances  which should be included in the nutrition order. */
export type FHIRNutritionOrderallergyIntolerance_allergyIntolerance_Union = FHIRAllergyIntolerance;

/** An encounter that provides additional information about the healthcare context in which this request is made. */
export type FHIRNutritionOrderencounter_encounter_Union = FHIREncounter;

export type FHIRNutritionOrderenteralFormula = {
   __typename?: 'FHIRNutritionOrderenteralFormula',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. */
  baseFormulaType?: Maybe<FHIRCodeableConcept>,
  /** The product or brand name of the enteral or infant formula product such as 'ACME Adult Standard Formula'. */
  baseFormulaProductName?: Maybe<Scalars['String']>,
  /** 
 * Indicates the type of modular component such as protein, carbohydrate, fat or
   * fiber to be provided in addition to or mixed with the base formula.
 */
  additiveType?: Maybe<FHIRCodeableConcept>,
  /** The product or brand name of the type of modular component to be added to the formula. */
  additiveProductName?: Maybe<Scalars['String']>,
  /** 
 * The amount of energy (calories) that the formula should provide per specified
   * volume, typically per mL or fluid oz.  For example, an infant may require a
   * formula that provides 24 calories per fluid ounce or an adult may require an
   * enteral formula that provides 1.5 calorie/mL.
 */
  caloricDensity?: Maybe<FHIRQuantity>,
  /** 
 * The route or physiological path of administration into the patient's
   * gastrointestinal  tract for purposes of providing the formula feeding, e.g.
   * nasogastric tube.
 */
  routeofAdministration?: Maybe<FHIRCodeableConcept>,
  /** 
 * Formula administration instructions as structured data.  This repeating
   * structure allows for changing the administration rate or volume over time for
   * both bolus and continuous feeding.  An example of this would be an instruction
   * to increase the rate of continuous feeding every 2 hours.
 */
  administration?: Maybe<Array<Maybe<FHIRNutritionOrderenteralFormulaadministration>>>,
  /** 
 * The maximum total quantity of formula that may be administered to a subject
   * over the period of time, e.g. 1440 mL over 24 hours.
 */
  maxVolumeToDeliver?: Maybe<FHIRQuantity>,
  /** Free text formula administration, feeding instructions or additional instructions or information. */
  administrationInstruction?: Maybe<Scalars['String']>,
};

export type FHIRNutritionOrderenteralFormula_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. */
  baseFormulaType?: Maybe<FHIRCodeableConcept_Input>,
  /** The product or brand name of the enteral or infant formula product such as 'ACME Adult Standard Formula'. */
  _baseFormulaProductName?: Maybe<FHIRElement_Input>,
  /** The product or brand name of the enteral or infant formula product such as 'ACME Adult Standard Formula'. */
  baseFormulaProductName?: Maybe<Scalars['String']>,
  /** 
 * Indicates the type of modular component such as protein, carbohydrate, fat or
   * fiber to be provided in addition to or mixed with the base formula.
 */
  additiveType?: Maybe<FHIRCodeableConcept_Input>,
  /** The product or brand name of the type of modular component to be added to the formula. */
  _additiveProductName?: Maybe<FHIRElement_Input>,
  /** The product or brand name of the type of modular component to be added to the formula. */
  additiveProductName?: Maybe<Scalars['String']>,
  /** 
 * The amount of energy (calories) that the formula should provide per specified
   * volume, typically per mL or fluid oz.  For example, an infant may require a
   * formula that provides 24 calories per fluid ounce or an adult may require an
   * enteral formula that provides 1.5 calorie/mL.
 */
  caloricDensity?: Maybe<FHIRQuantity_Input>,
  /** 
 * The route or physiological path of administration into the patient's
   * gastrointestinal  tract for purposes of providing the formula feeding, e.g.
   * nasogastric tube.
 */
  routeofAdministration?: Maybe<FHIRCodeableConcept_Input>,
  /** 
 * Formula administration instructions as structured data.  This repeating
   * structure allows for changing the administration rate or volume over time for
   * both bolus and continuous feeding.  An example of this would be an instruction
   * to increase the rate of continuous feeding every 2 hours.
 */
  administration?: Maybe<Array<Maybe<FHIRNutritionOrderenteralFormulaadministration_Input>>>,
  /** 
 * The maximum total quantity of formula that may be administered to a subject
   * over the period of time, e.g. 1440 mL over 24 hours.
 */
  maxVolumeToDeliver?: Maybe<FHIRQuantity_Input>,
  /** Free text formula administration, feeding instructions or additional instructions or information. */
  _administrationInstruction?: Maybe<FHIRElement_Input>,
  /** Free text formula administration, feeding instructions or additional instructions or information. */
  administrationInstruction?: Maybe<Scalars['String']>,
};

export type FHIRNutritionOrderenteralFormulaadministration = {
   __typename?: 'FHIRNutritionOrderenteralFormulaadministration',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The time period and frequency at which the enteral formula should be delivered to the patient. */
  schedule?: Maybe<FHIRTiming>,
  /** The volume of formula to provide to the patient per the specified administration schedule. */
  quantity?: Maybe<FHIRQuantity>,
  /** The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. */
  rateQuantity?: Maybe<FHIRQuantity>,
  /** The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. */
  rateRatio?: Maybe<FHIRRatio>,
};

export type FHIRNutritionOrderenteralFormulaadministration_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The time period and frequency at which the enteral formula should be delivered to the patient. */
  schedule?: Maybe<FHIRTiming_Input>,
  /** The volume of formula to provide to the patient per the specified administration schedule. */
  quantity?: Maybe<FHIRQuantity_Input>,
  /** The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. */
  rateQuantity?: Maybe<FHIRQuantity_Input>,
  /** The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. */
  rateRatio?: Maybe<FHIRRatio_Input>,
};

export type FHIRNutritionOrderList = {
   __typename?: 'FHIRNutritionOrderList',
  nodes?: Maybe<Array<Maybe<FHIRNutritionOrder>>>,
  listInfo?: Maybe<FHIRListInfo>,
};

export type FHIRNutritionOrderoralDiet = {
   __typename?: 'FHIRNutritionOrderoralDiet',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The time period and frequency at which the diet should be given.  The diet
   * should be given for the combination of all schedules if more than one schedule is present.
 */
  schedule?: Maybe<Array<Maybe<FHIRTiming>>>,
  /** 
 * Class that defines the quantity and type of nutrient modifications (for
   * example carbohydrate, fiber or sodium) required for the oral diet.
 */
  nutrient?: Maybe<Array<Maybe<FHIRNutritionOrderoralDietnutrient>>>,
  /** Class that describes any texture modifications required for the patient to safely consume various types of solid foods. */
  texture?: Maybe<Array<Maybe<FHIRNutritionOrderoralDiettexture>>>,
  /** The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient. */
  fluidConsistencyType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Free text or additional instructions or information pertaining to the oral diet. */
  instruction?: Maybe<Scalars['String']>,
};

export type FHIRNutritionOrderoralDiet_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept_Input>>>,
  /** 
 * The time period and frequency at which the diet should be given.  The diet
   * should be given for the combination of all schedules if more than one schedule is present.
 */
  schedule?: Maybe<Array<Maybe<FHIRTiming_Input>>>,
  /** 
 * Class that defines the quantity and type of nutrient modifications (for
   * example carbohydrate, fiber or sodium) required for the oral diet.
 */
  nutrient?: Maybe<Array<Maybe<FHIRNutritionOrderoralDietnutrient_Input>>>,
  /** Class that describes any texture modifications required for the patient to safely consume various types of solid foods. */
  texture?: Maybe<Array<Maybe<FHIRNutritionOrderoralDiettexture_Input>>>,
  /** The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient. */
  fluidConsistencyType?: Maybe<Array<Maybe<FHIRCodeableConcept_Input>>>,
  /** Free text or additional instructions or information pertaining to the oral diet. */
  _instruction?: Maybe<FHIRElement_Input>,
  /** Free text or additional instructions or information pertaining to the oral diet. */
  instruction?: Maybe<Scalars['String']>,
};

export type FHIRNutritionOrderoralDietnutrient = {
   __typename?: 'FHIRNutritionOrderoralDietnutrient',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The nutrient that is being modified such as carbohydrate or sodium. */
  modifier?: Maybe<FHIRCodeableConcept>,
  /** The quantity of the specified nutrient to include in diet. */
  amount?: Maybe<FHIRQuantity>,
};

export type FHIRNutritionOrderoralDietnutrient_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The nutrient that is being modified such as carbohydrate or sodium. */
  modifier?: Maybe<FHIRCodeableConcept_Input>,
  /** The quantity of the specified nutrient to include in diet. */
  amount?: Maybe<FHIRQuantity_Input>,
};

export type FHIRNutritionOrderoralDiettexture = {
   __typename?: 'FHIRNutritionOrderoralDiettexture',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. */
  modifier?: Maybe<FHIRCodeableConcept>,
  /** The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. */
  foodType?: Maybe<FHIRCodeableConcept>,
};

export type FHIRNutritionOrderoralDiettexture_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. */
  modifier?: Maybe<FHIRCodeableConcept_Input>,
  /** The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. */
  foodType?: Maybe<FHIRCodeableConcept_Input>,
};

/** The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. */
export type FHIRNutritionOrderorderer_orderer_Union = FHIRPractitioner | FHIRPractitionerRole;

/** 
 * The person (patient) who needs the nutrition order for an oral diet, nutritional
 * supplement and/or enteral or formula feeding.
 */
export type FHIRNutritionOrderpatient_patient_Union = FHIRPatient;

export type FHIRNutritionOrdersupplement = {
   __typename?: 'FHIRNutritionOrdersupplement',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The product or brand name of the nutritional supplement such as 'Acme Protein Shake'. */
  productName?: Maybe<Scalars['String']>,
  /** 
 * The time period and frequency at which the supplement(s) should be given.  The
   * supplement should be given for the combination of all schedules if more than
   * one schedule is present.
 */
  schedule?: Maybe<Array<Maybe<FHIRTiming>>>,
  /** The amount of the nutritional supplement to be given. */
  quantity?: Maybe<FHIRQuantity>,
  /** Free text or additional instructions or information pertaining to the oral supplement. */
  instruction?: Maybe<Scalars['String']>,
};

export type FHIRNutritionOrdersupplement_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. */
  type?: Maybe<FHIRCodeableConcept_Input>,
  /** The product or brand name of the nutritional supplement such as 'Acme Protein Shake'. */
  _productName?: Maybe<FHIRElement_Input>,
  /** The product or brand name of the nutritional supplement such as 'Acme Protein Shake'. */
  productName?: Maybe<Scalars['String']>,
  /** 
 * The time period and frequency at which the supplement(s) should be given.  The
   * supplement should be given for the combination of all schedules if more than
   * one schedule is present.
 */
  schedule?: Maybe<Array<Maybe<FHIRTiming_Input>>>,
  /** The amount of the nutritional supplement to be given. */
  quantity?: Maybe<FHIRQuantity_Input>,
  /** Free text or additional instructions or information pertaining to the oral supplement. */
  _instruction?: Maybe<FHIRElement_Input>,
  /** Free text or additional instructions or information pertaining to the oral supplement. */
  instruction?: Maybe<Scalars['String']>,
};

/** Measurements and simple assertions made about a patient, device or other subject. */
export type FHIRObservation = {
   __typename?: 'FHIRObservation',
  /** Type of resource */
  resourceType: FHIRObservation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this observation. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * A plan, proposal or order that is fulfilled in whole or in part by this event.
   *  For example, a MedicationRequest may require a patient to have laboratory
   * test performed before  it is dispensed.
 */
  basedOn?: Maybe<Array<Maybe<FHIRObservationbasedOn_basedOn_Union>>>,
  /** 
 * A larger event of which this particular Observation is a component or step. 
   * For example,  an observation as part of a procedure.
 */
  partOf?: Maybe<Array<Maybe<FHIRObservationpartOf_partOf_Union>>>,
  /** The status of the result value. */
  status: Scalars['FHIRCode'],
  /** A code that classifies the general type of observation being made. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Describes what was observed. Sometimes this is called the observation 'name'. */
  code: FHIRCodeableConcept,
  /** 
 * The patient, or group of patients, location, or device this observation is
   * about and into whose record the observation is placed. If the actual focus of
   * the observation is different from the subject (or a sample of, part, or region
   * of the subject), the `focus` element or the `code` itself specifies the actual
   * focus of the observation.
 */
  subject?: Maybe<FHIRObservationsubject_subject_Union>,
  /** 
 * The actual focus of an observation when it is not the patient of record
   * representing something or someone associated with the patient such as a
   * spouse, parent, fetus, or donor. For example, fetus observations in a mother's
   * record.  The focus of an observation could also be an existing condition,  an
   * intervention, the subject's diet,  another observation of the subject,  or a
   * body structure such as tumor or implanted device.   An example use case would
   * be using the Observation resource to capture whether the mother is trained to
   * change her child's tracheostomy tube. In this example, the child is the
   * patient of record and the mother is the focus.
 */
  focus?: Maybe<Array<Maybe<FHIRObservationfocus_focus_Union>>>,
  /** The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. */
  encounter?: Maybe<FHIRObservationencounter_encounter_Union>,
  /** 
 * The time or time-period the observed value is asserted as being true. For
   * biological subjects - e.g. human patients - this is usually called the
   * 'physiologically relevant time'. This is usually either the time of the
   * procedure or of specimen collection, but very often the source of the
   * date/time is not known, only the date/time itself.
 */
  effectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The time or time-period the observed value is asserted as being true. For
   * biological subjects - e.g. human patients - this is usually called the
   * 'physiologically relevant time'. This is usually either the time of the
   * procedure or of specimen collection, but very often the source of the
   * date/time is not known, only the date/time itself.
 */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * The time or time-period the observed value is asserted as being true. For
   * biological subjects - e.g. human patients - this is usually called the
   * 'physiologically relevant time'. This is usually either the time of the
   * procedure or of specimen collection, but very often the source of the
   * date/time is not known, only the date/time itself.
 */
  effectiveTiming?: Maybe<FHIRTiming>,
  /** 
 * The time or time-period the observed value is asserted as being true. For
   * biological subjects - e.g. human patients - this is usually called the
   * 'physiologically relevant time'. This is usually either the time of the
   * procedure or of specimen collection, but very often the source of the
   * date/time is not known, only the date/time itself.
 */
  effectiveInstant?: Maybe<Scalars['FHIRInstant']>,
  /** 
 * The date and time this version of the observation was made available to
   * providers, typically after the results have been reviewed and verified.
 */
  issued?: Maybe<Scalars['FHIRInstant']>,
  /** Who was responsible for asserting the observed value as 'true'. */
  performer?: Maybe<Array<Maybe<FHIRObservationperformer_performer_Union>>>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueString?: Maybe<Scalars['String']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueRange?: Maybe<FHIRRange>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueRatio?: Maybe<FHIRRatio>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueSampledData?: Maybe<FHIRSampledData>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valuePeriod?: Maybe<FHIRPeriod>,
  /** Provides a reason why the expected value in the element Observation.value[x] is missing. */
  dataAbsentReason?: Maybe<FHIRCodeableConcept>,
  /** A categorical assessment of an observation value.  For example, high, low, normal. */
  interpretation?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Comments about the observation or the results. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Indicates the site on the subject's body where the observation was made (i.e. the target site). */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** Indicates the mechanism used to perform the observation. */
  method?: Maybe<FHIRCodeableConcept>,
  /** The specimen that was used when this observation was made. */
  specimen?: Maybe<FHIRObservationspecimen_specimen_Union>,
  /** The device used to generate the observation data. */
  device?: Maybe<FHIRObservationdevice_device_Union>,
  /** 
 * Guidance on how to interpret the value by comparison to a normal or
   * recommended range.  Multiple reference ranges are interpreted as an 'OR'.   In
   * other words, to represent two distinct target populations, two
   * `referenceRange` elements would be used.
 */
  referenceRange?: Maybe<Array<Maybe<FHIRObservationreferenceRange>>>,
  /** 
 * This observation is a group observation (e.g. a battery, a panel of tests, a
   * set of vital sign measurements) that includes the target as a member of the group.
 */
  hasMember?: Maybe<Array<Maybe<FHIRObservationhasMember_hasMember_Union>>>,
  /** 
 * The target resource that represents a measurement from which this observation
   * value is derived. For example, a calculated anion gap or a fetal measurement
   * based on an ultrasound image.
 */
  derivedFrom?: Maybe<Array<Maybe<FHIRObservationderivedFrom_derivedFrom_Union>>>,
  /** 
 * Some observations have multiple component observations.  These component
   * observations are expressed as separate code value pairs that share the same
   * attributes.  Examples include systolic and diastolic component observations
   * for blood pressure measurement and multiple component observations for
   * genetics observations.
 */
  component?: Maybe<Array<Maybe<FHIRObservationcomponent>>>,
};

export enum FHIRObservation_Enum_schema {
  Observation = 'Observation'
}

/** 
 * A plan, proposal or order that is fulfilled in whole or in part by this event. 
 * For example, a MedicationRequest may require a patient to have laboratory test
 * performed before  it is dispensed.
 */
export type FHIRObservationbasedOn_basedOn_Union = FHIRCarePlan | FHIRDeviceRequest | FHIRImmunizationRecommendation | FHIRMedicationRequest | FHIRNutritionOrder | FHIRServiceRequest;

export type FHIRObservationcomponent = {
   __typename?: 'FHIRObservationcomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Describes what was observed. Sometimes this is called the observation 'code'. */
  code: FHIRCodeableConcept,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueString?: Maybe<Scalars['String']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueRange?: Maybe<FHIRRange>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueRatio?: Maybe<FHIRRatio>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueSampledData?: Maybe<FHIRSampledData>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The information determined as a result of making the observation, if the information has a simple value. */
  valuePeriod?: Maybe<FHIRPeriod>,
  /** Provides a reason why the expected value in the element Observation.component.value[x] is missing. */
  dataAbsentReason?: Maybe<FHIRCodeableConcept>,
  /** A categorical assessment of an observation value.  For example, high, low, normal. */
  interpretation?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

/** 
 * Set of definitional characteristics for a kind of observation or measurement
 * produced or consumed by an orderable health care service.
 */
export type FHIRObservationDefinition = {
   __typename?: 'FHIRObservationDefinition',
  /** Type of resource */
  resourceType: FHIRObservationDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code that classifies the general type of observation. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Describes what will be observed. Sometimes this is called the observation 'name'. */
  code: FHIRCodeableConcept,
  /** A unique identifier assigned to this ObservationDefinition artifact. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The data types allowed for the value element of the instance observations conforming to this ObservationDefinition. */
  permittedDataType?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Multiple results allowed for observations conforming to this ObservationDefinition. */
  multipleResultsAllowed?: Maybe<Scalars['Boolean']>,
  /** The method or technique used to perform the observation. */
  method?: Maybe<FHIRCodeableConcept>,
  /** The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition. */
  preferredReportName?: Maybe<Scalars['String']>,
  /** Characteristics for quantitative results of this observation. */
  quantitativeDetails?: Maybe<FHIRObservationDefinitionquantitativeDetails>,
  /** 
 * Multiple  ranges of results qualified by different contexts for ordinal or
   * continuous observations conforming to this ObservationDefinition.
 */
  qualifiedInterval?: Maybe<Array<Maybe<FHIRObservationDefinitionqualifiedInterval>>>,
  /** The set of valid coded results for the observations  conforming to this ObservationDefinition. */
  validCodedValueSet?: Maybe<FHIRObservationDefinitionvalidCodedValueSet_validCodedValueSet_Union>,
  /** The set of normal coded results for the observations conforming to this ObservationDefinition. */
  normalCodedValueSet?: Maybe<FHIRObservationDefinitionnormalCodedValueSet_normalCodedValueSet_Union>,
  /** The set of abnormal coded results for the observation conforming to this ObservationDefinition. */
  abnormalCodedValueSet?: Maybe<FHIRObservationDefinitionabnormalCodedValueSet_abnormalCodedValueSet_Union>,
  /** The set of critical coded results for the observation conforming to this ObservationDefinition. */
  criticalCodedValueSet?: Maybe<FHIRObservationDefinitioncriticalCodedValueSet_criticalCodedValueSet_Union>,
};

export enum FHIRObservationDefinition_Enum_schema {
  ObservationDefinition = 'ObservationDefinition'
}

/** The set of abnormal coded results for the observation conforming to this ObservationDefinition. */
export type FHIRObservationDefinitionabnormalCodedValueSet_abnormalCodedValueSet_Union = FHIRValueSet;

/** The set of critical coded results for the observation conforming to this ObservationDefinition. */
export type FHIRObservationDefinitioncriticalCodedValueSet_criticalCodedValueSet_Union = FHIRValueSet;

/** The set of normal coded results for the observations conforming to this ObservationDefinition. */
export type FHIRObservationDefinitionnormalCodedValueSet_normalCodedValueSet_Union = FHIRValueSet;

export type FHIRObservationDefinitionqualifiedInterval = {
   __typename?: 'FHIRObservationDefinitionqualifiedInterval',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition. */
  category?: Maybe<Scalars['FHIRCode']>,
  /** The low and high values determining the interval. There may be only one of the two. */
  range?: Maybe<FHIRRange>,
  /** Codes to indicate the health context the range applies to. For example, the normal or therapeutic range. */
  context?: Maybe<FHIRCodeableConcept>,
  /** Codes to indicate the target population this reference range applies to. */
  appliesTo?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Sex of the population the range applies to. */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The age at which this reference range is applicable. This is a neonatal age
   * (e.g. number of weeks at term) if the meaning says so.
 */
  age?: Maybe<FHIRRange>,
  /** The gestational age to which this reference range is applicable, in the context of pregnancy. */
  gestationalAge?: Maybe<FHIRRange>,
  /** Text based condition for which the reference range is valid. */
  condition?: Maybe<Scalars['String']>,
};

export type FHIRObservationDefinitionquantitativeDetails = {
   __typename?: 'FHIRObservationDefinitionquantitativeDetails',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Customary unit used to report quantitative results of observations conforming to this ObservationDefinition. */
  customaryUnit?: Maybe<FHIRCodeableConcept>,
  /** SI unit used to report quantitative results of observations conforming to this ObservationDefinition. */
  unit?: Maybe<FHIRCodeableConcept>,
  /** Factor for converting value expressed with SI unit to value expressed with customary unit. */
  conversionFactor?: Maybe<Scalars['Float']>,
  /** Number of digits after decimal separator when the results of such observations are of type Quantity. */
  decimalPrecision?: Maybe<Scalars['Int']>,
};

/** The set of valid coded results for the observations  conforming to this ObservationDefinition. */
export type FHIRObservationDefinitionvalidCodedValueSet_validCodedValueSet_Union = FHIRValueSet;

/** 
 * The target resource that represents a measurement from which this observation
 * value is derived. For example, a calculated anion gap or a fetal measurement
 * based on an ultrasound image.
 */
export type FHIRObservationderivedFrom_derivedFrom_Union = FHIRDocumentReference | FHIRImagingStudy | FHIRMedia | FHIRQuestionnaireResponse | FHIRObservation | FHIRMolecularSequence;

/** The device used to generate the observation data. */
export type FHIRObservationdevice_device_Union = FHIRDevice | FHIRDeviceMetric;

/** The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. */
export type FHIRObservationencounter_encounter_Union = FHIREncounter;

/** 
 * The actual focus of an observation when it is not the patient of record
 * representing something or someone associated with the patient such as a spouse,
 * parent, fetus, or donor. For example, fetus observations in a mother's record. 
 * The focus of an observation could also be an existing condition,  an
 * intervention, the subject's diet,  another observation of the subject,  or a
 * body structure such as tumor or implanted device.   An example use case would be
 * using the Observation resource to capture whether the mother is trained to
 * change her child's tracheostomy tube. In this example, the child is the patient
 * of record and the mother is the focus.
 */
export type FHIRObservationfocus_focus_Union = FHIRResource;

/** 
 * This observation is a group observation (e.g. a battery, a panel of tests, a set
 * of vital sign measurements) that includes the target as a member of the group.
 */
export type FHIRObservationhasMember_hasMember_Union = FHIRObservation | FHIRQuestionnaireResponse | FHIRMolecularSequence;

export type FHIRObservationList = {
   __typename?: 'FHIRObservationList',
  nodes?: Maybe<Array<Maybe<FHIRObservation>>>,
  listInfo?: Maybe<FHIRListInfo>,
};

/** 
 * A larger event of which this particular Observation is a component or step.  For
 * example,  an observation as part of a procedure.
 */
export type FHIRObservationpartOf_partOf_Union = FHIRMedicationAdministration | FHIRMedicationDispense | FHIRMedicationStatement | FHIRProcedure | FHIRImmunization | FHIRImagingStudy;

/** Who was responsible for asserting the observed value as 'true'. */
export type FHIRObservationperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRPatient | FHIRRelatedPerson;

export type FHIRObservationreferenceRange = {
   __typename?: 'FHIRObservationreferenceRange',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The value of the low bound of the reference range.  The low bound of the
   * reference range endpoint is inclusive of the value (e.g.  reference range is
   * >=5 - <=9). If the low bound is omitted,  it is assumed to be meaningless
   * (e.g. reference range is <=2.3).
 */
  low?: Maybe<FHIRQuantity>,
  /** 
 * The value of the high bound of the reference range.  The high bound of the
   * reference range endpoint is inclusive of the value (e.g.  reference range is
   * >=5 - <=9). If the high bound is omitted,  it is assumed to be meaningless
   * (e.g. reference range is >= 2.3).
 */
  high?: Maybe<FHIRQuantity>,
  /** 
 * Codes to indicate the what part of the targeted reference population it
   * applies to. For example, the normal or therapeutic range.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Codes to indicate the target population this reference range applies to.  For
   * example, a reference range may be based on the normal population or a
   * particular sex or race.  Multiple `appliesTo`  are interpreted as an 'AND' of
   * the target populations.  For example, to represent a target population of
   * African American females, both a code of female and a code for African
   * American would be used.
 */
  appliesTo?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The age at which this reference range is applicable. This is a neonatal age
   * (e.g. number of weeks at term) if the meaning says so.
 */
  age?: Maybe<FHIRRange>,
  /** 
 * Text based reference range in an observation which may be used when a
   * quantitative range is not appropriate for an observation.  An example would be
   * a reference value of 'Negative' or a list or table of 'normals'.
 */
  text?: Maybe<Scalars['String']>,
};

/** The specimen that was used when this observation was made. */
export type FHIRObservationspecimen_specimen_Union = FHIRSpecimen;

/** 
 * The patient, or group of patients, location, or device this observation is about
 * and into whose record the observation is placed. If the actual focus of the
 * observation is different from the subject (or a sample of, part, or region of
 * the subject), the `focus` element or the `code` itself specifies the actual
 * focus of the observation.
 */
export type FHIRObservationsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRDevice | FHIRLocation;


/** A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
export type FHIROperationDefinition = {
   __typename?: 'FHIROperationDefinition',
  /** Type of resource */
  resourceType: FHIROperationDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this operation definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this operation
   * definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the operation definition is
   * stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The identifier that is used to identify this version of the operation
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the operation definition
   * author and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the operation definition. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name: Scalars['String'],
  /** A short, descriptive, user-friendly title for the operation definition. */
  title?: Maybe<Scalars['String']>,
  /** The status of this operation definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** Whether this is an operation or a named query. */
  kind: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this operation definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the operation definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the operation definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the operation definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the operation definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate operation
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the operation definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this operation definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * Whether the operation affects state. Side effects such as producing audit
   * trail entries do not count as 'affecting  state'.
 */
  affectsState?: Maybe<Scalars['Boolean']>,
  /** The name used to invoke the operation. */
  code: Scalars['FHIRCode'],
  /** Additional information about how to use this operation or named query. */
  comment?: Maybe<Scalars['String']>,
  /** Indicates that this operation definition is a constraining profile on the base. */
  base?: Maybe<Scalars['FHIRCanonical']>,
  /** The types on which this operation can be executed. */
  resource?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * Indicates whether this operation or named query can be invoked at the system
   * level (e.g. without needing to choose a resource type for the context).
 */
  system: Scalars['Boolean'],
  /** 
 * Indicates whether this operation or named query can be invoked at the resource
   * type level for any given resource type level (e.g. without needing to choose a
   * specific resource id for the context).
 */
  type: Scalars['Boolean'],
  /** Indicates whether this operation can be invoked on a particular instance of one of the given types. */
  instance: Scalars['Boolean'],
  /** 
 * Additional validation information for the in parameters - a single profile
   * that covers all the parameters. The profile is a constraint on the parameters
   * resource as a whole.
 */
  inputProfile?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Additional validation information for the out parameters - a single profile
   * that covers all the parameters. The profile is a constraint on the parameters resource.
 */
  outputProfile?: Maybe<Scalars['FHIRCanonical']>,
  /** The parameters for the operation/query. */
  parameter?: Maybe<Array<Maybe<FHIROperationDefinitionparameter>>>,
  /** 
 * Defines an appropriate combination of parameters to use when invoking this
   * operation, to help code generators when generating overloaded parameter sets
   * for this operation.
 */
  overload?: Maybe<Array<Maybe<FHIROperationDefinitionoverload>>>,
};

export enum FHIROperationDefinition_Enum_schema {
  OperationDefinition = 'OperationDefinition'
}

export type FHIROperationDefinitionoverload = {
   __typename?: 'FHIROperationDefinitionoverload',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name of parameter to include in overload. */
  parameterName?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Comments to go on overload. */
  comment?: Maybe<Scalars['String']>,
};

export type FHIROperationDefinitionparameter = {
   __typename?: 'FHIROperationDefinitionparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of used to identify the parameter. */
  name: Scalars['FHIRCode'],
  /** Whether this is an input or an output parameter. */
  use: Scalars['FHIRCode'],
  /** The minimum number of times this parameter SHALL appear in the request or response. */
  min: Scalars['Int'],
  /** The maximum number of times this element is permitted to appear in the request or response. */
  max: Scalars['String'],
  /** Describes the meaning or use of this parameter. */
  documentation?: Maybe<Scalars['String']>,
  /** The type for this parameter. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Used when the type is 'Reference' or 'canonical', and identifies a profile
   * structure or implementation Guide that applies to the target of the reference
   * this parameter refers to. If any profiles are specified, then the content must
   * conform to at least one of them. The URL can be a local reference - to a
   * contained StructureDefinition, or a reference to another StructureDefinition
   * or Implementation Guide by a canonical URL. When an implementation guide is
   * specified, the target resource SHALL conform to at least one profile defined
   * in the implementation guide.
 */
  targetProfile?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** How the parameter is understood as a search parameter. This is only used if the parameter type is 'string'. */
  searchType?: Maybe<Scalars['FHIRCode']>,
  /** Binds to a value set if this parameter is coded (code, Coding, CodeableConcept). */
  binding?: Maybe<FHIROperationDefinitionparameterbinding>,
  /** Identifies other resource parameters within the operation invocation that are expected to resolve to this resource. */
  referencedFrom?: Maybe<Array<Maybe<FHIROperationDefinitionparameterreferencedFrom>>>,
};

export type FHIROperationDefinitionparameterbinding = {
   __typename?: 'FHIROperationDefinitionparameterbinding',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Indicates the degree of conformance expectations associated with this binding
   * - that is, the degree to which the provided value set must be adhered to in the instances.
 */
  strength: Scalars['FHIRCode'],
  /** Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used. */
  valueSet: Scalars['FHIRCanonical'],
};

export type FHIROperationDefinitionparameterreferencedFrom = {
   __typename?: 'FHIROperationDefinitionparameterreferencedFrom',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The name of the parameter or dot-separated path of parameter names pointing to
   * the resource parameter that is expected to contain a reference to this resource.
 */
  source: Scalars['String'],
  /** The id of the element in the referencing resource that is expected to resolve to this resource. */
  sourceId?: Maybe<Scalars['String']>,
};

/** A collection of error, warning, or information messages that result from a system action. */
export type FHIROperationOutcome = {
   __typename?: 'FHIROperationOutcome',
  /** Type of resource */
  resourceType: FHIROperationOutcome_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An error, warning, or information message that results from a system action. */
  issue?: Maybe<Array<FHIROperationOutcomeissue>>,
};

export enum FHIROperationOutcome_Enum_schema {
  OperationOutcome = 'OperationOutcome'
}

export type FHIROperationOutcomeissue = {
   __typename?: 'FHIROperationOutcomeissue',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates whether the issue indicates a variation from successful processing. */
  severity: Scalars['FHIRCode'],
  /** 
 * Describes the type of the issue. The system that creates an OperationOutcome
   * SHALL choose the most applicable code from the IssueType value set, and may
   * additional provide its own code for the error in the details element.
 */
  code: Scalars['FHIRCode'],
  /** 
 * Additional details about the error. This may be a text description of the
   * error or a system code that identifies the error.
 */
  details?: Maybe<FHIRCodeableConcept>,
  /** Additional diagnostic information about the issue. */
  diagnostics?: Maybe<Scalars['String']>,
  /** 
 * This element is deprecated because it is XML specific. It is replaced by
   * issue.expression, which is format independent, and simpler to parse.   For
   * resource issues, this will be a simple XPath limited to element names,
   * repetition indicators and the default child accessor that identifies one of
   * the elements in the resource that caused this issue to be raised.  For HTTP
   * errors, will be 'http.' + the parameter name.
 */
  location?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names,
   * repetition indicators and the default child accessor that identifies one of
   * the elements in the resource that caused this issue to be raised.
 */
  expression?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** 
 * A formally or informally recognized grouping of people or organizations formed
 * for the purpose of achieving some form of collective action.  Includes
 * companies, institutions, corporations, departments, community groups, healthcare
 * practice groups, payer/insurer, etc.
 */
export type FHIROrganization = {
   __typename?: 'FHIROrganization',
  /** Type of resource */
  resourceType: FHIROrganization_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the organization that is used to identify the organization across multiple disparate systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether the organization's record is still in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** The kind(s) of organization that this is. */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A name associated with the organization. */
  name?: Maybe<Scalars['String']>,
  /** A list of alternate names that the organization is known as, or was known as in the past. */
  alias?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** A contact detail for the organization. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** An address for the organization. */
  address?: Maybe<Array<Maybe<FHIRAddress>>>,
  /** The organization of which this organization forms a part. */
  partOf?: Maybe<FHIROrganizationpartOf_partOf_Union>,
  /** Contact for the organization for a certain purpose. */
  contact?: Maybe<Array<Maybe<FHIROrganizationcontact>>>,
  /** Technical endpoints providing access to services operated for the organization. */
  endpoint?: Maybe<Array<Maybe<FHIROrganizationendpoint_endpoint_Union>>>,
};

export enum FHIROrganization_Enum_schema {
  Organization = 'Organization'
}

/** 
 * Defines an affiliation/assotiation/relationship between 2 distinct oganizations,
 * that is not a part-of relationship/sub-division relationship.
 */
export type FHIROrganizationAffiliation = {
   __typename?: 'FHIROrganizationAffiliation',
  /** Type of resource */
  resourceType: FHIROrganizationAffiliation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifiers that are specific to this role. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this organization affiliation record is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** The period during which the participatingOrganization is affiliated with the primary organization. */
  period?: Maybe<FHIRPeriod>,
  /** Organization where the role is available (primary organization/has members). */
  organization?: Maybe<FHIROrganizationAffiliationorganization_organization_Union>,
  /** 
 * The Participating Organization provides/performs the role(s) defined by the
   * code to the Primary Organization (e.g. providing services or is a member of).
 */
  participatingOrganization?: Maybe<FHIROrganizationAffiliationparticipatingOrganization_participatingOrganization_Union>,
  /** 
 * Health insurance provider network in which the participatingOrganization
   * provides the role's services (if defined) at the indicated locations (if defined).
 */
  network?: Maybe<Array<Maybe<FHIROrganizationAffiliationnetwork_network_Union>>>,
  /** Definition of the role the participatingOrganization plays in the association. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Specific specialty of the participatingOrganization in the context of the role. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The location(s) at which the role occurs. */
  location?: Maybe<Array<Maybe<FHIROrganizationAffiliationlocation_location_Union>>>,
  /** Healthcare services provided through the role. */
  healthcareService?: Maybe<Array<Maybe<FHIROrganizationAffiliationhealthcareService_healthcareService_Union>>>,
  /** Contact details at the participatingOrganization relevant to this Affiliation. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Technical endpoints providing access to services operated for this role. */
  endpoint?: Maybe<Array<Maybe<FHIROrganizationAffiliationendpoint_endpoint_Union>>>,
};

export enum FHIROrganizationAffiliation_Enum_schema {
  OrganizationAffiliation = 'OrganizationAffiliation'
}

/** Technical endpoints providing access to services operated for this role. */
export type FHIROrganizationAffiliationendpoint_endpoint_Union = FHIREndpoint;

/** Healthcare services provided through the role. */
export type FHIROrganizationAffiliationhealthcareService_healthcareService_Union = FHIRHealthcareService;

/** The location(s) at which the role occurs. */
export type FHIROrganizationAffiliationlocation_location_Union = FHIRLocation;

/** 
 * Health insurance provider network in which the participatingOrganization
 * provides the role's services (if defined) at the indicated locations (if defined).
 */
export type FHIROrganizationAffiliationnetwork_network_Union = FHIROrganization;

/** Organization where the role is available (primary organization/has members). */
export type FHIROrganizationAffiliationorganization_organization_Union = FHIROrganization;

/** 
 * The Participating Organization provides/performs the role(s) defined by the code
 * to the Primary Organization (e.g. providing services or is a member of).
 */
export type FHIROrganizationAffiliationparticipatingOrganization_participatingOrganization_Union = FHIROrganization;

export type FHIROrganizationcontact = {
   __typename?: 'FHIROrganizationcontact',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates a purpose for which the contact can be reached. */
  purpose?: Maybe<FHIRCodeableConcept>,
  /** A name associated with the contact. */
  name?: Maybe<FHIRHumanName>,
  /** A contact detail (e.g. a telephone number or an email address) by which the party may be contacted. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Visiting or postal addresses for the contact. */
  address?: Maybe<FHIRAddress>,
};

/** Technical endpoints providing access to services operated for the organization. */
export type FHIROrganizationendpoint_endpoint_Union = FHIREndpoint;

/** The organization of which this organization forms a part. */
export type FHIROrganizationpartOf_partOf_Union = FHIROrganization;

export type FhirOrganizationType = {
   __typename?: 'FhirOrganizationType',
  code?: Maybe<Scalars['String']>,
  display?: Maybe<Scalars['String']>,
  definition?: Maybe<Scalars['String']>,
};

/** 
 * A condition to be used against `FhirOrganizationType` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FhirOrganizationTypeCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `display` field. */
  display?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `definition` field. */
  definition?: Maybe<Scalars['String']>,
};

/** A filter to be used against `FhirOrganizationType` object types. All fields are combined with a logical ‘and.’ */
export type FhirOrganizationTypeFilter = {
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>,
  /** Filter by the object’s `display` field. */
  display?: Maybe<StringFilter>,
  /** Filter by the object’s `definition` field. */
  definition?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FhirOrganizationTypeFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FhirOrganizationTypeFilter>>,
  /** Negates the expression. */
  not?: Maybe<FhirOrganizationTypeFilter>,
};

/** A connection to a list of `FhirOrganizationType` values. */
export type FhirOrganizationTypesConnection = {
   __typename?: 'FhirOrganizationTypesConnection',
  /** A list of `FhirOrganizationType` objects. */
  nodes: Array<FhirOrganizationType>,
  /** A list of edges which contains the `FhirOrganizationType` and cursor to aid in pagination. */
  edges: Array<FhirOrganizationTypesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `FhirOrganizationType` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `FhirOrganizationType` edge in the connection. */
export type FhirOrganizationTypesEdge = {
   __typename?: 'FhirOrganizationTypesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `FhirOrganizationType` at the end of the edge. */
  node: FhirOrganizationType,
};

/** Methods to use when ordering `FhirOrganizationType`. */
export enum FhirOrganizationTypesOrderBy {
  NATURAL = 'NATURAL',
  CODE_ASC = 'CODE_ASC',
  CODE_DESC = 'CODE_DESC',
  DISPLAY_ASC = 'DISPLAY_ASC',
  DISPLAY_DESC = 'DISPLAY_DESC',
  DEFINITION_ASC = 'DEFINITION_ASC',
  DEFINITION_DESC = 'DEFINITION_DESC'
}

/** 
 * Base StructureDefinition for ParameterDefinition Type: The parameters to the
 * module. This collection specifies both the input and output parameters. Input
 * parameters are provided by the caller as part of the $evaluate operation. Output
 * parameters are included in the GuidanceResponse.
 */
export type FHIRParameterDefinition = {
   __typename?: 'FHIRParameterDefinition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the parameter used to allow access to the value of the parameter in evaluation contexts. */
  name?: Maybe<Scalars['FHIRCode']>,
  /** Whether the parameter is input or output for the module. */
  use: Scalars['FHIRCode'],
  /** The minimum number of times this parameter SHALL appear in the request or response. */
  min?: Maybe<Scalars['Int']>,
  /** The maximum number of times this element is permitted to appear in the request or response. */
  max?: Maybe<Scalars['String']>,
  /** A brief discussion of what the parameter is for and how it is used by the module. */
  documentation?: Maybe<Scalars['String']>,
  /** The type of the parameter. */
  type: Scalars['FHIRCode'],
  /** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to. */
  profile?: Maybe<Scalars['FHIRCanonical']>,
};

/** 
 * Base StructureDefinition for ParameterDefinition Type: The parameters to the
 * module. This collection specifies both the input and output parameters. Input
 * parameters are provided by the caller as part of the $evaluate operation. Output
 * parameters are included in the GuidanceResponse.
 */
export type FHIRParameterDefinition_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The name of the parameter used to allow access to the value of the parameter in evaluation contexts. */
  _name?: Maybe<FHIRElement_Input>,
  /** The name of the parameter used to allow access to the value of the parameter in evaluation contexts. */
  name?: Maybe<Scalars['FHIRCode']>,
  /** Whether the parameter is input or output for the module. */
  _use?: Maybe<FHIRElement_Input>,
  /** Whether the parameter is input or output for the module. */
  use: Scalars['FHIRCode'],
  /** The minimum number of times this parameter SHALL appear in the request or response. */
  _min?: Maybe<FHIRElement_Input>,
  /** The minimum number of times this parameter SHALL appear in the request or response. */
  min?: Maybe<Scalars['Int']>,
  /** The maximum number of times this element is permitted to appear in the request or response. */
  _max?: Maybe<FHIRElement_Input>,
  /** The maximum number of times this element is permitted to appear in the request or response. */
  max?: Maybe<Scalars['String']>,
  /** A brief discussion of what the parameter is for and how it is used by the module. */
  _documentation?: Maybe<FHIRElement_Input>,
  /** A brief discussion of what the parameter is for and how it is used by the module. */
  documentation?: Maybe<Scalars['String']>,
  /** The type of the parameter. */
  _type?: Maybe<FHIRElement_Input>,
  /** The type of the parameter. */
  type: Scalars['FHIRCode'],
  /** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to. */
  _profile?: Maybe<FHIRElement_Input>,
  /** If specified, this indicates a profile that the input data must conform to, or that the output data will conform to. */
  profile?: Maybe<Scalars['FHIRCanonical']>,
};

/** 
 * This resource is a non-persisted resource used to pass information into and back
 * from an [operation](operations.html). It has no other use, and there is no
 * RESTful endpoint associated with it.
 */
export type FHIRParameters = {
   __typename?: 'FHIRParameters',
  /** Type of resource */
  resourceType: FHIRParameters_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** A parameter passed to or received from the operation. */
  parameter?: Maybe<Array<Maybe<FHIRParametersparameter>>>,
};

export enum FHIRParameters_Enum_schema {
  Parameters = 'Parameters'
}

export type FHIRParametersparameter = {
   __typename?: 'FHIRParametersparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the parameter (reference to the operation definition). */
  name: Scalars['String'],
  /** If the parameter is a data type. */
  valueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** If the parameter is a data type. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** If the parameter is a data type. */
  valueCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** If the parameter is a data type. */
  valueCode?: Maybe<Scalars['FHIRCode']>,
  /** If the parameter is a data type. */
  valueDate?: Maybe<Scalars['FHIRDate']>,
  /** If the parameter is a data type. */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** If the parameter is a data type. */
  valueDecimal?: Maybe<Scalars['Float']>,
  /** If the parameter is a data type. */
  valueId?: Maybe<Scalars['FHIRId']>,
  /** If the parameter is a data type. */
  valueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** If the parameter is a data type. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** If the parameter is a data type. */
  valueMarkdown?: Maybe<Scalars['String']>,
  /** If the parameter is a data type. */
  valueOid?: Maybe<Scalars['FHIROid']>,
  /** If the parameter is a data type. */
  valuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** If the parameter is a data type. */
  valueString?: Maybe<Scalars['String']>,
  /** If the parameter is a data type. */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** If the parameter is a data type. */
  valueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** If the parameter is a data type. */
  valueUri?: Maybe<Scalars['FHIRUri']>,
  /** If the parameter is a data type. */
  valueUrl?: Maybe<Scalars['FHIRUrl']>,
  /** If the parameter is a data type. */
  valueUuid?: Maybe<Scalars['FHIRUuid']>,
  /** If the parameter is a data type. */
  valueAddress?: Maybe<FHIRAddress>,
  /** If the parameter is a data type. */
  valueAge?: Maybe<FHIRAge>,
  /** If the parameter is a data type. */
  valueAnnotation?: Maybe<FHIRAnnotation>,
  /** If the parameter is a data type. */
  valueAttachment?: Maybe<FHIRAttachment>,
  /** If the parameter is a data type. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** If the parameter is a data type. */
  valueCoding?: Maybe<FHIRCoding>,
  /** If the parameter is a data type. */
  valueContactPoint?: Maybe<FHIRContactPoint>,
  /** If the parameter is a data type. */
  valueCount?: Maybe<FHIRCount>,
  /** If the parameter is a data type. */
  valueDistance?: Maybe<FHIRDistance>,
  /** If the parameter is a data type. */
  valueDuration?: Maybe<FHIRDuration>,
  /** If the parameter is a data type. */
  valueHumanName?: Maybe<FHIRHumanName>,
  /** If the parameter is a data type. */
  valueIdentifier?: Maybe<FHIRIdentifier>,
  /** If the parameter is a data type. */
  valueMoney?: Maybe<FHIRMoney>,
  /** If the parameter is a data type. */
  valuePeriod?: Maybe<FHIRPeriod>,
  /** If the parameter is a data type. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** If the parameter is a data type. */
  valueRange?: Maybe<FHIRRange>,
  /** If the parameter is a data type. */
  valueRatio?: Maybe<FHIRRatio>,
  /** If the parameter is a data type. */
  valueReference?: Maybe<FHIRResourceList>,
  /** If the parameter is a data type. */
  valueSampledData?: Maybe<FHIRSampledData>,
  /** If the parameter is a data type. */
  valueSignature?: Maybe<FHIRSignature>,
  /** If the parameter is a data type. */
  valueTiming?: Maybe<FHIRTiming>,
  /** If the parameter is a data type. */
  valueContactDetail?: Maybe<FHIRContactDetail>,
  /** If the parameter is a data type. */
  valueContributor?: Maybe<FHIRContributor>,
  /** If the parameter is a data type. */
  valueDataRequirement?: Maybe<FHIRDataRequirement>,
  /** If the parameter is a data type. */
  valueExpression?: Maybe<FHIRExpression>,
  /** If the parameter is a data type. */
  valueParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** If the parameter is a data type. */
  valueRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** If the parameter is a data type. */
  valueTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** If the parameter is a data type. */
  valueUsageContext?: Maybe<FHIRUsageContext>,
  /** If the parameter is a data type. */
  valueDosage?: Maybe<FHIRDosage>,
  /** If the parameter is a whole resource. */
  resource?: Maybe<FHIRResourceList>,
};

/** 
 * Demographics and other administrative information about an individual or animal
 * receiving care or other health-related services.
 */
export type FHIRPatient = {
   __typename?: 'FHIRPatient',
  /** Type of resource */
  resourceType: FHIRPatient_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An identifier for this patient. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * Whether this patient record is in active use.  Many systems use this property
   * to mark as non-current patients, such as those that have not been seen for a
   * period of time based on an organization's business rules.  It is often used to
   * filter patient lists to exclude inactive patients  Deceased patients may also
   * be marked as inactive for the same reasons, but may be active for some time after death.
 */
  active?: Maybe<Scalars['Boolean']>,
  /** A name associated with the individual. */
  name?: Maybe<Array<Maybe<FHIRHumanName>>>,
  /** A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes. */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** The date of birth for the individual. */
  birthDate?: Maybe<Scalars['FHIRDate']>,
  /** Indicates if the individual is deceased or not. */
  deceasedBoolean?: Maybe<Scalars['Boolean']>,
  /** Indicates if the individual is deceased or not. */
  deceasedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** An address for the individual. */
  address?: Maybe<Array<Maybe<FHIRAddress>>>,
  /** This field contains a patient's most recent marital (civil) status. */
  maritalStatus?: Maybe<FHIRCodeableConcept>,
  /** Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). */
  multipleBirthBoolean?: Maybe<Scalars['Boolean']>,
  /** Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). */
  multipleBirthInteger?: Maybe<Scalars['Int']>,
  /** Image of the patient. */
  photo?: Maybe<Array<Maybe<FHIRAttachment>>>,
  /** A contact party (e.g. guardian, partner, friend) for the patient. */
  contact?: Maybe<Array<Maybe<FHIRPatientcontact>>>,
  /** A language which may be used to communicate with the patient about his or her health. */
  communication?: Maybe<Array<Maybe<FHIRPatientcommunication>>>,
  /** Patient's nominated care provider. */
  generalPractitioner?: Maybe<Array<Maybe<FHIRPatientgeneralPractitioner_generalPractitioner_Union>>>,
  /** Organization that is the custodian of the patient record. */
  managingOrganization?: Maybe<FHIRPatientmanagingOrganization_managingOrganization_Union>,
  /** Link to another patient resource that concerns the same actual patient. */
  link?: Maybe<Array<Maybe<FHIRPatientlink>>>,
  allergyIntolerances?: Maybe<FHIRAllergyIntoleranceList>,
  observations?: Maybe<FHIRObservationList>,
  nutritionOrders?: Maybe<FHIRNutritionOrderList>,
};


/** 
 * Demographics and other administrative information about an individual or animal
 * receiving care or other health-related services.
 */
export type FHIRPatientallergyIntolerancesArgs = {
  after?: Maybe<Scalars['String']>
};


/** 
 * Demographics and other administrative information about an individual or animal
 * receiving care or other health-related services.
 */
export type FHIRPatientobservationsArgs = {
  after?: Maybe<Scalars['String']>
};


/** 
 * Demographics and other administrative information about an individual or animal
 * receiving care or other health-related services.
 */
export type FHIRPatientnutritionOrdersArgs = {
  after?: Maybe<Scalars['String']>
};

export enum FHIRPatient_Enum_schema {
  Patient = 'Patient'
}

export type FHIRPatientcommunication = {
   __typename?: 'FHIRPatientcommunication',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The ISO-639-1 alpha 2 code in lower case for the language, optionally followed
   * by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g.
   * 'en' for English, or 'en-US' for American English versus 'en-EN' for England English.
 */
  language: FHIRCodeableConcept,
  /** Indicates whether or not the patient prefers this language (over other languages he masters up a certain level). */
  preferred?: Maybe<Scalars['Boolean']>,
};

export type FHIRPatientcontact = {
   __typename?: 'FHIRPatientcontact',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The nature of the relationship between the patient and the contact person. */
  relationship?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A name associated with the contact person. */
  name?: Maybe<FHIRHumanName>,
  /** A contact detail for the person, e.g. a telephone number or an email address. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Address for the contact person. */
  address?: Maybe<FHIRAddress>,
  /** 
 * Administrative Gender - the gender that the contact person is considered to
   * have for administration and record keeping purposes.
 */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** Organization on behalf of which the contact is acting or for which the contact is working. */
  organization?: Maybe<FHIRPatientcontactorganization_organization_Union>,
  /** The period during which this contact person or organization is valid to be contacted relating to this patient. */
  period?: Maybe<FHIRPeriod>,
};

/** Organization on behalf of which the contact is acting or for which the contact is working. */
export type FHIRPatientcontactorganization_organization_Union = FHIROrganization;

/** Patient's nominated care provider. */
export type FHIRPatientgeneralPractitioner_generalPractitioner_Union = FHIROrganization | FHIRPractitioner | FHIRPractitionerRole;

export type FHIRPatientlink = {
   __typename?: 'FHIRPatientlink',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The other patient resource that the link refers to. */
  other: FHIRPatientlinkother_other_Union,
  /** The type of link between this patient resource and another patient resource. */
  type: Scalars['FHIRCode'],
};

/** The other patient resource that the link refers to. */
export type FHIRPatientlinkother_other_Union = FHIRPatient | FHIRRelatedPerson;

export type FHIRPatientList = {
   __typename?: 'FHIRPatientList',
  nodes?: Maybe<Array<Maybe<FHIRPatient>>>,
  listInfo?: Maybe<FHIRListInfo>,
};

/** Organization that is the custodian of the patient record. */
export type FHIRPatientmanagingOrganization_managingOrganization_Union = FHIROrganization;

export enum FHIRPatientOrderBy {
  ID_DESC = 'ID_DESC',
  ID_ASC = 'ID_ASC',
  BIRTHDATE_DESC = 'BIRTHDATE_DESC',
  BIRTHDATE_ASC = 'BIRTHDATE_ASC'
}

/** 
 * This resource provides the status of the payment for goods and services
 * rendered, and the request and response resource references.
 */
export type FHIRPaymentNotice = {
   __typename?: 'FHIRPaymentNotice',
  /** Type of resource */
  resourceType: FHIRPaymentNotice_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this payment notice. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** Reference of resource for which payment is being made. */
  request?: Maybe<FHIRPaymentNoticerequest_request_Union>,
  /** Reference of response to resource for which payment is being made. */
  response?: Maybe<FHIRPaymentNoticeresponse_response_Union>,
  /** The date when this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** The practitioner who is responsible for the services rendered to the patient. */
  provider?: Maybe<FHIRPaymentNoticeprovider_provider_Union>,
  /** A reference to the payment which is the subject of this notice. */
  payment: FHIRPaymentNoticepayment_payment_Union,
  /** The date when the above payment action occurred. */
  paymentDate?: Maybe<Scalars['FHIRDate']>,
  /** The party who will receive or has received payment that is the subject of this notification. */
  payee?: Maybe<FHIRPaymentNoticepayee_payee_Union>,
  /** The party who is notified of the payment status. */
  recipient: FHIRPaymentNoticerecipient_recipient_Union,
  /** The amount sent to the payee. */
  amount: FHIRMoney,
  /** A code indicating whether payment has been sent or cleared. */
  paymentStatus?: Maybe<FHIRCodeableConcept>,
};

export enum FHIRPaymentNotice_Enum_schema {
  PaymentNotice = 'PaymentNotice'
}

/** The party who will receive or has received payment that is the subject of this notification. */
export type FHIRPaymentNoticepayee_payee_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** A reference to the payment which is the subject of this notice. */
export type FHIRPaymentNoticepayment_payment_Union = FHIRPaymentReconciliation;

/** The practitioner who is responsible for the services rendered to the patient. */
export type FHIRPaymentNoticeprovider_provider_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** The party who is notified of the payment status. */
export type FHIRPaymentNoticerecipient_recipient_Union = FHIROrganization;

/** Reference of resource for which payment is being made. */
export type FHIRPaymentNoticerequest_request_Union = FHIRResource;

/** Reference of response to resource for which payment is being made. */
export type FHIRPaymentNoticeresponse_response_Union = FHIRResource;

/** This resource provides the details including amount of a payment and allocates the payment items being paid. */
export type FHIRPaymentReconciliation = {
   __typename?: 'FHIRPaymentReconciliation',
  /** Type of resource */
  resourceType: FHIRPaymentReconciliation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this payment reconciliation. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** The period of time for which payments have been gathered into this bulk payment for settlement. */
  period?: Maybe<FHIRPeriod>,
  /** The date when the resource was created. */
  created: Scalars['FHIRDateTime'],
  /** The party who generated the payment. */
  paymentIssuer?: Maybe<FHIRPaymentReconciliationpaymentIssuer_paymentIssuer_Union>,
  /** Original request resource reference. */
  request?: Maybe<FHIRPaymentReconciliationrequest_request_Union>,
  /** The practitioner who is responsible for the services rendered to the patient. */
  requestor?: Maybe<FHIRPaymentReconciliationrequestor_requestor_Union>,
  /** The outcome of a request for a reconciliation. */
  outcome?: Maybe<Scalars['FHIRCode']>,
  /** A human readable description of the status of the request for the reconciliation. */
  disposition?: Maybe<Scalars['String']>,
  /** The date of payment as indicated on the financial instrument. */
  paymentDate: Scalars['FHIRDate'],
  /** Total payment amount as indicated on the financial instrument. */
  paymentAmount: FHIRMoney,
  /** Issuer's unique identifier for the payment instrument. */
  paymentIdentifier?: Maybe<FHIRIdentifier>,
  /** Distribution of the payment amount for a previously acknowledged payable. */
  detail?: Maybe<Array<Maybe<FHIRPaymentReconciliationdetail>>>,
  /** A code for the form to be used for printing the content. */
  formCode?: Maybe<FHIRCodeableConcept>,
  /** A note that describes or explains the processing in a human readable form. */
  processNote?: Maybe<Array<Maybe<FHIRPaymentReconciliationprocessNote>>>,
};

export enum FHIRPaymentReconciliation_Enum_schema {
  PaymentReconciliation = 'PaymentReconciliation'
}

export type FHIRPaymentReconciliationdetail = {
   __typename?: 'FHIRPaymentReconciliationdetail',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for the current payment item for the referenced payable. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Unique identifier for the prior payment item for the referenced payable. */
  predecessor?: Maybe<FHIRIdentifier>,
  /** Code to indicate the nature of the payment. */
  type: FHIRCodeableConcept,
  /** A resource, such as a Claim, the evaluation of which could lead to payment. */
  request?: Maybe<FHIRPaymentReconciliationdetailrequest_request_Union>,
  /** The party which submitted the claim or financial transaction. */
  submitter?: Maybe<FHIRPaymentReconciliationdetailsubmitter_submitter_Union>,
  /** A resource, such as a ClaimResponse, which contains a commitment to payment. */
  response?: Maybe<FHIRPaymentReconciliationdetailresponse_response_Union>,
  /** The date from the response resource containing a commitment to pay. */
  date?: Maybe<Scalars['FHIRDate']>,
  /** A reference to the individual who is responsible for inquiries regarding the response and its payment. */
  responsible?: Maybe<FHIRPaymentReconciliationdetailresponsible_responsible_Union>,
  /** The party which is receiving the payment. */
  payee?: Maybe<FHIRPaymentReconciliationdetailpayee_payee_Union>,
  /** The monetary amount allocated from the total payment to the payable. */
  amount?: Maybe<FHIRMoney>,
};

/** The party which is receiving the payment. */
export type FHIRPaymentReconciliationdetailpayee_payee_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** A resource, such as a Claim, the evaluation of which could lead to payment. */
export type FHIRPaymentReconciliationdetailrequest_request_Union = FHIRResource;

/** A resource, such as a ClaimResponse, which contains a commitment to payment. */
export type FHIRPaymentReconciliationdetailresponse_response_Union = FHIRResource;

/** A reference to the individual who is responsible for inquiries regarding the response and its payment. */
export type FHIRPaymentReconciliationdetailresponsible_responsible_Union = FHIRPractitionerRole;

/** The party which submitted the claim or financial transaction. */
export type FHIRPaymentReconciliationdetailsubmitter_submitter_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** The party who generated the payment. */
export type FHIRPaymentReconciliationpaymentIssuer_paymentIssuer_Union = FHIROrganization;

export type FHIRPaymentReconciliationprocessNote = {
   __typename?: 'FHIRPaymentReconciliationprocessNote',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The business purpose of the note text. */
  type?: Maybe<Scalars['FHIRCode']>,
  /** The explanation or description associated with the processing. */
  text?: Maybe<Scalars['String']>,
};

/** Original request resource reference. */
export type FHIRPaymentReconciliationrequest_request_Union = FHIRTask;

/** The practitioner who is responsible for the services rendered to the patient. */
export type FHIRPaymentReconciliationrequestor_requestor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time. */
export type FHIRPeriod = {
   __typename?: 'FHIRPeriod',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The start of the period. The boundary is inclusive. */
  start?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The end of the period. If the end of the period is missing, it means no end
   * was known or planned at the time the instance was created. The start may be in
   * the past, and the end date in the future, which means that period is
   * expected/planned to end at that time.
 */
  end?: Maybe<Scalars['FHIRDateTime']>,
};

/** Base StructureDefinition for Period Type: A time period defined by a start and end date and optionally time. */
export type FHIRPeriod_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The start of the period. The boundary is inclusive. */
  _start?: Maybe<FHIRElement_Input>,
  /** The start of the period. The boundary is inclusive. */
  start?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The end of the period. If the end of the period is missing, it means no end
   * was known or planned at the time the instance was created. The start may be in
   * the past, and the end date in the future, which means that period is
   * expected/planned to end at that time.
 */
  _end?: Maybe<FHIRElement_Input>,
  /** 
 * The end of the period. If the end of the period is missing, it means no end
   * was known or planned at the time the instance was created. The start may be in
   * the past, and the end date in the future, which means that period is
   * expected/planned to end at that time.
 */
  end?: Maybe<Scalars['FHIRDateTime']>,
};

/** Demographics and administrative information about a person independent of a specific health-related context. */
export type FHIRPerson = {
   __typename?: 'FHIRPerson',
  /** Type of resource */
  resourceType: FHIRPerson_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for a person within a particular scope. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A name associated with the person. */
  name?: Maybe<Array<Maybe<FHIRHumanName>>>,
  /** A contact detail for the person, e.g. a telephone number or an email address. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Administrative Gender. */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** The birth date for the person. */
  birthDate?: Maybe<Scalars['FHIRDate']>,
  /** One or more addresses for the person. */
  address?: Maybe<Array<Maybe<FHIRAddress>>>,
  /** An image that can be displayed as a thumbnail of the person to enhance the identification of the individual. */
  photo?: Maybe<FHIRAttachment>,
  /** The organization that is the custodian of the person record. */
  managingOrganization?: Maybe<FHIRPersonmanagingOrganization_managingOrganization_Union>,
  /** Whether this person's record is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** Link to a resource that concerns the same actual person. */
  link?: Maybe<Array<Maybe<FHIRPersonlink>>>,
};

export enum FHIRPerson_Enum_schema {
  Person = 'Person'
}

export type FHIRPersonlink = {
   __typename?: 'FHIRPersonlink',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The resource to which this actual person is associated. */
  target: FHIRPersonlinktarget_target_Union,
  /** Level of assurance that this link is associated with the target resource. */
  assurance?: Maybe<Scalars['FHIRCode']>,
};

/** The resource to which this actual person is associated. */
export type FHIRPersonlinktarget_target_Union = FHIRPatient | FHIRPractitioner | FHIRRelatedPerson | FHIRPerson;

/** The organization that is the custodian of the person record. */
export type FHIRPersonmanagingOrganization_managingOrganization_Union = FHIROrganization;

/** 
 * This resource allows for the definition of various types of plans as a sharable,
 * consumable, and executable artifact. The resource is general enough to support
 * the description of a broad range of clinical artifacts such as clinical decision
 * support rules, order sets and protocols.
 */
export type FHIRPlanDefinition = {
   __typename?: 'FHIRPlanDefinition',
  /** Type of resource */
  resourceType: FHIRPlanDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this plan definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this plan definition is
   * (or will be) published. This URL can be the target of a canonical reference.
   * It SHALL remain the same when the plan definition is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this plan definition when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the plan definition
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the plan definition author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence. To provide a version consistent
   * with the Decision Support Service specification, use the format
   * Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
   * knowledge assets, refer to the Decision Support Service specification. Note
   * that a version is required for non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the plan definition. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the plan definition. */
  title?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the plan definition giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** 
 * A high-level category for the plan definition that distinguishes the kinds of
   * systems that would be interested in the plan definition.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The status of this plan definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this plan definition is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** A code or group definition that describes the intended subject of the plan definition. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A code or group definition that describes the intended subject of the plan definition. */
  subjectReference?: Maybe<FHIRPlanDefinitionsubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the plan definition was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the plan definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the plan definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the plan definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate plan
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the plan definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this plan definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description of how the plan definition is used from a clinical perspective. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the plan definition and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the plan definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the plan definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the plan definition. Topics
   * provide a high-level categorization of the definition that can be useful for
   * filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a Library resource containing any formal logic used by the plan definition. */
  library?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * Goals that describe what the activities within the plan are intended to
   * achieve. For example, weight loss, restoring an activity of daily living,
   * obtaining herd immunity via immunization, meeting a process improvement
   * objective, etc.
 */
  goal?: Maybe<Array<Maybe<FHIRPlanDefinitiongoal>>>,
  /** An action or group of actions to be taken as part of the plan. */
  action?: Maybe<Array<Maybe<FHIRPlanDefinitionaction>>>,
};

export enum FHIRPlanDefinition_Enum_schema {
  PlanDefinition = 'PlanDefinition'
}

export type FHIRPlanDefinitionaction = {
   __typename?: 'FHIRPlanDefinitionaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A user-visible prefix for the action. */
  prefix?: Maybe<Scalars['String']>,
  /** The title of the action displayed to a user. */
  title?: Maybe<Scalars['String']>,
  /** A brief description of the action used to provide a summary to display to the user. */
  description?: Maybe<Scalars['String']>,
  /** 
 * A text equivalent of the action to be performed. This provides a
   * human-interpretable description of the action when the definition is consumed
   * by a system that might not be capable of interpreting it dynamically.
 */
  textEquivalent?: Maybe<Scalars['String']>,
  /** Indicates how quickly the action should be addressed with respect to other actions. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A code that provides meaning for the action or action group. For example, a
   * section may have a LOINC code for the section of a documentation template.
 */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A description of why this action is necessary or appropriate. */
  reason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Didactic or other informational resources associated with the action that can
   * be provided to the CDS recipient. Information resources can include inline
   * text commentary and links to web resources.
 */
  documentation?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** Identifies goals that this action supports. The reference must be to a goal element defined within this plan definition. */
  goalId?: Maybe<Array<Maybe<Scalars['FHIRId']>>>,
  /** A code or group definition that describes the intended subject of the action and its children, if any. */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A code or group definition that describes the intended subject of the action and its children, if any. */
  subjectReference?: Maybe<FHIRPlanDefinitionactionsubjectReference_subjectReference_Union>,
  /** A description of when the action should be triggered. */
  trigger?: Maybe<Array<Maybe<FHIRTriggerDefinition>>>,
  /** An expression that describes applicability criteria or start/stop conditions for the action. */
  condition?: Maybe<Array<Maybe<FHIRPlanDefinitionactioncondition>>>,
  /** Defines input data requirements for the action. */
  input?: Maybe<Array<Maybe<FHIRDataRequirement>>>,
  /** Defines the outputs of the action, if any. */
  output?: Maybe<Array<Maybe<FHIRDataRequirement>>>,
  /** A relationship to another action such as 'before' or '30-60 minutes after start of'. */
  relatedAction?: Maybe<Array<Maybe<FHIRPlanDefinitionactionrelatedAction>>>,
  /** An optional value describing when the action should be performed. */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** An optional value describing when the action should be performed. */
  timingAge?: Maybe<FHIRAge>,
  /** An optional value describing when the action should be performed. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** An optional value describing when the action should be performed. */
  timingDuration?: Maybe<FHIRDuration>,
  /** An optional value describing when the action should be performed. */
  timingRange?: Maybe<FHIRRange>,
  /** An optional value describing when the action should be performed. */
  timingTiming?: Maybe<FHIRTiming>,
  /** Indicates who should participate in performing the action described. */
  participant?: Maybe<Array<Maybe<FHIRPlanDefinitionactionparticipant>>>,
  /** The type of action to perform (create, update, remove). */
  type?: Maybe<FHIRCodeableConcept>,
  /** Defines the grouping behavior for the action and its children. */
  groupingBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines the selection behavior for the action and its children. */
  selectionBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines the required behavior for the action. */
  requiredBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines whether the action should usually be preselected. */
  precheckBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines whether the action can be selected multiple times. */
  cardinalityBehavior?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A reference to an ActivityDefinition that describes the action to be taken in
   * detail, or a PlanDefinition that describes a series of actions to be taken.
 */
  definitionCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * A reference to an ActivityDefinition that describes the action to be taken in
   * detail, or a PlanDefinition that describes a series of actions to be taken.
 */
  definitionUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A reference to a StructureMap resource that defines a transform that can be
   * executed to produce the intent resource using the ActivityDefinition instance as the input.
 */
  transform?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * Customizations that should be applied to the statically defined resource. For
   * example, if the dosage of a medication must be computed based on the patient's
   * weight, a customization would be used to specify an expression that calculated
   * the weight, and the path on the resource that would contain the result.
 */
  dynamicValue?: Maybe<Array<Maybe<FHIRPlanDefinitionactiondynamicValue>>>,
};

export type FHIRPlanDefinitionactioncondition = {
   __typename?: 'FHIRPlanDefinitionactioncondition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of condition. */
  kind: Scalars['FHIRCode'],
  /** An expression that returns true or false, indicating whether the condition is satisfied. */
  expression?: Maybe<FHIRExpression>,
};

export type FHIRPlanDefinitionactiondynamicValue = {
   __typename?: 'FHIRPlanDefinitionactiondynamicValue',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The path to the element to be customized. This is the path on the resource
   * that will hold the result of the calculation defined by the expression. The
   * specified path SHALL be a FHIRPath resolveable on the specified target type of
   * the ActivityDefinition, and SHALL consist only of identifiers, constant
   * indexers, and a restricted subset of functions. The path is allowed to contain
   * qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse
   * multiple-cardinality sub-elements (see the [Simple FHIRPath
   * Profile](fhirpath.html#simple) for full details).
 */
  path?: Maybe<Scalars['String']>,
  /** An expression specifying the value of the customized element. */
  expression?: Maybe<FHIRExpression>,
};

export type FHIRPlanDefinitionactionparticipant = {
   __typename?: 'FHIRPlanDefinitionactionparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of participant in the action. */
  type: Scalars['FHIRCode'],
  /** The role the participant should play in performing the described action. */
  role?: Maybe<FHIRCodeableConcept>,
};

export type FHIRPlanDefinitionactionrelatedAction = {
   __typename?: 'FHIRPlanDefinitionactionrelatedAction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The element id of the related action. */
  actionId: Scalars['FHIRId'],
  /** The relationship of this action to the related action. */
  relationship: Scalars['FHIRCode'],
  /** A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. */
  offsetDuration?: Maybe<FHIRDuration>,
  /** A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. */
  offsetRange?: Maybe<FHIRRange>,
};

/** A code or group definition that describes the intended subject of the action and its children, if any. */
export type FHIRPlanDefinitionactionsubjectReference_subjectReference_Union = FHIRGroup;

export type FHIRPlanDefinitiongoal = {
   __typename?: 'FHIRPlanDefinitiongoal',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates a category the goal falls within. */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * Human-readable and/or coded description of a specific desired objective of
   * care, such as 'control blood pressure' or 'negotiate an obstacle course' or
   * 'dance with child at wedding'.
 */
  description: FHIRCodeableConcept,
  /** Identifies the expected level of importance associated with reaching/sustaining the defined goal. */
  priority?: Maybe<FHIRCodeableConcept>,
  /** The event after which the goal should begin being pursued. */
  start?: Maybe<FHIRCodeableConcept>,
  /** Identifies problems, conditions, issues, or concerns the goal is intended to address. */
  addresses?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Didactic or other informational resources associated with the goal that
   * provide further supporting information about the goal. Information resources
   * can include inline text commentary and links to web resources.
 */
  documentation?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** Indicates what should be done and within what timeframe. */
  target?: Maybe<Array<Maybe<FHIRPlanDefinitiongoaltarget>>>,
};

export type FHIRPlanDefinitiongoaltarget = {
   __typename?: 'FHIRPlanDefinitiongoaltarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The parameter whose value is to be tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. */
  measure?: Maybe<FHIRCodeableConcept>,
  /** 
 * The target value of the measure to be achieved to signify fulfillment of the
   * goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any value at or below the high value. Similarly, if the
   * high value is missing, it indicates that the goal is achieved at any value at
   * or above the low value.
 */
  detailQuantity?: Maybe<FHIRQuantity>,
  /** 
 * The target value of the measure to be achieved to signify fulfillment of the
   * goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any value at or below the high value. Similarly, if the
   * high value is missing, it indicates that the goal is achieved at any value at
   * or above the low value.
 */
  detailRange?: Maybe<FHIRRange>,
  /** 
 * The target value of the measure to be achieved to signify fulfillment of the
   * goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the
   * range can be specified. When a low value is missing, it indicates that the
   * goal is achieved at any value at or below the high value. Similarly, if the
   * high value is missing, it indicates that the goal is achieved at any value at
   * or above the low value.
 */
  detailCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Indicates the timeframe after the start of the goal in which the goal should be met. */
  due?: Maybe<FHIRDuration>,
};

/** A code or group definition that describes the intended subject of the plan definition. */
export type FHIRPlanDefinitionsubjectReference_subjectReference_Union = FHIRGroup;

/** Base StructureDefinition for Population Type: A populatioof people with some set of grouping criteria. */
export type FHIRPopulation = {
   __typename?: 'FHIRPopulation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The age of the specific population. */
  ageRange?: Maybe<FHIRRange>,
  /** The age of the specific population. */
  ageCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The gender of the specific population. */
  gender?: Maybe<FHIRCodeableConcept>,
  /** Race of the specific population. */
  race?: Maybe<FHIRCodeableConcept>,
  /** The existing physiological conditions of the specific population to which this applies. */
  physiologicalCondition?: Maybe<FHIRCodeableConcept>,
};


/** A person who is directly or indirectly involved in the provisioning of healthcare. */
export type FHIRPractitioner = {
   __typename?: 'FHIRPractitioner',
  /** Type of resource */
  resourceType: FHIRPractitioner_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An identifier that applies to this person in this role. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this practitioner's record is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** The name(s) associated with the practitioner. */
  name?: Maybe<Array<Maybe<FHIRHumanName>>>,
  /** A contact detail for the practitioner, e.g. a telephone number or an email address. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** 
 * Address(es) of the practitioner that are not role specific (typically home
   * address).  Work addresses are not typically entered in this property as they
   * are usually role dependent.
 */
  address?: Maybe<Array<Maybe<FHIRAddress>>>,
  /** Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes. */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** The date of birth for the practitioner. */
  birthDate?: Maybe<Scalars['FHIRDate']>,
  /** Image of the person. */
  photo?: Maybe<Array<Maybe<FHIRAttachment>>>,
  /** 
 * The official certifications, training, and licenses that authorize or
   * otherwise pertain to the provision of care by the practitioner.  For example,
   * a medical license issued by a medical board authorizing the practitioner to
   * practice medicine within a certian locality.
 */
  qualification?: Maybe<Array<Maybe<FHIRPractitionerqualification>>>,
  /** A language the practitioner can use in patient communication. */
  communication?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export enum FHIRPractitioner_Enum_schema {
  Practitioner = 'Practitioner'
}

export type FHIRPractitionerqualification = {
   __typename?: 'FHIRPractitionerqualification',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An identifier that applies to this person's qualification in this role. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Coded representation of the qualification. */
  code: FHIRCodeableConcept,
  /** Period during which the qualification is valid. */
  period?: Maybe<FHIRPeriod>,
  /** Organization that regulates and issues the qualification. */
  issuer?: Maybe<FHIRPractitionerqualificationissuer_issuer_Union>,
};

/** Organization that regulates and issues the qualification. */
export type FHIRPractitionerqualificationissuer_issuer_Union = FHIROrganization;

/** 
 * A specific set of Roles/Locations/specialties/services that a practitioner may
 * perform at an organization for a period of time.
 */
export type FHIRPractitionerRole = {
   __typename?: 'FHIRPractitionerRole',
  /** Type of resource */
  resourceType: FHIRPractitionerRole_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business Identifiers that are specific to a role/location. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this practitioner role record is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** The period during which the person is authorized to act as a practitioner in these role(s) for the organization. */
  period?: Maybe<FHIRPeriod>,
  /** Practitioner that is able to provide the defined services for the organization. */
  practitioner?: Maybe<FHIRPractitionerRolepractitioner_practitioner_Union>,
  /** The organization where the Practitioner performs the roles associated. */
  organization?: Maybe<FHIRPractitionerRoleorganization_organization_Union>,
  /** Roles which this practitioner is authorized to perform for the organization. */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Specific specialty of the practitioner. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The location(s) at which this practitioner provides care. */
  location?: Maybe<Array<Maybe<FHIRPractitionerRolelocation_location_Union>>>,
  /** The list of healthcare services that this worker provides for this role's Organization/Location(s). */
  healthcareService?: Maybe<Array<Maybe<FHIRPractitionerRolehealthcareService_healthcareService_Union>>>,
  /** Contact details that are specific to the role/location/service. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** A collection of times the practitioner is available or performing this role at the location and/or healthcareservice. */
  availableTime?: Maybe<Array<Maybe<FHIRPractitionerRoleavailableTime>>>,
  /** The practitioner is not available or performing this role during this period of time due to the provided reason. */
  notAvailable?: Maybe<Array<Maybe<FHIRPractitionerRolenotAvailable>>>,
  /** 
 * A description of site availability exceptions, e.g. public holiday
   * availability. Succinctly describing all possible exceptions to normal site
   * availability as details in the available Times and not available Times.
 */
  availabilityExceptions?: Maybe<Scalars['String']>,
  /** Technical endpoints providing access to services operated for the practitioner with this role. */
  endpoint?: Maybe<Array<Maybe<FHIRPractitionerRoleendpoint_endpoint_Union>>>,
};

export enum FHIRPractitionerRole_Enum_schema {
  PractitionerRole = 'PractitionerRole'
}

export type FHIRPractitionerRoleavailableTime = {
   __typename?: 'FHIRPractitionerRoleavailableTime',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates which days of the week are available between the start and end Times. */
  daysOfWeek?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Is this always available? (hence times are irrelevant) e.g. 24 hour service. */
  allDay?: Maybe<Scalars['Boolean']>,
  /** The opening time of day. Note: If the AllDay flag is set, then this time is ignored. */
  availableStartTime?: Maybe<Scalars['FHIRTime']>,
  /** The closing time of day. Note: If the AllDay flag is set, then this time is ignored. */
  availableEndTime?: Maybe<Scalars['FHIRTime']>,
};

/** Technical endpoints providing access to services operated for the practitioner with this role. */
export type FHIRPractitionerRoleendpoint_endpoint_Union = FHIREndpoint;

/** The list of healthcare services that this worker provides for this role's Organization/Location(s). */
export type FHIRPractitionerRolehealthcareService_healthcareService_Union = FHIRHealthcareService;

/** The location(s) at which this practitioner provides care. */
export type FHIRPractitionerRolelocation_location_Union = FHIRLocation;

export type FHIRPractitionerRolenotAvailable = {
   __typename?: 'FHIRPractitionerRolenotAvailable',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The reason that can be presented to the user as to why this time is not available. */
  description: Scalars['String'],
  /** Service is not available (seasonally or for a public holiday) from this date. */
  during?: Maybe<FHIRPeriod>,
};

/** The organization where the Practitioner performs the roles associated. */
export type FHIRPractitionerRoleorganization_organization_Union = FHIROrganization;

/** Practitioner that is able to provide the defined services for the organization. */
export type FHIRPractitionerRolepractitioner_practitioner_Union = FHIRPractitioner;

/** 
 * An action that is or was performed on or for a patient. This can be a physical
 * intervention like an operation, or less invasive like long term services,
 * counseling, or hypnotherapy.
 */
export type FHIRProcedure = {
   __typename?: 'FHIRProcedure',
  /** Type of resource */
  resourceType: FHIRProcedure_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this procedure by the performer or other
   * systems which remain constant as the resource is updated and is propagated
   * from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, order set or other
   * definition that is adhered to in whole or in part by this Procedure.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, order set or
   * other definition that is adhered to in whole or in part by this Procedure.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A reference to a resource that contains details of the request for this procedure. */
  basedOn?: Maybe<Array<Maybe<FHIRProcedurebasedOn_basedOn_Union>>>,
  /** A larger event of which this particular procedure is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRProcedurepartOf_partOf_Union>>>,
  /** A code specifying the state of the procedure. Generally, this will be the in-progress or completed state. */
  status: Scalars['FHIRCode'],
  /** Captures the reason for the current state of the procedure. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** A code that classifies the procedure for searching, sorting and display purposes (e.g. 'Surgical Procedure'). */
  category?: Maybe<FHIRCodeableConcept>,
  /** 
 * The specific procedure that is performed. Use text if the exact nature of the
   * procedure cannot be coded (e.g. 'Laparoscopic Appendectomy').
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** The person, animal or group on which the procedure was performed. */
  subject: FHIRProceduresubject_subject_Union,
  /** 
 * The Encounter during which this Procedure was created or performed or to which
   * the creation of this record is tightly associated.
 */
  encounter?: Maybe<FHIRProcedureencounter_encounter_Union>,
  /** 
 * Estimated or actual date, date-time, period, or age when the procedure was
   * performed.  Allows a period to support complex procedures that span more than
   * one date, and also allows for the length of the procedure to be captured.
 */
  performedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Estimated or actual date, date-time, period, or age when the procedure was
   * performed.  Allows a period to support complex procedures that span more than
   * one date, and also allows for the length of the procedure to be captured.
 */
  performedPeriod?: Maybe<FHIRPeriod>,
  /** 
 * Estimated or actual date, date-time, period, or age when the procedure was
   * performed.  Allows a period to support complex procedures that span more than
   * one date, and also allows for the length of the procedure to be captured.
 */
  performedString?: Maybe<Scalars['String']>,
  /** 
 * Estimated or actual date, date-time, period, or age when the procedure was
   * performed.  Allows a period to support complex procedures that span more than
   * one date, and also allows for the length of the procedure to be captured.
 */
  performedAge?: Maybe<FHIRAge>,
  /** 
 * Estimated or actual date, date-time, period, or age when the procedure was
   * performed.  Allows a period to support complex procedures that span more than
   * one date, and also allows for the length of the procedure to be captured.
 */
  performedRange?: Maybe<FHIRRange>,
  /** Individual who recorded the record and takes responsibility for its content. */
  recorder?: Maybe<FHIRProcedurerecorder_recorder_Union>,
  /** Individual who is making the procedure statement. */
  asserter?: Maybe<FHIRProcedureasserter_asserter_Union>,
  /** Limited to 'real' people rather than equipment. */
  performer?: Maybe<Array<Maybe<FHIRProcedureperformer>>>,
  /** The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. */
  location?: Maybe<FHIRProcedurelocation_location_Union>,
  /** 
 * The coded reason why the procedure was performed. This may be a coded entity
   * of some type, or may simply be present as text.
 */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The justification of why the procedure was performed. */
  reasonReference?: Maybe<Array<Maybe<FHIRProcedurereasonReference_reasonReference_Union>>>,
  /** 
 * Detailed and structured anatomical location information. Multiple locations
   * are allowed - e.g. multiple punch biopsies of a lesion.
 */
  bodySite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The outcome of the procedure - did it resolve the reasons for the procedure being performed? */
  outcome?: Maybe<FHIRCodeableConcept>,
  /** This could be a histology result, pathology report, surgical report, etc. */
  report?: Maybe<Array<Maybe<FHIRProcedurereport_report_Union>>>,
  /** 
 * Any complications that occurred during the procedure, or in the immediate
   * post-performance period. These are generally tracked separately from the
   * notes, which will typically describe the procedure itself rather than any
   * 'post procedure' issues.
 */
  complication?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Any complications that occurred during the procedure, or in the immediate post-performance period. */
  complicationDetail?: Maybe<Array<Maybe<FHIRProcedurecomplicationDetail_complicationDetail_Union>>>,
  /** 
 * If the procedure required specific follow up - e.g. removal of sutures. The
   * follow up may be represented as a simple note or could potentially be more
   * complex, in which case the CarePlan resource can be used.
 */
  followUp?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Any other notes and comments about the procedure. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * A device that is implanted, removed or otherwise manipulated (calibration,
   * battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a
   * focal portion of the Procedure.
 */
  focalDevice?: Maybe<Array<Maybe<FHIRProcedurefocalDevice>>>,
  /** Identifies medications, devices and any other substance used as part of the procedure. */
  usedReference?: Maybe<Array<Maybe<FHIRProcedureusedReference_usedReference_Union>>>,
  /** Identifies coded items that were used as part of the procedure. */
  usedCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

export enum FHIRProcedure_Enum_schema {
  Procedure = 'Procedure'
}

/** Individual who is making the procedure statement. */
export type FHIRProcedureasserter_asserter_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole;

/** A reference to a resource that contains details of the request for this procedure. */
export type FHIRProcedurebasedOn_basedOn_Union = FHIRCarePlan | FHIRServiceRequest;

/** Any complications that occurred during the procedure, or in the immediate post-performance period. */
export type FHIRProcedurecomplicationDetail_complicationDetail_Union = FHIRCondition;

/** 
 * The Encounter during which this Procedure was created or performed or to which
 * the creation of this record is tightly associated.
 */
export type FHIRProcedureencounter_encounter_Union = FHIREncounter;

export type FHIRProcedurefocalDevice = {
   __typename?: 'FHIRProcedurefocalDevice',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of change that happened to the device during the procedure. */
  action?: Maybe<FHIRCodeableConcept>,
  /** The device that was manipulated (changed) during the procedure. */
  manipulated: FHIRProcedurefocalDevicemanipulated_manipulated_Union,
};

/** The device that was manipulated (changed) during the procedure. */
export type FHIRProcedurefocalDevicemanipulated_manipulated_Union = FHIRDevice;

/** The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. */
export type FHIRProcedurelocation_location_Union = FHIRLocation;

/** A larger event of which this particular procedure is a component or step. */
export type FHIRProcedurepartOf_partOf_Union = FHIRProcedure | FHIRObservation | FHIRMedicationAdministration;

export type FHIRProcedureperformer = {
   __typename?: 'FHIRProcedureperformer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist. */
  function?: Maybe<FHIRCodeableConcept>,
  /** The practitioner who was involved in the procedure. */
  actor: FHIRProcedureperformeractor_actor_Union,
  /** The organization the device or practitioner was acting on behalf of. */
  onBehalfOf?: Maybe<FHIRProcedureperformeronBehalfOf_onBehalfOf_Union>,
};

/** The practitioner who was involved in the procedure. */
export type FHIRProcedureperformeractor_actor_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** The organization the device or practitioner was acting on behalf of. */
export type FHIRProcedureperformeronBehalfOf_onBehalfOf_Union = FHIROrganization;

/** The justification of why the procedure was performed. */
export type FHIRProcedurereasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRProcedure | FHIRDiagnosticReport | FHIRDocumentReference;

/** Individual who recorded the record and takes responsibility for its content. */
export type FHIRProcedurerecorder_recorder_Union = FHIRPatient | FHIRRelatedPerson | FHIRPractitioner | FHIRPractitionerRole;

/** This could be a histology result, pathology report, surgical report, etc. */
export type FHIRProcedurereport_report_Union = FHIRDiagnosticReport | FHIRDocumentReference | FHIRComposition;

/** The person, animal or group on which the procedure was performed. */
export type FHIRProceduresubject_subject_Union = FHIRPatient | FHIRGroup;

/** Identifies medications, devices and any other substance used as part of the procedure. */
export type FHIRProcedureusedReference_usedReference_Union = FHIRDevice | FHIRMedication | FHIRSubstance;

/** 
 * Base StructureDefinition for ProdCharacteristic Type: The marketing status
 * describes the date when a medicinal product is actually put on the market or the
 * date as of which it is no longer available.
 */
export type FHIRProdCharacteristic = {
   __typename?: 'FHIRProdCharacteristic',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Where applicable, the height can be specified using a numerical value and its
   * unit of measurement The unit of measurement shall be specified in accordance
   * with ISO 11240 and the resulting terminology The symbol and the symbol
   * identifier shall be used.
 */
  height?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the width can be specified using a numerical value and its
   * unit of measurement The unit of measurement shall be specified in accordance
   * with ISO 11240 and the resulting terminology The symbol and the symbol
   * identifier shall be used.
 */
  width?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the depth can be specified using a numerical value and its
   * unit of measurement The unit of measurement shall be specified in accordance
   * with ISO 11240 and the resulting terminology The symbol and the symbol
   * identifier shall be used.
 */
  depth?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the weight can be specified using a numerical value and its
   * unit of measurement The unit of measurement shall be specified in accordance
   * with ISO 11240 and the resulting terminology The symbol and the symbol
   * identifier shall be used.
 */
  weight?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the nominal volume can be specified using a numerical value
   * and its unit of measurement The unit of measurement shall be specified in
   * accordance with ISO 11240 and the resulting terminology The symbol and the
   * symbol identifier shall be used.
 */
  nominalVolume?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the external diameter can be specified using a numerical
   * value and its unit of measurement The unit of measurement shall be specified
   * in accordance with ISO 11240 and the resulting terminology The symbol and the
   * symbol identifier shall be used.
 */
  externalDiameter?: Maybe<FHIRQuantity>,
  /** 
 * Where applicable, the shape can be specified An appropriate controlled
   * vocabulary shall be used The term and the term identifier shall be used.
 */
  shape?: Maybe<Scalars['String']>,
  /** 
 * Where applicable, the color can be specified An appropriate controlled
   * vocabulary shall be used The term and the term identifier shall be used.
 */
  color?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Where applicable, the imprint can be specified as text. */
  imprint?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Where applicable, the image can be provided The format of the image attachment
   * shall be specified by regional implementations.
 */
  image?: Maybe<Array<Maybe<FHIRAttachment>>>,
  /** 
 * Where applicable, the scoring can be specified An appropriate controlled
   * vocabulary shall be used The term and the term identifier shall be used.
 */
  scoring?: Maybe<FHIRCodeableConcept>,
};

/** 
 * Base StructureDefinition for ProductShelfLife Type: The shelf-life and storage
 * information for a medicinal product item or container can be described using this class.
 */
export type FHIRProductShelfLife = {
   __typename?: 'FHIRProductShelfLife',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for the packaged Medicinal Product. */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * This describes the shelf life, taking into account various scenarios such as
   * shelf life of the packaged Medicinal Product itself, shelf life after
   * transformation where necessary and shelf life after the first opening of a
   * bottle, etc. The shelf life type shall be specified using an appropriate
   * controlled vocabulary The controlled term and the controlled term identifier
   * shall be specified.
 */
  type: FHIRCodeableConcept,
  /** 
 * The shelf life time period can be specified using a numerical value for the
   * period of time and its unit of time measurement The unit of measurement shall
   * be specified in accordance with ISO 11240 and the resulting terminology The
   * symbol and the symbol identifier shall be used.
 */
  period: FHIRQuantity,
  /** 
 * Special precautions for storage, if any, can be specified using an appropriate
   * controlled vocabulary The controlled term and the controlled term identifier
   * shall be specified.
 */
  specialPrecautionsForStorage?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

/** 
 * Provenance of a resource is a record that describes entities and processes
 * involved in producing and delivering or otherwise influencing that resource.
 * Provenance provides a critical foundation for assessing authenticity, enabling
 * trust, and allowing reproducibility. Provenance assertions are a form of
 * contextual metadata and can themselves become important records with their own
 * provenance. Provenance statement indicates clinical significance in terms of
 * confidence in authenticity, reliability, and trustworthiness, integrity, and
 * stage in lifecycle (e.g. Document Completion - has the artifact been legally
 * authenticated), all of which may impact security, privacy, and trust policies.
 */
export type FHIRProvenance = {
   __typename?: 'FHIRProvenance',
  /** Type of resource */
  resourceType: FHIRProvenance_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The Reference(s) that were generated or updated by  the activity described in
   * this resource. A provenance can point to more than one target if multiple
   * resources were created/updated by the same activity.
 */
  target?: Maybe<Array<FHIRProvenancetarget_target_Union>>,
  /** The period during which the activity occurred. */
  occurredPeriod?: Maybe<FHIRPeriod>,
  /** The period during which the activity occurred. */
  occurredDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The instant of time at which the activity was recorded. */
  recorded: Scalars['FHIRInstant'],
  /** 
 * Policy or plan the activity was defined by. Typically, a single activity may
   * have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
 */
  policy?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** Where the activity occurred, if relevant. */
  location?: Maybe<FHIRProvenancelocation_location_Union>,
  /** The reason that the activity was taking place. */
  reason?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * An activity is something that occurs over a period of time and acts upon or
   * with entities; it may include consuming, processing, transforming, modifying,
   * relocating, using, or generating entities.
 */
  activity?: Maybe<FHIRCodeableConcept>,
  /** 
 * An actor taking a role in an activity  for which it can be assigned some
   * degree of responsibility for the activity taking place.
 */
  agent?: Maybe<Array<FHIRProvenanceagent>>,
  /** An entity used in this activity. */
  entity?: Maybe<Array<Maybe<FHIRProvenanceentity>>>,
  /** 
 * A digital signature on the target Reference(s). The signer should match a
   * Provenance.agent. The purpose of the signature is indicated.
 */
  signature?: Maybe<Array<Maybe<FHIRSignature>>>,
};

export enum FHIRProvenance_Enum_schema {
  Provenance = 'Provenance'
}

export type FHIRProvenanceagent = {
   __typename?: 'FHIRProvenanceagent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The participation the agent had with respect to the activity. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The function of the agent with respect to the activity. The security role enabling the agent with respect to the activity. */
  role?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The individual, device or organization that participated in the event. */
  who: FHIRProvenanceagentwho_who_Union,
  /** The individual, device, or organization for whom the change was made. */
  onBehalfOf?: Maybe<FHIRProvenanceagentonBehalfOf_onBehalfOf_Union>,
};

/** The individual, device, or organization for whom the change was made. */
export type FHIRProvenanceagentonBehalfOf_onBehalfOf_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRPatient | FHIRDevice | FHIROrganization;

/** The individual, device or organization that participated in the event. */
export type FHIRProvenanceagentwho_who_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRPatient | FHIRDevice | FHIROrganization;

export type FHIRProvenanceentity = {
   __typename?: 'FHIRProvenanceentity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** How the entity was used during the activity. */
  role: Scalars['FHIRCode'],
  /** Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. */
  what: FHIRProvenanceentitywhat_what_Union,
};

/** Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. */
export type FHIRProvenanceentitywhat_what_Union = FHIRResource;

/** Where the activity occurred, if relevant. */
export type FHIRProvenancelocation_location_Union = FHIRLocation;

/** 
 * The Reference(s) that were generated or updated by  the activity described in
 * this resource. A provenance can point to more than one target if multiple
 * resources were created/updated by the same activity.
 */
export type FHIRProvenancetarget_target_Union = FHIRResource;

/** 
 * Base StructureDefinition for Quantity Type: A measured amount (or an amount that
 * can potentially be measured). Note that measured amounts include amounts that
 * are not precisely quantified, including amounts involving arbitrary units and
 * floating currencies.
 */
export type FHIRQuantity = {
   __typename?: 'FHIRQuantity',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * Base StructureDefinition for Quantity Type: A measured amount (or an amount that
 * can potentially be measured). Note that measured amounts include amounts that
 * are not precisely quantified, including amounts involving arbitrary units and
 * floating currencies.
 */
export type FHIRQuantity_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  _value?: Maybe<FHIRElement_Input>,
  /** The value of the measured amount. The value includes an implicit precision in the presentation of the value. */
  value?: Maybe<Scalars['Float']>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  _comparator?: Maybe<FHIRElement_Input>,
  /** 
 * How the value should be understood and represented - whether the actual value
   * is greater or less than the stated value due to measurement issues; e.g. if
   * the comparator is '<' , then the real value is < stated value.
 */
  comparator?: Maybe<Scalars['FHIRCode']>,
  /** A human-readable form of the unit. */
  _unit?: Maybe<FHIRElement_Input>,
  /** A human-readable form of the unit. */
  unit?: Maybe<Scalars['String']>,
  /** The identification of the system that provides the coded form of the unit. */
  _system?: Maybe<FHIRElement_Input>,
  /** The identification of the system that provides the coded form of the unit. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** A computer processable form of the unit in some unit representation system. */
  _code?: Maybe<FHIRElement_Input>,
  /** A computer processable form of the unit in some unit representation system. */
  code?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * A structured set of questions intended to guide the collection of answers from
 * end-users. Questionnaires provide detailed control over order, presentation,
 * phraseology and grouping to allow coherent, consistent data collection.
 */
export type FHIRQuestionnaire = {
   __typename?: 'FHIRQuestionnaire',
  /** Type of resource */
  resourceType: FHIRQuestionnaire_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this questionnaire when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this questionnaire is
   * (or will be) published. This URL can be the target of a canonical reference.
   * It SHALL remain the same when the questionnaire is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this questionnaire when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the questionnaire when
   * it is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the questionnaire author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the questionnaire. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the questionnaire. */
  title?: Maybe<Scalars['String']>,
  /** The URL of a Questionnaire that this Questionnaire is based on. */
  derivedFrom?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The status of this questionnaire. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this questionnaire is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** The types of subjects that can be the subject of responses created for the questionnaire. */
  subjectType?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * The date  (and optionally time) when the questionnaire was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the questionnaire changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the questionnaire. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the questionnaire from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate
   * questionnaire instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the questionnaire is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this questionnaire is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the questionnaire and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the questionnaire.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the questionnaire content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** An identifier for this question or group of questions in a particular terminology such as LOINC. */
  code?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** A particular question, question grouping or display text that is part of the questionnaire. */
  item?: Maybe<Array<Maybe<FHIRQuestionnaireitem>>>,
};

export enum FHIRQuestionnaire_Enum_schema {
  Questionnaire = 'Questionnaire'
}

export type FHIRQuestionnaireitem = {
   __typename?: 'FHIRQuestionnaireitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An identifier that is unique within the Questionnaire allowing linkage to the
   * equivalent item in a QuestionnaireResponse resource.
 */
  linkId: Scalars['String'],
  /** 
 * This element is a URI that refers to an
   * [ElementDefinition](elementdefinition.html) that provides information about
   * this item, including information that might otherwise be included in the
   * instance of the Questionnaire resource. A detailed description of the
   * construction of the URI is shown in Comments, below. If this element is
   * present then the following element values MAY be derived from the Element
   * Definition if the corresponding elements of this Questionnaire resource
   * instance have no value:  * code (ElementDefinition.code)  * type
   * (ElementDefinition.type)  * required (ElementDefinition.min)  * repeats
   * (ElementDefinition.max)  * maxLength (ElementDefinition.maxLength)  *
   * answerValueSet (ElementDefinition.binding) * options
   * (ElementDefinition.binding).
 */
  definition?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A terminology code that corresponds to this group or question (e.g. a code
   * from LOINC, which defines many questions and answers).
 */
  code?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * A short label for a particular group, question or set of display text within
   * the questionnaire used for reference by the individual completing the questionnaire.
 */
  prefix?: Maybe<Scalars['String']>,
  /** The name of a section, the text of a question or text content for a display item. */
  text?: Maybe<Scalars['String']>,
  /** 
 * The type of questionnaire item this is - whether text for display, a grouping
   * of other items or a particular type of data to be captured (string, integer,
   * coded choice, etc.).
 */
  type: Scalars['FHIRCode'],
  /** 
 * A constraint indicating that this item should only be enabled (displayed/allow
   * answers to be captured) when the specified condition is true.
 */
  enableWhen?: Maybe<Array<Maybe<FHIRQuestionnaireitemenableWhen>>>,
  /** Controls how multiple enableWhen values are interpreted -  whether all or any must be true. */
  enableBehavior?: Maybe<Scalars['FHIRCode']>,
  /** 
 * An indication, if true, that the item must be present in a 'completed'
   * QuestionnaireResponse.  If false, the item may be skipped when answering the questionnaire.
 */
  required?: Maybe<Scalars['Boolean']>,
  /** 
 * An indication, if true, that the item may occur multiple times in the
   * response, collecting multiple answers for questions or multiple sets of
   * answers for groups.
 */
  repeats?: Maybe<Scalars['Boolean']>,
  /** An indication, when true, that the value cannot be changed by a human respondent to the Questionnaire. */
  readOnly?: Maybe<Scalars['Boolean']>,
  /** The maximum number of characters that are permitted in the answer to be considered a 'valid' QuestionnaireResponse. */
  maxLength?: Maybe<Scalars['Int']>,
  /** 
 * A reference to a value set containing a list of codes representing permitted
   * answers for a 'choice' or 'open-choice' question.
 */
  answerValueSet?: Maybe<Scalars['FHIRCanonical']>,
  /** One of the permitted answers for a 'choice' or 'open-choice' question. */
  answerOption?: Maybe<Array<Maybe<FHIRQuestionnaireitemanswerOption>>>,
  /** One or more values that should be pre-populated in the answer when initially rendering the questionnaire for user input. */
  initial?: Maybe<Array<Maybe<FHIRQuestionnaireiteminitial>>>,
};

export type FHIRQuestionnaireitemanswerOption = {
   __typename?: 'FHIRQuestionnaireitemanswerOption',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A potential answer that's allowed as the answer to this question. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** A potential answer that's allowed as the answer to this question. */
  valueDate?: Maybe<Scalars['FHIRDate']>,
  /** A potential answer that's allowed as the answer to this question. */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** A potential answer that's allowed as the answer to this question. */
  valueString?: Maybe<Scalars['String']>,
  /** A potential answer that's allowed as the answer to this question. */
  valueCoding?: Maybe<FHIRCoding>,
  /** A potential answer that's allowed as the answer to this question. */
  valueReference?: Maybe<FHIRQuestionnaireitemanswerOptionvalueReference_valueReference_Union>,
  /** Indicates whether the answer value is selected when the list of possible answers is initially shown. */
  initialSelected?: Maybe<Scalars['Boolean']>,
};

/** A potential answer that's allowed as the answer to this question. */
export type FHIRQuestionnaireitemanswerOptionvalueReference_valueReference_Union = FHIRResource;

export type FHIRQuestionnaireitemenableWhen = {
   __typename?: 'FHIRQuestionnaireitemenableWhen',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The linkId for the question whose answer (or lack of answer) governs whether this item is enabled. */
  question: Scalars['String'],
  /** Specifies the criteria by which the question is enabled. */
  operator: Scalars['FHIRCode'],
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerBoolean: Scalars['Boolean'],
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerDecimal?: Maybe<Scalars['Float']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerInteger?: Maybe<Scalars['Int']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerDate?: Maybe<Scalars['FHIRDate']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerTime?: Maybe<Scalars['FHIRTime']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerString?: Maybe<Scalars['String']>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerCoding?: Maybe<FHIRCoding>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerQuantity?: Maybe<FHIRQuantity>,
  /** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
  answerReference?: Maybe<FHIRQuestionnaireitemenableWhenanswerReference_answerReference_Union>,
};

/** A value that the referenced question is tested using the specified operator in order for the item to be enabled. */
export type FHIRQuestionnaireitemenableWhenanswerReference_answerReference_Union = FHIRResource;

export type FHIRQuestionnaireiteminitial = {
   __typename?: 'FHIRQuestionnaireiteminitial',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The actual value to for an initial answer. */
  valueBoolean: Scalars['Boolean'],
  /** The actual value to for an initial answer. */
  valueDecimal: Scalars['Float'],
  /** The actual value to for an initial answer. */
  valueInteger: Scalars['Int'],
  /** The actual value to for an initial answer. */
  valueDate: Scalars['FHIRDate'],
  /** The actual value to for an initial answer. */
  valueDateTime: Scalars['FHIRDateTime'],
  /** The actual value to for an initial answer. */
  valueTime: Scalars['FHIRTime'],
  /** The actual value to for an initial answer. */
  valueString: Scalars['String'],
  /** The actual value to for an initial answer. */
  valueUri: Scalars['FHIRUri'],
  /** The actual value to for an initial answer. */
  valueAttachment: FHIRAttachment,
  /** The actual value to for an initial answer. */
  valueCoding: FHIRCoding,
  /** The actual value to for an initial answer. */
  valueQuantity: FHIRQuantity,
  /** The actual value to for an initial answer. */
  valueReference: FHIRQuestionnaireiteminitialvalueReference_valueReference_Union,
};

/** The actual value to for an initial answer. */
export type FHIRQuestionnaireiteminitialvalueReference_valueReference_Union = FHIRResource;

/** 
 * A structured set of questions and their answers. The questions are ordered and
 * grouped into coherent subsets, corresponding to the structure of the grouping of
 * the questionnaire being responded to.
 */
export type FHIRQuestionnaireResponse = {
   __typename?: 'FHIRQuestionnaireResponse',
  /** Type of resource */
  resourceType: FHIRQuestionnaireResponse_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A business identifier assigned to a particular completed (or partially completed) questionnaire. */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * The order, proposal or plan that is fulfilled in whole or in part by this
   * QuestionnaireResponse.  For example, a ServiceRequest seeking an intake
   * assessment or a decision support recommendation to assess for post-partum depression.
 */
  basedOn?: Maybe<Array<Maybe<FHIRQuestionnaireResponsebasedOn_basedOn_Union>>>,
  /** 
 * A procedure or observation that this questionnaire was performed as part of
   * the execution of.  For example, the surgery a checklist was executed as part of.
 */
  partOf?: Maybe<Array<Maybe<FHIRQuestionnaireResponsepartOf_partOf_Union>>>,
  /** The Questionnaire that defines and organizes the questions for which answers are being provided. */
  questionnaire?: Maybe<Scalars['FHIRCanonical']>,
  /** The position of the questionnaire response within its overall lifecycle. */
  status: Scalars['FHIRCode'],
  /** 
 * The subject of the questionnaire response.  This could be a patient,
   * organization, practitioner, device, etc.  This is who/what the answers apply
   * to, but is not necessarily the source of information.
 */
  subject?: Maybe<FHIRQuestionnaireResponsesubject_subject_Union>,
  /** 
 * The Encounter during which this questionnaire response was created or to which
   * the creation of this record is tightly associated.
 */
  encounter?: Maybe<FHIRQuestionnaireResponseencounter_encounter_Union>,
  /** The date and/or time that this set of answers were last changed. */
  authored?: Maybe<Scalars['FHIRDateTime']>,
  /** Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system. */
  author?: Maybe<FHIRQuestionnaireResponseauthor_author_Union>,
  /** The person who answered the questions about the subject. */
  source?: Maybe<FHIRQuestionnaireResponsesource_source_Union>,
  /** A group or question item from the original questionnaire for which answers are provided. */
  item?: Maybe<Array<Maybe<FHIRQuestionnaireResponseitem>>>,
};

export enum FHIRQuestionnaireResponse_Enum_schema {
  QuestionnaireResponse = 'QuestionnaireResponse'
}

/** Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system. */
export type FHIRQuestionnaireResponseauthor_author_Union = FHIRDevice | FHIRPractitioner | FHIRPractitionerRole | FHIRPatient | FHIRRelatedPerson | FHIROrganization;

/** 
 * The order, proposal or plan that is fulfilled in whole or in part by this
 * QuestionnaireResponse.  For example, a ServiceRequest seeking an intake
 * assessment or a decision support recommendation to assess for post-partum depression.
 */
export type FHIRQuestionnaireResponsebasedOn_basedOn_Union = FHIRCarePlan | FHIRServiceRequest;

/** 
 * The Encounter during which this questionnaire response was created or to which
 * the creation of this record is tightly associated.
 */
export type FHIRQuestionnaireResponseencounter_encounter_Union = FHIREncounter;

export type FHIRQuestionnaireResponseitem = {
   __typename?: 'FHIRQuestionnaireResponseitem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource. */
  linkId: Scalars['String'],
  /** A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item. */
  definition?: Maybe<Scalars['FHIRUri']>,
  /** Text that is displayed above the contents of the group or as the text of the question being answered. */
  text?: Maybe<Scalars['String']>,
  /** The respondent's answer(s) to the question. */
  answer?: Maybe<Array<Maybe<FHIRQuestionnaireResponseitemanswer>>>,
};

export type FHIRQuestionnaireResponseitemanswer = {
   __typename?: 'FHIRQuestionnaireResponseitemanswer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueDecimal?: Maybe<Scalars['Float']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueDate?: Maybe<Scalars['FHIRDate']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueTime?: Maybe<Scalars['FHIRTime']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueString?: Maybe<Scalars['String']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueUri?: Maybe<Scalars['FHIRUri']>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueAttachment?: Maybe<FHIRAttachment>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueCoding?: Maybe<FHIRCoding>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** The answer (or one of the answers) provided by the respondent to the question. */
  valueReference?: Maybe<FHIRQuestionnaireResponseitemanswervalueReference_valueReference_Union>,
};

/** The answer (or one of the answers) provided by the respondent to the question. */
export type FHIRQuestionnaireResponseitemanswervalueReference_valueReference_Union = FHIRResource;

/** 
 * A procedure or observation that this questionnaire was performed as part of the
 * execution of.  For example, the surgery a checklist was executed as part of.
 */
export type FHIRQuestionnaireResponsepartOf_partOf_Union = FHIRObservation | FHIRProcedure;

/** The person who answered the questions about the subject. */
export type FHIRQuestionnaireResponsesource_source_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

/** 
 * The subject of the questionnaire response.  This could be a patient,
 * organization, practitioner, device, etc.  This is who/what the answers apply to,
 * but is not necessarily the source of information.
 */
export type FHIRQuestionnaireResponsesubject_subject_Union = FHIRResource;

/** Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit. */
export type FHIRRange = {
   __typename?: 'FHIRRange',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The low limit. The boundary is inclusive. */
  low?: Maybe<FHIRQuantity>,
  /** The high limit. The boundary is inclusive. */
  high?: Maybe<FHIRQuantity>,
};

/** Base StructureDefinition for Range Type: A set of ordered Quantities defined by a low and high limit. */
export type FHIRRange_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The low limit. The boundary is inclusive. */
  low?: Maybe<FHIRQuantity_Input>,
  /** The high limit. The boundary is inclusive. */
  high?: Maybe<FHIRQuantity_Input>,
};

/** Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator. */
export type FHIRRatio = {
   __typename?: 'FHIRRatio',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The value of the numerator. */
  numerator?: Maybe<FHIRQuantity>,
  /** The value of the denominator. */
  denominator?: Maybe<FHIRQuantity>,
};

/** Base StructureDefinition for Ratio Type: A relationship of two Quantity values - expressed as a numerator and a denominator. */
export type FHIRRatio_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The value of the numerator. */
  numerator?: Maybe<FHIRQuantity_Input>,
  /** The value of the denominator. */
  denominator?: Maybe<FHIRQuantity_Input>,
};

/** 
 * Base StructureDefinition for RelatedArtifact Type: Related artifacts such as
 * additional documentation, justification, or bibliographic references.
 */
export type FHIRRelatedArtifact = {
   __typename?: 'FHIRRelatedArtifact',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of relationship to the related artifact. */
  type: Scalars['FHIRCode'],
  /** 
 * A short label that can be used to reference the citation from elsewhere in the
   * containing artifact, such as a footnote index.
 */
  label?: Maybe<Scalars['String']>,
  /** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer. */
  display?: Maybe<Scalars['String']>,
  /** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format. */
  citation?: Maybe<Scalars['String']>,
  /** A url for the artifact that can be followed to access the actual content. */
  url?: Maybe<Scalars['FHIRUrl']>,
  /** The document being referenced, represented as an attachment. This is exclusive with the resource element. */
  document?: Maybe<FHIRAttachment>,
  /** The related resource, such as a library, value set, profile, or other knowledge resource. */
  resource?: Maybe<Scalars['FHIRCanonical']>,
};

/** 
 * Base StructureDefinition for RelatedArtifact Type: Related artifacts such as
 * additional documentation, justification, or bibliographic references.
 */
export type FHIRRelatedArtifact_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The type of relationship to the related artifact. */
  _type?: Maybe<FHIRElement_Input>,
  /** The type of relationship to the related artifact. */
  type: Scalars['FHIRCode'],
  /** 
 * A short label that can be used to reference the citation from elsewhere in the
   * containing artifact, such as a footnote index.
 */
  _label?: Maybe<FHIRElement_Input>,
  /** 
 * A short label that can be used to reference the citation from elsewhere in the
   * containing artifact, such as a footnote index.
 */
  label?: Maybe<Scalars['String']>,
  /** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer. */
  _display?: Maybe<FHIRElement_Input>,
  /** A brief description of the document or knowledge resource being referenced, suitable for display to a consumer. */
  display?: Maybe<Scalars['String']>,
  /** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format. */
  _citation?: Maybe<FHIRElement_Input>,
  /** A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format. */
  citation?: Maybe<Scalars['String']>,
  /** A url for the artifact that can be followed to access the actual content. */
  _url?: Maybe<FHIRElement_Input>,
  /** A url for the artifact that can be followed to access the actual content. */
  url?: Maybe<Scalars['FHIRUrl']>,
  /** The document being referenced, represented as an attachment. This is exclusive with the resource element. */
  document?: Maybe<FHIRAttachment_Input>,
  /** The related resource, such as a library, value set, profile, or other knowledge resource. */
  _resource?: Maybe<FHIRElement_Input>,
  /** The related resource, such as a library, value set, profile, or other knowledge resource. */
  resource?: Maybe<Scalars['FHIRCanonical']>,
};

/** 
 * Information about a person that is involved in the care for a patient, but who
 * is not the target of healthcare, nor has a formal responsibility in the care process.
 */
export type FHIRRelatedPerson = {
   __typename?: 'FHIRRelatedPerson',
  /** Type of resource */
  resourceType: FHIRRelatedPerson_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for a person within a particular scope. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this related person record is in active use. */
  active?: Maybe<Scalars['Boolean']>,
  /** The patient this person is related to. */
  patient: FHIRRelatedPersonpatient_patient_Union,
  /** The nature of the relationship between a patient and the related person. */
  relationship?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A name associated with the person. */
  name?: Maybe<Array<Maybe<FHIRHumanName>>>,
  /** A contact detail for the person, e.g. a telephone number or an email address. */
  telecom?: Maybe<Array<Maybe<FHIRContactPoint>>>,
  /** Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes. */
  gender?: Maybe<Scalars['FHIRCode']>,
  /** The date on which the related person was born. */
  birthDate?: Maybe<Scalars['FHIRDate']>,
  /** Address where the related person can be contacted or visited. */
  address?: Maybe<Array<Maybe<FHIRAddress>>>,
  /** Image of the person. */
  photo?: Maybe<Array<Maybe<FHIRAttachment>>>,
  /** 
 * The period of time during which this relationship is or was active. If there
   * are no dates defined, then the interval is unknown.
 */
  period?: Maybe<FHIRPeriod>,
  /** A language which may be used to communicate with about the patient's health. */
  communication?: Maybe<Array<Maybe<FHIRRelatedPersoncommunication>>>,
};

export enum FHIRRelatedPerson_Enum_schema {
  RelatedPerson = 'RelatedPerson'
}

export type FHIRRelatedPersoncommunication = {
   __typename?: 'FHIRRelatedPersoncommunication',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The ISO-639-1 alpha 2 code in lower case for the language, optionally followed
   * by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g.
   * 'en' for English, or 'en-US' for American English versus 'en-EN' for England English.
 */
  language: FHIRCodeableConcept,
  /** Indicates whether or not the patient prefers this language (over other languages he masters up a certain level). */
  preferred?: Maybe<Scalars['Boolean']>,
};

/** The patient this person is related to. */
export type FHIRRelatedPersonpatient_patient_Union = FHIRPatient;

/** 
 * A group of related requests that can be used to capture intended activities that
 * have inter-dependencies such as 'give this medication after that one'.
 */
export type FHIRRequestGroup = {
   __typename?: 'FHIRRequestGroup',
  /** Type of resource */
  resourceType: FHIRRequestGroup_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Allows a service to provide a unique, business identifier for the request. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * A canonical URL referencing a FHIR-defined protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this request.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * A URL referencing an externally defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this request.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** A plan, proposal or order that is fulfilled in whole or in part by this request. */
  basedOn?: Maybe<Array<Maybe<FHIRRequestGroupbasedOn_basedOn_Union>>>,
  /** Completed or terminated request(s) whose function is taken by this new request. */
  replaces?: Maybe<Array<Maybe<FHIRRequestGroupreplaces_replaces_Union>>>,
  /** 
 * A shared identifier common to all requests that were authorized more or less
   * simultaneously by a single author, representing the identifier of the
   * requisition, prescription or similar form.
 */
  groupIdentifier?: Maybe<FHIRIdentifier>,
  /** The current state of the request. For request groups, the status reflects the status of all the requests in the group. */
  status: Scalars['FHIRCode'],
  /** 
 * Indicates the level of authority/intentionality associated with the request
   * and where the request fits into the workflow chain.
 */
  intent: Scalars['FHIRCode'],
  /** Indicates how quickly the request should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** A code that identifies what the overall request group is. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The subject for which the request group was created. */
  subject?: Maybe<FHIRRequestGroupsubject_subject_Union>,
  /** Describes the context of the request group, if any. */
  encounter?: Maybe<FHIRRequestGroupencounter_encounter_Union>,
  /** Indicates when the request group was created. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** Provides a reference to the author of the request group. */
  author?: Maybe<FHIRRequestGroupauthor_author_Union>,
  /** Describes the reason for the request group in coded or textual form. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates another resource whose existence justifies this request group. */
  reasonReference?: Maybe<Array<Maybe<FHIRRequestGroupreasonReference_reasonReference_Union>>>,
  /** Provides a mechanism to communicate additional information about the response. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** The actions, if any, produced by the evaluation of the artifact. */
  action?: Maybe<Array<Maybe<FHIRRequestGroupaction>>>,
};

export enum FHIRRequestGroup_Enum_schema {
  RequestGroup = 'RequestGroup'
}

export type FHIRRequestGroupaction = {
   __typename?: 'FHIRRequestGroupaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A user-visible prefix for the action. */
  prefix?: Maybe<Scalars['String']>,
  /** The title of the action displayed to a user. */
  title?: Maybe<Scalars['String']>,
  /** A short description of the action used to provide a summary to display to the user. */
  description?: Maybe<Scalars['String']>,
  /** 
 * A text equivalent of the action to be performed. This provides a
   * human-interpretable description of the action when the definition is consumed
   * by a system that might not be capable of interpreting it dynamically.
 */
  textEquivalent?: Maybe<Scalars['String']>,
  /** Indicates how quickly the action should be addressed with respect to other actions. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A code that provides meaning for the action or action group. For example, a
   * section may have a LOINC code for a section of a documentation template.
 */
  code?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Didactic or other informational resources associated with the action that can
   * be provided to the CDS recipient. Information resources can include inline
   * text commentary and links to web resources.
 */
  documentation?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** An expression that describes applicability criteria, or start/stop conditions for the action. */
  condition?: Maybe<Array<Maybe<FHIRRequestGroupactioncondition>>>,
  /** A relationship to another action such as 'before' or '30-60 minutes after start of'. */
  relatedAction?: Maybe<Array<Maybe<FHIRRequestGroupactionrelatedAction>>>,
  /** An optional value describing when the action should be performed. */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** An optional value describing when the action should be performed. */
  timingAge?: Maybe<FHIRAge>,
  /** An optional value describing when the action should be performed. */
  timingPeriod?: Maybe<FHIRPeriod>,
  /** An optional value describing when the action should be performed. */
  timingDuration?: Maybe<FHIRDuration>,
  /** An optional value describing when the action should be performed. */
  timingRange?: Maybe<FHIRRange>,
  /** An optional value describing when the action should be performed. */
  timingTiming?: Maybe<FHIRTiming>,
  /** The participant that should perform or be responsible for this action. */
  participant?: Maybe<Array<Maybe<FHIRRequestGroupactionparticipant_participant_Union>>>,
  /** The type of action to perform (create, update, remove). */
  type?: Maybe<FHIRCodeableConcept>,
  /** Defines the grouping behavior for the action and its children. */
  groupingBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines the selection behavior for the action and its children. */
  selectionBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines expectations around whether an action is required. */
  requiredBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines whether the action should usually be preselected. */
  precheckBehavior?: Maybe<Scalars['FHIRCode']>,
  /** Defines whether the action can be selected multiple times. */
  cardinalityBehavior?: Maybe<Scalars['FHIRCode']>,
  /** The resource that is the target of the action (e.g. CommunicationRequest). */
  resource?: Maybe<FHIRRequestGroupactionresource_resource_Union>,
};

export type FHIRRequestGroupactioncondition = {
   __typename?: 'FHIRRequestGroupactioncondition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kind of condition. */
  kind: Scalars['FHIRCode'],
  /** An expression that returns true or false, indicating whether or not the condition is satisfied. */
  expression?: Maybe<FHIRExpression>,
};

/** The participant that should perform or be responsible for this action. */
export type FHIRRequestGroupactionparticipant_participant_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRDevice;

export type FHIRRequestGroupactionrelatedAction = {
   __typename?: 'FHIRRequestGroupactionrelatedAction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The element id of the action this is related to. */
  actionId: Scalars['FHIRId'],
  /** The relationship of this action to the related action. */
  relationship: Scalars['FHIRCode'],
  /** A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. */
  offsetDuration?: Maybe<FHIRDuration>,
  /** A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. */
  offsetRange?: Maybe<FHIRRange>,
};

/** The resource that is the target of the action (e.g. CommunicationRequest). */
export type FHIRRequestGroupactionresource_resource_Union = FHIRResource;

/** Provides a reference to the author of the request group. */
export type FHIRRequestGroupauthor_author_Union = FHIRDevice | FHIRPractitioner | FHIRPractitionerRole;

/** A plan, proposal or order that is fulfilled in whole or in part by this request. */
export type FHIRRequestGroupbasedOn_basedOn_Union = FHIRResource;

/** Describes the context of the request group, if any. */
export type FHIRRequestGroupencounter_encounter_Union = FHIREncounter;

/** Indicates another resource whose existence justifies this request group. */
export type FHIRRequestGroupreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** Completed or terminated request(s) whose function is taken by this new request. */
export type FHIRRequestGroupreplaces_replaces_Union = FHIRResource;

/** The subject for which the request group was created. */
export type FHIRRequestGroupsubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * The ResearchDefinition resource describes the conditional state (population and
 * any exposures being compared within the population) and outcome (if specified)
 * that the knowledge (evidence, assertion, recommendation) is about.
 */
export type FHIRResearchDefinition = {
   __typename?: 'FHIRResearchDefinition',
  /** Type of resource */
  resourceType: FHIRResearchDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this research definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this research
   * definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the research definition is
   * stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this research definition when it
   * is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the research
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the research definition author
   * and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence. To
   * provide a version consistent with the Decision Support Service specification,
   * use the format Major.Minor.Revision (e.g. 1.0.0). For more information on
   * versioning knowledge assets, refer to the Decision Support Service
   * specification. Note that a version is required for non-experimental active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the research definition. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the research definition. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The short title provides an alternate title for use in informal descriptive
   * contexts where the full, formal title is not necessary.
 */
  shortTitle?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the ResearchDefinition giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this research definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this research definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The intended subjects for the ResearchDefinition. If this element is not
   * provided, a Patient subject is assumed, but the subject of the
   * ResearchDefinition can be anything.
 */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * The intended subjects for the ResearchDefinition. If this element is not
   * provided, a Patient subject is assumed, but the subject of the
   * ResearchDefinition can be anything.
 */
  subjectReference?: Maybe<FHIRResearchDefinitionsubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the research definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the research definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the research definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the research definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  comment?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate research
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the research definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this research definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description, from a clinical perspective, of how the ResearchDefinition is used. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the research definition and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the research definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the research definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the ResearchDefinition. Topics
   * provide a high-level categorization grouping types of ResearchDefinitions that
   * can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a Library resource containing the formal logic used by the ResearchDefinition. */
  library?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** A reference to a ResearchElementDefinition resource that defines the population for the research. */
  population: FHIRResearchDefinitionpopulation_population_Union,
  /** A reference to a ResearchElementDefinition resource that defines the exposure for the research. */
  exposure?: Maybe<FHIRResearchDefinitionexposure_exposure_Union>,
  /** A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research. */
  exposureAlternative?: Maybe<FHIRResearchDefinitionexposureAlternative_exposureAlternative_Union>,
  /** A reference to a ResearchElementDefinition resomece that defines the outcome for the research. */
  outcome?: Maybe<FHIRResearchDefinitionoutcome_outcome_Union>,
};

export enum FHIRResearchDefinition_Enum_schema {
  ResearchDefinition = 'ResearchDefinition'
}

/** A reference to a ResearchElementDefinition resource that defines the exposure for the research. */
export type FHIRResearchDefinitionexposure_exposure_Union = FHIRResearchElementDefinition;

/** A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research. */
export type FHIRResearchDefinitionexposureAlternative_exposureAlternative_Union = FHIRResearchElementDefinition;

/** A reference to a ResearchElementDefinition resomece that defines the outcome for the research. */
export type FHIRResearchDefinitionoutcome_outcome_Union = FHIRResearchElementDefinition;

/** A reference to a ResearchElementDefinition resource that defines the population for the research. */
export type FHIRResearchDefinitionpopulation_population_Union = FHIRResearchElementDefinition;

/** 
 * The intended subjects for the ResearchDefinition. If this element is not
 * provided, a Patient subject is assumed, but the subject of the
 * ResearchDefinition can be anything.
 */
export type FHIRResearchDefinitionsubjectReference_subjectReference_Union = FHIRGroup;

/** 
 * The ResearchElementDefinition resource describes a 'PICO' element that knowledge
 * (evidence, assertion, recommendation) is about.
 */
export type FHIRResearchElementDefinition = {
   __typename?: 'FHIRResearchElementDefinition',
  /** Type of resource */
  resourceType: FHIRResearchElementDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this research element definition when
   * it is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this research
   * element definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the research element
   * definition is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this research element definition
   * when it is represented in other formats, or referenced in a specification,
   * model, design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the research element
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the research element
   * definition author and is not expected to be globally unique. For example, it
   * might be a timestamp (e.g. yyyymmdd) if a managed version is not available.
   * There is also no expectation that versions can be placed in a lexicographical
   * sequence. To provide a version consistent with the Decision Support Service
   * specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more
   * information on versioning knowledge assets, refer to the Decision Support
   * Service specification. Note that a version is required for non-experimental
   * active artifacts.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the research element definition. This name
   * should be usable as an identifier for the module by machine processing
   * applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the research element definition. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The short title provides an alternate title for use in informal descriptive
   * contexts where the full, formal title is not necessary.
 */
  shortTitle?: Maybe<Scalars['String']>,
  /** An explanatory or alternate title for the ResearchElementDefinition giving additional information about its content. */
  subtitle?: Maybe<Scalars['String']>,
  /** The status of this research element definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this research element definition is authored
   * for testing purposes (or education/evaluation/marketing) and is not intended
   * to be used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The intended subjects for the ResearchElementDefinition. If this element is
   * not provided, a Patient subject is assumed, but the subject of the
   * ResearchElementDefinition can be anything.
 */
  subjectCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * The intended subjects for the ResearchElementDefinition. If this element is
   * not provided, a Patient subject is assumed, but the subject of the
   * ResearchElementDefinition can be anything.
 */
  subjectReference?: Maybe<FHIRResearchElementDefinitionsubjectReference_subjectReference_Union>,
  /** 
 * The date  (and optionally time) when the research element definition was
   * published. The date must change when the business version changes and it must
   * change if the status code changes. In addition, it should change when the
   * substantive content of the research element definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the research element definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the research element definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  comment?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate research
   * element definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the research element definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this research element definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** A detailed description, from a clinical perspective, of how the ResearchElementDefinition is used. */
  usage?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the research element definition and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the research element definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the research element definition content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the ResearchElementDefinition.
   * Topics provide a high-level categorization grouping types of
   * ResearchElementDefinitions that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** A reference to a Library resource containing the formal logic used by the ResearchElementDefinition. */
  library?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** The type of research element, a population, an exposure, or an outcome. */
  type: Scalars['FHIRCode'],
  /** The type of the outcome (e.g. Dichotomous, Continuous, or Descriptive). */
  variableType?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A characteristic that defines the members of the research element. Multiple
   * characteristics are applied with 'and' semantics.
 */
  characteristic?: Maybe<Array<FHIRResearchElementDefinitioncharacteristic>>,
};

export enum FHIRResearchElementDefinition_Enum_schema {
  ResearchElementDefinition = 'ResearchElementDefinition'
}

export type FHIRResearchElementDefinitioncharacteristic = {
   __typename?: 'FHIRResearchElementDefinitioncharacteristic',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Define members of the research element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionCodeableConcept: FHIRCodeableConcept,
  /** 
 * Define members of the research element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionCanonical: Scalars['FHIRCanonical'],
  /** 
 * Define members of the research element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionExpression: FHIRExpression,
  /** 
 * Define members of the research element using Codes (such as condition,
   * medication, or observation), Expressions ( using an expression language such
   * as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in
   * the last year).
 */
  definitionDataRequirement: FHIRDataRequirement,
  /** Use UsageContext to define the members of the population, such as Age Ranges, Genders, Settings. */
  usageContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** When true, members with this characteristic are excluded from the element. */
  exclude?: Maybe<Scalars['Boolean']>,
  /** Specifies the UCUM unit for the outcome. */
  unitOfMeasure?: Maybe<FHIRCodeableConcept>,
  /** A narrative description of the time period the study covers. */
  studyEffectiveDescription?: Maybe<Scalars['String']>,
  /** Indicates what effective period the study covers. */
  studyEffectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates what effective period the study covers. */
  studyEffectivePeriod?: Maybe<FHIRPeriod>,
  /** Indicates what effective period the study covers. */
  studyEffectiveDuration?: Maybe<FHIRDuration>,
  /** Indicates what effective period the study covers. */
  studyEffectiveTiming?: Maybe<FHIRTiming>,
  /** Indicates duration from the study initiation. */
  studyEffectiveTimeFromStart?: Maybe<FHIRDuration>,
  /** Indicates how elements are aggregated within the study effective period. */
  studyEffectiveGroupMeasure?: Maybe<Scalars['FHIRCode']>,
  /** A narrative description of the time period the study covers. */
  participantEffectiveDescription?: Maybe<Scalars['String']>,
  /** Indicates what effective period the study covers. */
  participantEffectiveDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Indicates what effective period the study covers. */
  participantEffectivePeriod?: Maybe<FHIRPeriod>,
  /** Indicates what effective period the study covers. */
  participantEffectiveDuration?: Maybe<FHIRDuration>,
  /** Indicates what effective period the study covers. */
  participantEffectiveTiming?: Maybe<FHIRTiming>,
  /** Indicates duration from the participant's study entry. */
  participantEffectiveTimeFromStart?: Maybe<FHIRDuration>,
  /** Indicates how elements are aggregated within the study effective period. */
  participantEffectiveGroupMeasure?: Maybe<Scalars['FHIRCode']>,
};

/** 
 * The intended subjects for the ResearchElementDefinition. If this element is not
 * provided, a Patient subject is assumed, but the subject of the
 * ResearchElementDefinition can be anything.
 */
export type FHIRResearchElementDefinitionsubjectReference_subjectReference_Union = FHIRGroup;

/** 
 * A process where a researcher or organization plans and then executes a series of
 * steps intended to increase the field of healthcare-related knowledge.  This
 * includes studies of safety, efficacy, comparative effectiveness and other
 * information about medications, devices, therapies and other interventional and
 * investigative techniques.  A ResearchStudy involves the gathering of information
 * about human or animal subjects.
 */
export type FHIRResearchStudy = {
   __typename?: 'FHIRResearchStudy',
  /** Type of resource */
  resourceType: FHIRResearchStudy_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this research study by the sponsor or other systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A short, descriptive user-friendly label for the study. */
  title?: Maybe<Scalars['String']>,
  /** The set of steps expected to be performed as part of the execution of the study. */
  protocol?: Maybe<Array<Maybe<FHIRResearchStudyprotocol_protocol_Union>>>,
  /** A larger research study of which this particular study is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRResearchStudypartOf_partOf_Union>>>,
  /** The current state of the study. */
  status: Scalars['FHIRCode'],
  /** The type of study based upon the intent of the study's activities. A classification of the intent of the study. */
  primaryPurposeType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The stage in the progression of a therapy from initial experimental use in
   * humans in clinical trials to post-market evaluation.
 */
  phase?: Maybe<FHIRCodeableConcept>,
  /** 
 * Codes categorizing the type of study such as investigational vs.
   * observational, type of blinding, type of randomization, safety vs. efficacy, etc.
 */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The medication(s), food(s), therapy(ies), device(s) or other concerns or
   * interventions that the study is seeking to gain more information about.
 */
  focus?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The condition that is the focus of the study.  For example, In a study to
   * examine risk factors for Lupus, might have as an inclusion criterion 'healthy
   * volunteer', but the target condition code would be a Lupus SNOMED code.
 */
  condition?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Contact details to assist a user in learning more about or engaging with the study. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Citations, references and other related documents. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** Key terms to aid in searching for or filtering the study. */
  keyword?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates a country, state or other region where the study is taking place. */
  location?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A full description of how the study is being conducted. */
  description?: Maybe<Scalars['String']>,
  /** 
 * Reference to a Group that defines the criteria for and quantity of subjects
   * participating in the study.  E.g. ' 200 female Europeans between the ages of
   * 20 and 45 with early onset diabetes'.
 */
  enrollment?: Maybe<Array<Maybe<FHIRResearchStudyenrollment_enrollment_Union>>>,
  /** Identifies the start date and the expected (or actual, depending on status) end date for the study. */
  period?: Maybe<FHIRPeriod>,
  /** An organization that initiates the investigation and is legally responsible for the study. */
  sponsor?: Maybe<FHIRResearchStudysponsor_sponsor_Union>,
  /** 
 * A researcher in a study who oversees multiple aspects of the study, such as
   * concept development, protocol writing, protocol submission for IRB approval,
   * participant recruitment, informed consent, data collection, analysis,
   * interpretation and presentation.
 */
  principalInvestigator?: Maybe<FHIRResearchStudyprincipalInvestigator_principalInvestigator_Union>,
  /** A facility in which study activities are conducted. */
  site?: Maybe<Array<Maybe<FHIRResearchStudysite_site_Union>>>,
  /** A description and/or code explaining the premature termination of the study. */
  reasonStopped?: Maybe<FHIRCodeableConcept>,
  /** Comments made about the study by the performer, subject or other participants. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * Describes an expected sequence of events for one of the participants of a
   * study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
 */
  arm?: Maybe<Array<Maybe<FHIRResearchStudyarm>>>,
  /** 
 * A goal that the study is aiming to achieve in terms of a scientific question
   * to be answered by the analysis of data collected during the study.
 */
  objective?: Maybe<Array<Maybe<FHIRResearchStudyobjective>>>,
};

export enum FHIRResearchStudy_Enum_schema {
  ResearchStudy = 'ResearchStudy'
}

export type FHIRResearchStudyarm = {
   __typename?: 'FHIRResearchStudyarm',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique, human-readable label for this arm of the study. */
  name: Scalars['String'],
  /** Categorization of study arm, e.g. experimental, active comparator, placebo comparater. */
  type?: Maybe<FHIRCodeableConcept>,
  /** A succinct description of the path through the study that would be followed by a subject adhering to this arm. */
  description?: Maybe<Scalars['String']>,
};

/** 
 * Reference to a Group that defines the criteria for and quantity of subjects
 * participating in the study.  E.g. ' 200 female Europeans between the ages of 20
 * and 45 with early onset diabetes'.
 */
export type FHIRResearchStudyenrollment_enrollment_Union = FHIRGroup;

export type FHIRResearchStudyobjective = {
   __typename?: 'FHIRResearchStudyobjective',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique, human-readable label for this objective of the study. */
  name?: Maybe<Scalars['String']>,
  /** The kind of study objective. */
  type?: Maybe<FHIRCodeableConcept>,
};

/** A larger research study of which this particular study is a component or step. */
export type FHIRResearchStudypartOf_partOf_Union = FHIRResearchStudy;

/** 
 * A researcher in a study who oversees multiple aspects of the study, such as
 * concept development, protocol writing, protocol submission for IRB approval,
 * participant recruitment, informed consent, data collection, analysis,
 * interpretation and presentation.
 */
export type FHIRResearchStudyprincipalInvestigator_principalInvestigator_Union = FHIRPractitioner | FHIRPractitionerRole;

/** The set of steps expected to be performed as part of the execution of the study. */
export type FHIRResearchStudyprotocol_protocol_Union = FHIRPlanDefinition;

/** A facility in which study activities are conducted. */
export type FHIRResearchStudysite_site_Union = FHIRLocation;

/** An organization that initiates the investigation and is legally responsible for the study. */
export type FHIRResearchStudysponsor_sponsor_Union = FHIROrganization;

/** A physical entity which is the primary unit of operational and/or administrative interest in a study. */
export type FHIRResearchSubject = {
   __typename?: 'FHIRResearchSubject',
  /** Type of resource */
  resourceType: FHIRResearchSubject_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this research subject for a study. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The current state of the subject. */
  status: Scalars['FHIRCode'],
  /** The dates the subject began and ended their participation in the study. */
  period?: Maybe<FHIRPeriod>,
  /** Reference to the study the subject is participating in. */
  study: FHIRResearchSubjectstudy_study_Union,
  /** The record of the person or animal who is involved in the study. */
  individual: FHIRResearchSubjectindividual_individual_Union,
  /** The name of the arm in the study the subject is expected to follow as part of this study. */
  assignedArm?: Maybe<Scalars['String']>,
  /** The name of the arm in the study the subject actually followed as part of this study. */
  actualArm?: Maybe<Scalars['String']>,
  /** A record of the patient's informed agreement to participate in the study. */
  consent?: Maybe<FHIRResearchSubjectconsent_consent_Union>,
};

export enum FHIRResearchSubject_Enum_schema {
  ResearchSubject = 'ResearchSubject'
}

/** A record of the patient's informed agreement to participate in the study. */
export type FHIRResearchSubjectconsent_consent_Union = FHIRConsent;

/** The record of the person or animal who is involved in the study. */
export type FHIRResearchSubjectindividual_individual_Union = FHIRPatient;

/** Reference to the study the subject is participating in. */
export type FHIRResearchSubjectstudy_study_Union = FHIRResearchStudy;

/** This is the base resource type for everything. */
export type FHIRResource = {
   __typename?: 'FHIRResource',
  /** Type of resource */
  resourceType: FHIRResource_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
};

export enum FHIRResource_Enum_schema {
  Resource = 'Resource'
}

/** Union of all available resources */
export type FHIRResourceList = FHIRResource | FHIRAccount | FHIRActivityDefinition | FHIRAdverseEvent | FHIRAllergyIntolerance | FHIRAppointment | FHIRAppointmentResponse | FHIRAuditEvent | FHIRBasic | FHIRBinary | FHIRBiologicallyDerivedProduct | FHIRBodyStructure | FHIRBundle | FHIRCapabilityStatement | FHIRCarePlan | FHIRCareTeam | FHIRCatalogEntry | FHIRChargeItem | FHIRChargeItemDefinition | FHIRClaim | FHIRClaimResponse | FHIRClinicalImpression | FHIRCodeSystem | FHIRCommunication | FHIRCommunicationRequest | FHIRCompartmentDefinition | FHIRComposition | FHIRConceptMap | FHIRCondition | FHIRConsent | FHIRContract | FHIRCoverage | FHIRCoverageEligibilityRequest | FHIRCoverageEligibilityResponse | FHIRDetectedIssue | FHIRDevice | FHIRDeviceDefinition | FHIRDeviceMetric | FHIRDeviceRequest | FHIRDeviceUseStatement | FHIRDiagnosticReport | FHIRDocumentManifest | FHIRDocumentReference | FHIRDomainResource | FHIREffectEvidenceSynthesis | FHIREncounter | FHIREndpoint | FHIREnrollmentRequest | FHIREnrollmentResponse | FHIREpisodeOfCare | FHIREventDefinition | FHIREvidence | FHIREvidenceVariable | FHIRExampleScenario | FHIRExplanationOfBenefit | FHIRFamilyMemberHistory | FHIRFlag | FHIRGoal | FHIRGraphDefinition | FHIRGroup | FHIRGuidanceResponse | FHIRHealthcareService | FHIRImagingStudy | FHIRImmunization | FHIRImmunizationEvaluation | FHIRImmunizationRecommendation | FHIRImplementationGuide | FHIRInsurancePlan | FHIRInvoice | FHIRLibrary | FHIRLinkage | FHIRList | FHIRLocation | FHIRMeasure | FHIRMeasureReport | FHIRMedia | FHIRMedication | FHIRMedicationAdministration | FHIRMedicationDispense | FHIRMedicationKnowledge | FHIRMedicationRequest | FHIRMedicationStatement | FHIRMedicinalProduct | FHIRMedicinalProductAuthorization | FHIRMedicinalProductContraindication | FHIRMedicinalProductIndication | FHIRMedicinalProductIngredient | FHIRMedicinalProductInteraction | FHIRMedicinalProductManufactured | FHIRMedicinalProductPackaged | FHIRMedicinalProductPharmaceutical | FHIRMedicinalProductUndesirableEffect | FHIRMessageDefinition | FHIRMessageHeader | FHIRMolecularSequence | FHIRNamingSystem | FHIRNutritionOrder | FHIRObservation | FHIRObservationDefinition | FHIROperationDefinition | FHIROperationOutcome | FHIROrganization | FHIROrganizationAffiliation | FHIRParameters | FHIRPatient | FHIRPaymentNotice | FHIRPaymentReconciliation | FHIRPerson | FHIRPlanDefinition | FHIRPractitioner | FHIRPractitionerRole | FHIRProcedure | FHIRProvenance | FHIRQuestionnaire | FHIRQuestionnaireResponse | FHIRRelatedPerson | FHIRRequestGroup | FHIRResearchDefinition | FHIRResearchElementDefinition | FHIRResearchStudy | FHIRResearchSubject | FHIRRiskAssessment | FHIRRiskEvidenceSynthesis | FHIRSchedule | FHIRSearchParameter | FHIRServiceRequest | FHIRSlot | FHIRSpecimen | FHIRSpecimenDefinition | FHIRStructureDefinition | FHIRStructureMap | FHIRSubstance | FHIRSubstanceNucleicAcid | FHIRSubstancePolymer | FHIRSubstanceProtein | FHIRSubstanceReferenceInformation | FHIRSubstanceSourceMaterial | FHIRSubstanceSpecification | FHIRSupplyDelivery | FHIRSupplyRequest | FHIRTask | FHIRTerminologyCapabilities | FHIRTestReport | FHIRTestScript | FHIRValueSet | FHIRVerificationResult | FHIRVisionPrescription;

/** An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome. */
export type FHIRRiskAssessment = {
   __typename?: 'FHIRRiskAssessment',
  /** Type of resource */
  resourceType: FHIRRiskAssessment_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Business identifier assigned to the risk assessment. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A reference to the request that is fulfilled by this risk assessment. */
  basedOn?: Maybe<FHIRRiskAssessmentbasedOn_basedOn_Union>,
  /** A reference to a resource that this risk assessment is part of, such as a Procedure. */
  parent?: Maybe<FHIRRiskAssessmentparent_parent_Union>,
  /** The status of the RiskAssessment, using the same statuses as an Observation. */
  status: Scalars['FHIRCode'],
  /** The algorithm, process or mechanism used to evaluate the risk. */
  method?: Maybe<FHIRCodeableConcept>,
  /** The type of the risk assessment performed. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The patient or group the risk assessment applies to. */
  subject: FHIRRiskAssessmentsubject_subject_Union,
  /** The encounter where the assessment was performed. */
  encounter?: Maybe<FHIRRiskAssessmentencounter_encounter_Union>,
  /** The date (and possibly time) the risk assessment was performed. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The date (and possibly time) the risk assessment was performed. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** For assessments or prognosis specific to a particular condition, indicates the condition being assessed. */
  condition?: Maybe<FHIRRiskAssessmentcondition_condition_Union>,
  /** The provider or software application that performed the assessment. */
  performer?: Maybe<FHIRRiskAssessmentperformer_performer_Union>,
  /** The reason the risk assessment was performed. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Resources supporting the reason the risk assessment was performed. */
  reasonReference?: Maybe<Array<Maybe<FHIRRiskAssessmentreasonReference_reasonReference_Union>>>,
  /** 
 * Indicates the source data considered as part of the assessment (for example,
   * FamilyHistory, Observations, Procedures, Conditions, etc.).
 */
  basis?: Maybe<Array<Maybe<FHIRRiskAssessmentbasis_basis_Union>>>,
  /** Describes the expected outcome for the subject. */
  prediction?: Maybe<Array<Maybe<FHIRRiskAssessmentprediction>>>,
  /** A description of the steps that might be taken to reduce the identified risk(s). */
  mitigation?: Maybe<Scalars['String']>,
  /** Additional comments about the risk assessment. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRRiskAssessment_Enum_schema {
  RiskAssessment = 'RiskAssessment'
}

/** A reference to the request that is fulfilled by this risk assessment. */
export type FHIRRiskAssessmentbasedOn_basedOn_Union = FHIRResource;

/** 
 * Indicates the source data considered as part of the assessment (for example,
 * FamilyHistory, Observations, Procedures, Conditions, etc.).
 */
export type FHIRRiskAssessmentbasis_basis_Union = FHIRResource;

/** For assessments or prognosis specific to a particular condition, indicates the condition being assessed. */
export type FHIRRiskAssessmentcondition_condition_Union = FHIRCondition;

/** The encounter where the assessment was performed. */
export type FHIRRiskAssessmentencounter_encounter_Union = FHIREncounter;

/** A reference to a resource that this risk assessment is part of, such as a Procedure. */
export type FHIRRiskAssessmentparent_parent_Union = FHIRResource;

/** The provider or software application that performed the assessment. */
export type FHIRRiskAssessmentperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRDevice;

export type FHIRRiskAssessmentprediction = {
   __typename?: 'FHIRRiskAssessmentprediction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** One of the potential outcomes for the patient (e.g. remission, death,  a particular condition). */
  outcome?: Maybe<FHIRCodeableConcept>,
  /** Indicates how likely the outcome is (in the specified timeframe). */
  probabilityDecimal?: Maybe<Scalars['Float']>,
  /** Indicates how likely the outcome is (in the specified timeframe). */
  probabilityRange?: Maybe<FHIRRange>,
  /** 
 * Indicates how likely the outcome is (in the specified timeframe), expressed as
   * a qualitative value (e.g. low, medium, or high).
 */
  qualitativeRisk?: Maybe<FHIRCodeableConcept>,
  /** 
 * Indicates the risk for this particular subject (with their specific
   * characteristics) divided by the risk of the population in general.  (Numbers
   * greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
 */
  relativeRisk?: Maybe<Scalars['Float']>,
  /** Indicates the period of time or age range of the subject to which the specified probability applies. */
  whenPeriod?: Maybe<FHIRPeriod>,
  /** Indicates the period of time or age range of the subject to which the specified probability applies. */
  whenRange?: Maybe<FHIRRange>,
  /** Additional information explaining the basis for the prediction. */
  rationale?: Maybe<Scalars['String']>,
};

/** Resources supporting the reason the risk assessment was performed. */
export type FHIRRiskAssessmentreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** The patient or group the risk assessment applies to. */
export type FHIRRiskAssessmentsubject_subject_Union = FHIRPatient | FHIRGroup;

/** 
 * The RiskEvidenceSynthesis resource describes the likelihood of an outcome in a
 * population plus exposure state where the risk estimate is derived from a
 * combination of research studies.
 */
export type FHIRRiskEvidenceSynthesis = {
   __typename?: 'FHIRRiskEvidenceSynthesis',
  /** Type of resource */
  resourceType: FHIRRiskEvidenceSynthesis_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this risk evidence synthesis when it
   * is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this risk
   * evidence synthesis is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the risk evidence synthesis
   * is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this risk evidence synthesis when
   * it is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the risk evidence
   * synthesis when it is referenced in a specification, model, design or instance.
   * This is an arbitrary value managed by the risk evidence synthesis author and
   * is not expected to be globally unique. For example, it might be a timestamp
   * (e.g. yyyymmdd) if a managed version is not available. There is also no
   * expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the risk evidence synthesis. This name
   * should be usable as an identifier for the module by machine processing
   * applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the risk evidence synthesis. */
  title?: Maybe<Scalars['String']>,
  /** The status of this risk evidence synthesis. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * The date  (and optionally time) when the risk evidence synthesis was
   * published. The date must change when the business version changes and it must
   * change if the status code changes. In addition, it should change when the
   * substantive content of the risk evidence synthesis changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the risk evidence synthesis. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the risk evidence synthesis from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate risk
   * evidence synthesis instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the risk evidence synthesis is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A copyright statement relating to the risk evidence synthesis and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the risk evidence synthesis.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The date on which the resource content was approved by the publisher. Approval
   * happens once when the content is officially approved for usage.
 */
  approvalDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * The date on which the resource content was last reviewed. Review happens
   * periodically after approval but does not change the original approval date.
 */
  lastReviewDate?: Maybe<Scalars['FHIRDate']>,
  /** The period during which the risk evidence synthesis content was or is planned to be in active use. */
  effectivePeriod?: Maybe<FHIRPeriod>,
  /** 
 * Descriptive topics related to the content of the RiskEvidenceSynthesis. Topics
   * provide a high-level categorization grouping types of EffectEvidenceSynthesiss
   * that can be useful for filtering and searching.
 */
  topic?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** An individiual or organization primarily involved in the creation and maintenance of the content. */
  author?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for internal coherence of the content. */
  editor?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization primarily responsible for review of some aspect of the content. */
  reviewer?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** An individual or organization responsible for officially endorsing the content for use in some setting. */
  endorser?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** Related artifacts such as additional documentation, justification, or bibliographic references. */
  relatedArtifact?: Maybe<Array<Maybe<FHIRRelatedArtifact>>>,
  /** Type of synthesis eg meta-analysis. */
  synthesisType?: Maybe<FHIRCodeableConcept>,
  /** Type of study eg randomized trial. */
  studyType?: Maybe<FHIRCodeableConcept>,
  /** A reference to a EvidenceVariable resource that defines the population for the research. */
  population: FHIRRiskEvidenceSynthesispopulation_population_Union,
  /** A reference to a EvidenceVariable resource that defines the exposure for the research. */
  exposure?: Maybe<FHIRRiskEvidenceSynthesisexposure_exposure_Union>,
  /** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
  outcome: FHIRRiskEvidenceSynthesisoutcome_outcome_Union,
  /** A description of the size of the sample involved in the synthesis. */
  sampleSize?: Maybe<FHIRRiskEvidenceSynthesissampleSize>,
  /** The estimated risk of the outcome. */
  riskEstimate?: Maybe<FHIRRiskEvidenceSynthesisriskEstimate>,
  /** A description of the certainty of the risk estimate. */
  certainty?: Maybe<Array<Maybe<FHIRRiskEvidenceSynthesiscertainty>>>,
};

export enum FHIRRiskEvidenceSynthesis_Enum_schema {
  RiskEvidenceSynthesis = 'RiskEvidenceSynthesis'
}

export type FHIRRiskEvidenceSynthesiscertainty = {
   __typename?: 'FHIRRiskEvidenceSynthesiscertainty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A rating of the certainty of the effect estimate. */
  rating?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** A description of a component of the overall certainty. */
  certaintySubcomponent?: Maybe<Array<Maybe<FHIRRiskEvidenceSynthesiscertaintycertaintySubcomponent>>>,
};

export type FHIRRiskEvidenceSynthesiscertaintycertaintySubcomponent = {
   __typename?: 'FHIRRiskEvidenceSynthesiscertaintycertaintySubcomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type of subcomponent of certainty rating. */
  type?: Maybe<FHIRCodeableConcept>,
  /** A rating of a subcomponent of rating certainty. */
  rating?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A human-readable string to clarify or explain concepts about the resource. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

/** A reference to a EvidenceVariable resource that defines the exposure for the research. */
export type FHIRRiskEvidenceSynthesisexposure_exposure_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resomece that defines the outcome for the research. */
export type FHIRRiskEvidenceSynthesisoutcome_outcome_Union = FHIREvidenceVariable;

/** A reference to a EvidenceVariable resource that defines the population for the research. */
export type FHIRRiskEvidenceSynthesispopulation_population_Union = FHIREvidenceVariable;

export type FHIRRiskEvidenceSynthesisriskEstimate = {
   __typename?: 'FHIRRiskEvidenceSynthesisriskEstimate',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable summary of risk estimate. */
  description?: Maybe<Scalars['String']>,
  /** Examples include proportion and mean. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The point estimate of the risk estimate. */
  value?: Maybe<Scalars['Float']>,
  /** Specifies the UCUM unit for the outcome. */
  unitOfMeasure?: Maybe<FHIRCodeableConcept>,
  /** The sample size for the group that was measured for this risk estimate. */
  denominatorCount?: Maybe<Scalars['Int']>,
  /** The number of group members with the outcome of interest. */
  numeratorCount?: Maybe<Scalars['Int']>,
  /** A description of the precision of the estimate for the effect. */
  precisionEstimate?: Maybe<Array<Maybe<FHIRRiskEvidenceSynthesisriskEstimateprecisionEstimate>>>,
};

export type FHIRRiskEvidenceSynthesisriskEstimateprecisionEstimate = {
   __typename?: 'FHIRRiskEvidenceSynthesisriskEstimateprecisionEstimate',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Examples include confidence interval and interquartile range. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Use 95 for a 95% confidence interval. */
  level?: Maybe<Scalars['Float']>,
  /** Lower bound of confidence interval. */
  from?: Maybe<Scalars['Float']>,
  /** Upper bound of confidence interval. */
  to?: Maybe<Scalars['Float']>,
};

export type FHIRRiskEvidenceSynthesissampleSize = {
   __typename?: 'FHIRRiskEvidenceSynthesissampleSize',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Human-readable summary of sample size. */
  description?: Maybe<Scalars['String']>,
  /** Number of studies included in this evidence synthesis. */
  numberOfStudies?: Maybe<Scalars['Int']>,
  /** Number of participants included in this evidence synthesis. */
  numberOfParticipants?: Maybe<Scalars['Int']>,
};

/** 
 * Base StructureDefinition for SampledData Type: A series of measurements taken by
 * a device, with upper and lower limits. There may be more than one dimension in the data.
 */
export type FHIRSampledData = {
   __typename?: 'FHIRSampledData',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The base quantity that a measured value of zero represents. In addition, this
   * provides the units of the entire measurement series.
 */
  origin: FHIRQuantity,
  /** The length of time between sampling times, measured in milliseconds. */
  period: Scalars['Float'],
  /** A correction factor that is applied to the sampled data points before they are added to the origin. */
  factor?: Maybe<Scalars['Float']>,
  /** 
 * The lower limit of detection of the measured points. This is needed if any of
   * the data points have the value 'L' (lower than detection limit).
 */
  lowerLimit?: Maybe<Scalars['Float']>,
  /** 
 * The upper limit of detection of the measured points. This is needed if any of
   * the data points have the value 'U' (higher than detection limit).
 */
  upperLimit?: Maybe<Scalars['Float']>,
  /** 
 * The number of sample points at each time point. If this value is greater than
   * one, then the dimensions will be interlaced - all the sample points for a
   * point in time will be recorded at once.
 */
  dimensions: Scalars['FHIRPositiveInt'],
  /** 
 * A series of data points which are decimal values separated by a single space
   * (character u20). The special values 'E' (error), 'L' (below detection limit)
   * and 'U' (above detection limit) can also be used in place of a decimal value.
 */
  data?: Maybe<Scalars['String']>,
};

/** 
 * Base StructureDefinition for SampledData Type: A series of measurements taken by
 * a device, with upper and lower limits. There may be more than one dimension in the data.
 */
export type FHIRSampledData_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * The base quantity that a measured value of zero represents. In addition, this
   * provides the units of the entire measurement series.
 */
  origin: FHIRQuantity_Input,
  /** The length of time between sampling times, measured in milliseconds. */
  _period?: Maybe<FHIRElement_Input>,
  /** The length of time between sampling times, measured in milliseconds. */
  period: Scalars['Float'],
  /** A correction factor that is applied to the sampled data points before they are added to the origin. */
  _factor?: Maybe<FHIRElement_Input>,
  /** A correction factor that is applied to the sampled data points before they are added to the origin. */
  factor?: Maybe<Scalars['Float']>,
  /** 
 * The lower limit of detection of the measured points. This is needed if any of
   * the data points have the value 'L' (lower than detection limit).
 */
  _lowerLimit?: Maybe<FHIRElement_Input>,
  /** 
 * The lower limit of detection of the measured points. This is needed if any of
   * the data points have the value 'L' (lower than detection limit).
 */
  lowerLimit?: Maybe<Scalars['Float']>,
  /** 
 * The upper limit of detection of the measured points. This is needed if any of
   * the data points have the value 'U' (higher than detection limit).
 */
  _upperLimit?: Maybe<FHIRElement_Input>,
  /** 
 * The upper limit of detection of the measured points. This is needed if any of
   * the data points have the value 'U' (higher than detection limit).
 */
  upperLimit?: Maybe<Scalars['Float']>,
  /** 
 * The number of sample points at each time point. If this value is greater than
   * one, then the dimensions will be interlaced - all the sample points for a
   * point in time will be recorded at once.
 */
  _dimensions?: Maybe<FHIRElement_Input>,
  /** 
 * The number of sample points at each time point. If this value is greater than
   * one, then the dimensions will be interlaced - all the sample points for a
   * point in time will be recorded at once.
 */
  dimensions: Scalars['FHIRPositiveInt'],
  /** 
 * A series of data points which are decimal values separated by a single space
   * (character u20). The special values 'E' (error), 'L' (below detection limit)
   * and 'U' (above detection limit) can also be used in place of a decimal value.
 */
  _data?: Maybe<FHIRElement_Input>,
  /** 
 * A series of data points which are decimal values separated by a single space
   * (character u20). The special values 'E' (error), 'L' (below detection limit)
   * and 'U' (above detection limit) can also be used in place of a decimal value.
 */
  data?: Maybe<Scalars['String']>,
};

/** A container for slots of time that may be available for booking appointments. */
export type FHIRSchedule = {
   __typename?: 'FHIRSchedule',
  /** Type of resource */
  resourceType: FHIRSchedule_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** External Ids for this item. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Whether this schedule record is in active use or should not be used (such as was entered in error). */
  active?: Maybe<Scalars['Boolean']>,
  /** A broad categorization of the service that is to be performed during this appointment. */
  serviceCategory?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specific service that is to be performed during this appointment. */
  serviceType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specialty of a practitioner that would be required to perform the service requested in this appointment. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Slots that reference this schedule resource provide the availability details to these referenced resource(s). */
  actor?: Maybe<Array<FHIRScheduleactor_actor_Union>>,
  /** 
 * The period of time that the slots that reference this Schedule resource cover
   * (even if none exist). These  cover the amount of time that an organization's
   * planning horizon; the interval for which they are currently accepting
   * appointments. This does not define a 'template' for planning outside these dates.
 */
  planningHorizon?: Maybe<FHIRPeriod>,
  /** 
 * Comments on the availability to describe any extended information. Such as
   * custom constraints on the slots that may be associated.
 */
  comment?: Maybe<Scalars['String']>,
};

export enum FHIRSchedule_Enum_schema {
  Schedule = 'Schedule'
}

/** Slots that reference this schedule resource provide the availability details to these referenced resource(s). */
export type FHIRScheduleactor_actor_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRDevice | FHIRHealthcareService | FHIRLocation;

/** A search parameter that defines a named search item that can be used to search/filter on a resource. */
export type FHIRSearchParameter = {
   __typename?: 'FHIRSearchParameter',
  /** Type of resource */
  resourceType: FHIRSearchParameter_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this search parameter when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this search parameter
   * is (or will be) published. This URL can be the target of a canonical
   * reference. It SHALL remain the same when the search parameter is stored on
   * different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * The identifier that is used to identify this version of the search parameter
   * when it is referenced in a specification, model, design or instance. This is
   * an arbitrary value managed by the search parameter author and is not expected
   * to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if
   * a managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the search parameter. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name: Scalars['String'],
  /** 
 * Where this search parameter is originally defined. If a derivedFrom is
   * provided, then the details in the search parameter must be consistent with the
   * definition from which it is defined. i.e. the parameter should have the same
   * meaning, and (usually) the functionality should be a proper subset of the
   * underlying search parameter.
 */
  derivedFrom?: Maybe<Scalars['FHIRCanonical']>,
  /** The status of this search parameter. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this search parameter is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the search parameter was published. The
   * date must change when the business version changes and it must change if the
   * status code changes. In addition, it should change when the substantive
   * content of the search parameter changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the search parameter. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** And how it used. */
  description: Scalars['String'],
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate search
   * parameter instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the search parameter is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this search parameter is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** The code used in the URL or the parameter name in a parameters resource for this search parameter. */
  code: Scalars['FHIRCode'],
  /** The base resource type(s) that this search parameter can be used against. */
  base?: Maybe<Array<Scalars['FHIRCode']>>,
  /** The type of value that a search parameter may contain, and how the content is interpreted. */
  type: Scalars['FHIRCode'],
  /** A FHIRPath expression that returns a set of elements for the search parameter. */
  expression?: Maybe<Scalars['String']>,
  /** An XPath expression that returns a set of elements for the search parameter. */
  xpath?: Maybe<Scalars['String']>,
  /** How the search parameter relates to the set of elements returned by evaluating the xpath query. */
  xpathUsage?: Maybe<Scalars['FHIRCode']>,
  /** Types of resource (if a resource is referenced). */
  target?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * Whether multiple values are allowed for each time the parameter exists. Values
   * are separated by commas, and the parameter matches if any of the values match.
 */
  multipleOr?: Maybe<Scalars['Boolean']>,
  /** 
 * Whether multiple parameters are allowed - e.g. more than one parameter with
   * the same name. The search matches if all the parameters match.
 */
  multipleAnd?: Maybe<Scalars['Boolean']>,
  /** Comparators supported for the search parameter. */
  comparator?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** A modifier supported for the search parameter. */
  modifier?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** 
 * Contains the names of any search parameters which may be chained to the
   * containing search parameter. Chained parameters may be added to search
   * parameters of type reference and specify that resources will only be returned
   * if they contain a reference to a resource which matches the chained parameter
   * value. Values for this field should be drawn from SearchParameter.code for a
   * parameter on the target resource type.
 */
  chain?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Used to define the parts of a composite search parameter. */
  component?: Maybe<Array<Maybe<FHIRSearchParametercomponent>>>,
};

export enum FHIRSearchParameter_Enum_schema {
  SearchParameter = 'SearchParameter'
}

export type FHIRSearchParametercomponent = {
   __typename?: 'FHIRSearchParametercomponent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The definition of the search parameter that describes this part. */
  definition: Scalars['FHIRCanonical'],
  /** 
 * A sub-expression that defines how to extract values for this component from
   * the output of the main SearchParameter.expression.
 */
  expression: Scalars['String'],
};

/** A record of a request for service such as diagnostic investigations, treatments, or operations to be performed. */
export type FHIRServiceRequest = {
   __typename?: 'FHIRServiceRequest',
  /** Type of resource */
  resourceType: FHIRServiceRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifiers assigned to this order instance by the orderer and/or the receiver and/or order fulfiller. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a FHIR-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this ServiceRequest.
 */
  instantiatesCanonical?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** 
 * The URL pointing to an externally maintained protocol, guideline, orderset or
   * other definition that is adhered to in whole or in part by this
   * ServiceRequest.
 */
  instantiatesUri?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** Plan/proposal/order fulfilled by this request. */
  basedOn?: Maybe<Array<Maybe<FHIRServiceRequestbasedOn_basedOn_Union>>>,
  /** The request takes the place of the referenced completed or terminated request(s). */
  replaces?: Maybe<Array<Maybe<FHIRServiceRequestreplaces_replaces_Union>>>,
  /** 
 * A shared identifier common to all service requests that were authorized more
   * or less simultaneously by a single author, representing the composite or group identifier.
 */
  requisition?: Maybe<FHIRIdentifier>,
  /** The status of the order. */
  status: Scalars['FHIRCode'],
  /** Whether the request is a proposal, plan, an original order or a reflex order. */
  intent: Scalars['FHIRCode'],
  /** A code that classifies the service for searching, sorting and display purposes (e.g. 'Surgical Procedure'). */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Indicates how quickly the ServiceRequest should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** Set this to true if the record is saying that the service/procedure should NOT be performed. */
  doNotPerform?: Maybe<Scalars['Boolean']>,
  /** 
 * A code that identifies a particular service (i.e., procedure, diagnostic
   * investigation, or panel of investigations) that have been requested.
 */
  code?: Maybe<FHIRCodeableConcept>,
  /** 
 * Additional details and instructions about the how the services are to be
   * delivered.   For example, and order for a urinary catheter may have an order
   * detail for an external or indwelling catheter, or an order for a bandage may
   * require additional instructions specifying how the bandage should be applied.
 */
  orderDetail?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * An amount of service being requested which can be a quantity ( for example
   * $1,500 home modification), a ratio ( for example, 20 half day visits per
   * month), or a range (2.0 to 1.8 Gy per fraction).
 */
  quantityQuantity?: Maybe<FHIRQuantity>,
  /** 
 * An amount of service being requested which can be a quantity ( for example
   * $1,500 home modification), a ratio ( for example, 20 half day visits per
   * month), or a range (2.0 to 1.8 Gy per fraction).
 */
  quantityRatio?: Maybe<FHIRRatio>,
  /** 
 * An amount of service being requested which can be a quantity ( for example
   * $1,500 home modification), a ratio ( for example, 20 half day visits per
   * month), or a range (2.0 to 1.8 Gy per fraction).
 */
  quantityRange?: Maybe<FHIRRange>,
  /** 
 * On whom or what the service is to be performed. This is usually a human
   * patient, but can also be requested on animals, groups of humans or animals,
   * devices such as dialysis machines, or even locations (typically for
   * environmental scans).
 */
  subject: FHIRServiceRequestsubject_subject_Union,
  /** An encounter that provides additional information about the healthcare context in which this request is made. */
  encounter?: Maybe<FHIRServiceRequestencounter_encounter_Union>,
  /** The date/time at which the requested service should occur. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The date/time at which the requested service should occur. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** The date/time at which the requested service should occur. */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** 
 * If a CodeableConcept is present, it indicates the pre-condition for performing
   * the service.  For example 'pain', 'on flare-up', etc.
 */
  asNeededBoolean?: Maybe<Scalars['Boolean']>,
  /** 
 * If a CodeableConcept is present, it indicates the pre-condition for performing
   * the service.  For example 'pain', 'on flare-up', etc.
 */
  asNeededCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** When the request transitioned to being actionable. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The individual who initiated the request and has responsibility for its activation. */
  requester?: Maybe<FHIRServiceRequestrequester_requester_Union>,
  /** Desired type of performer for doing the requested service. */
  performerType?: Maybe<FHIRCodeableConcept>,
  /** The desired performer for doing the requested service.  For example, the surgeon, dermatopathologist, endoscopist, etc. */
  performer?: Maybe<Array<Maybe<FHIRServiceRequestperformer_performer_Union>>>,
  /** 
 * The preferred location(s) where the procedure should actually happen in coded
   * or free text form. E.g. at home or nursing day care center.
 */
  locationCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * A reference to the the preferred location(s) where the procedure should
   * actually happen. E.g. at home or nursing day care center.
 */
  locationReference?: Maybe<Array<Maybe<FHIRServiceRequestlocationReference_locationReference_Union>>>,
  /** 
 * An explanation or justification for why this service is being requested in
   * coded or textual form.   This is often for billing purposes.  May relate to
   * the resources referred to in `supportingInfo`.
 */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Indicates another resource that provides a justification for why this service
   * is being requested.   May relate to the resources referred to in
   * `supportingInfo`.
 */
  reasonReference?: Maybe<Array<Maybe<FHIRServiceRequestreasonReference_reasonReference_Union>>>,
  /** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
   * pre-determinations that may be needed for delivering the requested service.
 */
  insurance?: Maybe<Array<Maybe<FHIRServiceRequestinsurance_insurance_Union>>>,
  /** 
 * Additional clinical information about the patient or specimen that may
   * influence the services or their interpretations.     This information includes
   * diagnosis, clinical findings and other observations.  In laboratory ordering
   * these are typically referred to as 'ask at order entry questions (AOEs)'. 
   * This includes observations explicitly requested by the producer (filler) to
   * provide context or supporting information needed to complete the order. For
   * example,  reporting the amount of inspired oxygen for blood gas measurements.
 */
  supportingInfo?: Maybe<Array<Maybe<FHIRServiceRequestsupportingInfo_supportingInfo_Union>>>,
  /** One or more specimens that the laboratory procedure will use. */
  specimen?: Maybe<Array<Maybe<FHIRServiceRequestspecimen_specimen_Union>>>,
  /** Anatomic location where the procedure should be performed. This is the target site. */
  bodySite?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Any other notes and comments made about the service request. For example, internal billing notes. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** Instructions in terms that are understood by the patient or consumer. */
  patientInstruction?: Maybe<Scalars['String']>,
  /** Key events in the history of the request. */
  relevantHistory?: Maybe<Array<Maybe<FHIRServiceRequestrelevantHistory_relevantHistory_Union>>>,
};

export enum FHIRServiceRequest_Enum_schema {
  ServiceRequest = 'ServiceRequest'
}

/** Plan/proposal/order fulfilled by this request. */
export type FHIRServiceRequestbasedOn_basedOn_Union = FHIRCarePlan | FHIRServiceRequest | FHIRMedicationRequest;

/** An encounter that provides additional information about the healthcare context in which this request is made. */
export type FHIRServiceRequestencounter_encounter_Union = FHIREncounter;

/** 
 * Insurance plans, coverage extensions, pre-authorizations and/or
 * pre-determinations that may be needed for delivering the requested service.
 */
export type FHIRServiceRequestinsurance_insurance_Union = FHIRCoverage | FHIRClaimResponse;

/** 
 * A reference to the the preferred location(s) where the procedure should actually
 * happen. E.g. at home or nursing day care center.
 */
export type FHIRServiceRequestlocationReference_locationReference_Union = FHIRLocation;

/** The desired performer for doing the requested service.  For example, the surgeon, dermatopathologist, endoscopist, etc. */
export type FHIRServiceRequestperformer_performer_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRHealthcareService | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** 
 * Indicates another resource that provides a justification for why this service is
 * being requested.   May relate to the resources referred to in `supportingInfo`.
 */
export type FHIRServiceRequestreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** Key events in the history of the request. */
export type FHIRServiceRequestrelevantHistory_relevantHistory_Union = FHIRProvenance;

/** The request takes the place of the referenced completed or terminated request(s). */
export type FHIRServiceRequestreplaces_replaces_Union = FHIRServiceRequest;

/** The individual who initiated the request and has responsibility for its activation. */
export type FHIRServiceRequestrequester_requester_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** One or more specimens that the laboratory procedure will use. */
export type FHIRServiceRequestspecimen_specimen_Union = FHIRSpecimen;

/** 
 * On whom or what the service is to be performed. This is usually a human patient,
 * but can also be requested on animals, groups of humans or animals, devices such
 * as dialysis machines, or even locations (typically for environmental scans).
 */
export type FHIRServiceRequestsubject_subject_Union = FHIRPatient | FHIRGroup | FHIRLocation | FHIRDevice;

/** 
 * Additional clinical information about the patient or specimen that may influence
 * the services or their interpretations.     This information includes diagnosis,
 * clinical findings and other observations.  In laboratory ordering these are
 * typically referred to as 'ask at order entry questions (AOEs)'.  This includes
 * observations explicitly requested by the producer (filler) to provide context or
 * supporting information needed to complete the order. For example,  reporting the
 * amount of inspired oxygen for blood gas measurements.
 */
export type FHIRServiceRequestsupportingInfo_supportingInfo_Union = FHIRResource;

/** 
 * Base StructureDefinition for Signature Type: A signature along with supporting
 * context. The signature may be a digital signature that is cryptographic in
 * nature, or some other signature acceptable to the domain. This other signature
 * may be as simple as a graphical image representing a hand-written signature, or
 * a signature ceremony Different signature approaches have different utilities.
 */
export type FHIRSignature = {
   __typename?: 'FHIRSignature',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An indication of the reason that the entity signed this document. This may be
   * explicitly included as part of the signature information and can be used when
   * determining accountability for various actions concerning the document.
 */
  type?: Maybe<Array<FHIRCoding>>,
  /** When the digital signature was signed. */
  when: Scalars['FHIRInstant'],
  /** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key). */
  who: FHIRSignaturewho_who_Union,
  /** A reference to an application-usable description of the identity that is represented by the signature. */
  onBehalfOf?: Maybe<FHIRSignatureonBehalfOf_onBehalfOf_Union>,
  /** A mime type that indicates the technical format of the target resources signed by the signature. */
  targetFormat?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A mime type that indicates the technical format of the signature. Important
   * mime types are application/signature+xml for X ML DigSig, application/jose for
   * JWS, and image/* for a graphical image of a signature, etc.
 */
  sigFormat?: Maybe<Scalars['FHIRCode']>,
  /** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty. */
  data?: Maybe<Scalars['FHIRBase64Binary']>,
};

/** 
 * Base StructureDefinition for Signature Type: A signature along with supporting
 * context. The signature may be a digital signature that is cryptographic in
 * nature, or some other signature acceptable to the domain. This other signature
 * may be as simple as a graphical image representing a hand-written signature, or
 * a signature ceremony Different signature approaches have different utilities.
 */
export type FHIRSignature_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * An indication of the reason that the entity signed this document. This may be
   * explicitly included as part of the signature information and can be used when
   * determining accountability for various actions concerning the document.
 */
  type?: Maybe<Array<FHIRCoding_Input>>,
  /** When the digital signature was signed. */
  _when?: Maybe<FHIRElement_Input>,
  /** When the digital signature was signed. */
  when: Scalars['FHIRInstant'],
  /** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key). */
  who: Scalars['String'],
  /** A reference to an application-usable description of the identity that is represented by the signature. */
  onBehalfOf?: Maybe<Scalars['String']>,
  /** A mime type that indicates the technical format of the target resources signed by the signature. */
  _targetFormat?: Maybe<FHIRElement_Input>,
  /** A mime type that indicates the technical format of the target resources signed by the signature. */
  targetFormat?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A mime type that indicates the technical format of the signature. Important
   * mime types are application/signature+xml for X ML DigSig, application/jose for
   * JWS, and image/* for a graphical image of a signature, etc.
 */
  _sigFormat?: Maybe<FHIRElement_Input>,
  /** 
 * A mime type that indicates the technical format of the signature. Important
   * mime types are application/signature+xml for X ML DigSig, application/jose for
   * JWS, and image/* for a graphical image of a signature, etc.
 */
  sigFormat?: Maybe<Scalars['FHIRCode']>,
  /** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty. */
  _data?: Maybe<FHIRElement_Input>,
  /** The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty. */
  data?: Maybe<Scalars['FHIRBase64Binary']>,
};

/** A reference to an application-usable description of the identity that is represented by the signature. */
export type FHIRSignatureonBehalfOf_onBehalfOf_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRPatient | FHIRDevice | FHIROrganization;

/** A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key). */
export type FHIRSignaturewho_who_Union = FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRPatient | FHIRDevice | FHIROrganization;

/** A slot of time on a schedule that may be available for booking appointments. */
export type FHIRSlot = {
   __typename?: 'FHIRSlot',
  /** Type of resource */
  resourceType: FHIRSlot_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** External Ids for this item. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A broad categorization of the service that is to be performed during this appointment. */
  serviceCategory?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The type of appointments that can be booked into this slot (ideally this would
   * be an identifiable service - which is at a location, rather than the location
   * itself). If provided then this overrides the value provided on the
   * availability resource.
 */
  serviceType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The specialty of a practitioner that would be required to perform the service requested in this appointment. */
  specialty?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The style of appointment or patient that may be booked in the slot (not service type). */
  appointmentType?: Maybe<FHIRCodeableConcept>,
  /** The schedule resource that this slot defines an interval of status information. */
  schedule: FHIRSlotschedule_schedule_Union,
  /** busy | free | busy-unavailable | busy-tentative | entered-in-error. */
  status: Scalars['FHIRCode'],
  /** Date/Time that the slot is to begin. */
  start: Scalars['FHIRInstant'],
  /** Date/Time that the slot is to conclude. */
  end: Scalars['FHIRInstant'],
  /** This slot has already been overbooked, appointments are unlikely to be accepted for this time. */
  overbooked?: Maybe<Scalars['Boolean']>,
  /** Comments on the slot to describe any extended information. Such as custom constraints on the slot. */
  comment?: Maybe<Scalars['String']>,
};

export enum FHIRSlot_Enum_schema {
  Slot = 'Slot'
}

/** The schedule resource that this slot defines an interval of status information. */
export type FHIRSlotschedule_schedule_Union = FHIRSchedule;

/** A sample to be used for analysis. */
export type FHIRSpecimen = {
   __typename?: 'FHIRSpecimen',
  /** Type of resource */
  resourceType: FHIRSpecimen_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Id for specimen. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier assigned by the lab when accessioning specimen(s). This is not
   * necessarily the same as the specimen identifier, depending on local lab procedures.
 */
  accessionIdentifier?: Maybe<FHIRIdentifier>,
  /** The availability of the specimen. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** The kind of material that forms the specimen. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Where the specimen came from. This may be from patient(s), from a location
   * (e.g., the source of an environmental sample), or a sampling of a substance or a device.
 */
  subject?: Maybe<FHIRSpecimensubject_subject_Union>,
  /** Time when specimen was received for processing or testing. */
  receivedTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * Reference to the parent (source) specimen which is used when the specimen was
   * either derived from or a component of another specimen.
 */
  parent?: Maybe<Array<Maybe<FHIRSpecimenparent_parent_Union>>>,
  /** Details concerning a service request that required a specimen to be collected. */
  request?: Maybe<Array<Maybe<FHIRSpecimenrequest_request_Union>>>,
  /** Details concerning the specimen collection. */
  collection?: Maybe<FHIRSpecimencollection>,
  /** Details concerning processing and processing steps for the specimen. */
  processing?: Maybe<Array<Maybe<FHIRSpecimenprocessing>>>,
  /** 
 * The container holding the specimen.  The recursive nature of containers; i.e.
   * blood in tube in tray in rack is not addressed here.
 */
  container?: Maybe<Array<Maybe<FHIRSpecimencontainer>>>,
  /** A mode or state of being that describes the nature of the specimen. */
  condition?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * To communicate any details or issues about the specimen or during the specimen
   * collection. (for example: broken vial, sent with patient, frozen).
 */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export enum FHIRSpecimen_Enum_schema {
  Specimen = 'Specimen'
}

export type FHIRSpecimencollection = {
   __typename?: 'FHIRSpecimencollection',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Person who collected the specimen. */
  collector?: Maybe<FHIRSpecimencollectioncollector_collector_Union>,
  /** Time when specimen was collected from subject - the physiologically relevant time. */
  collectedDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** Time when specimen was collected from subject - the physiologically relevant time. */
  collectedPeriod?: Maybe<FHIRPeriod>,
  /** The span of time over which the collection of a specimen occurred. */
  duration?: Maybe<FHIRDuration>,
  /** 
 * The quantity of specimen collected; for instance the volume of a blood sample,
   * or the physical measurement of an anatomic pathology sample.
 */
  quantity?: Maybe<FHIRQuantity>,
  /** A coded value specifying the technique that is used to perform the procedure. */
  method?: Maybe<FHIRCodeableConcept>,
  /** 
 * Anatomical location from which the specimen was collected (if subject is a
   * patient). This is the target site.  This element is not used for environmental specimens.
 */
  bodySite?: Maybe<FHIRCodeableConcept>,
  /** Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection. */
  fastingStatusCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection. */
  fastingStatusDuration?: Maybe<FHIRDuration>,
};

/** Person who collected the specimen. */
export type FHIRSpecimencollectioncollector_collector_Union = FHIRPractitioner | FHIRPractitionerRole;

export type FHIRSpecimencontainer = {
   __typename?: 'FHIRSpecimencontainer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Id for container. There may be multiple; a manufacturer's bar code, lab
   * assigned identifier, etc. The container ID may differ from the specimen id in
   * some circumstances.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Textual description of the container. */
  description?: Maybe<Scalars['String']>,
  /** The type of container associated with the specimen (e.g. slide, aliquot, etc.). */
  type?: Maybe<FHIRCodeableConcept>,
  /** The capacity (volume or other measure) the container may contain. */
  capacity?: Maybe<FHIRQuantity>,
  /** 
 * The quantity of specimen in the container; may be volume, dimensions, or other
   * appropriate measurements, depending on the specimen type.
 */
  specimenQuantity?: Maybe<FHIRQuantity>,
  /** Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. */
  additiveCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. */
  additiveReference?: Maybe<FHIRSpecimencontaineradditiveReference_additiveReference_Union>,
};

/** Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. */
export type FHIRSpecimencontaineradditiveReference_additiveReference_Union = FHIRSubstance;

/** A kind of specimen with associated set of requirements. */
export type FHIRSpecimenDefinition = {
   __typename?: 'FHIRSpecimenDefinition',
  /** Type of resource */
  resourceType: FHIRSpecimenDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A business identifier associated with the kind of specimen. */
  identifier?: Maybe<FHIRIdentifier>,
  /** The kind of material to be collected. */
  typeCollected?: Maybe<FHIRCodeableConcept>,
  /** Preparation of the patient for specimen collection. */
  patientPreparation?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Time aspect of specimen collection (duration or offset). */
  timeAspect?: Maybe<Scalars['String']>,
  /** The action to be performed for collecting the specimen. */
  collection?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Specimen conditioned in a container as expected by the testing laboratory. */
  typeTested?: Maybe<Array<Maybe<FHIRSpecimenDefinitiontypeTested>>>,
};

export enum FHIRSpecimenDefinition_Enum_schema {
  SpecimenDefinition = 'SpecimenDefinition'
}

export type FHIRSpecimenDefinitiontypeTested = {
   __typename?: 'FHIRSpecimenDefinitiontypeTested',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Primary of secondary specimen. */
  isDerived?: Maybe<Scalars['Boolean']>,
  /** The kind of specimen conditioned for testing expected by lab. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The preference for this type of conditioned specimen. */
  preference: Scalars['FHIRCode'],
  /** The specimen's container. */
  container?: Maybe<FHIRSpecimenDefinitiontypeTestedcontainer>,
  /** Requirements for delivery and special handling of this kind of conditioned specimen. */
  requirement?: Maybe<Scalars['String']>,
  /** 
 * The usual time that a specimen of this kind is retained after the ordered
   * tests are completed, for the purpose of additional testing.
 */
  retentionTime?: Maybe<FHIRDuration>,
  /** Criterion for rejection of the specimen in its container by the laboratory. */
  rejectionCriterion?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * Set of instructions for preservation/transport of the specimen at a defined
   * temperature interval, prior the testing process.
 */
  handling?: Maybe<Array<Maybe<FHIRSpecimenDefinitiontypeTestedhandling>>>,
};

export type FHIRSpecimenDefinitiontypeTestedcontainer = {
   __typename?: 'FHIRSpecimenDefinitiontypeTestedcontainer',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of material of the container. */
  material?: Maybe<FHIRCodeableConcept>,
  /** The type of container used to contain this kind of specimen. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Color of container cap. */
  cap?: Maybe<FHIRCodeableConcept>,
  /** The textual description of the kind of container. */
  description?: Maybe<Scalars['String']>,
  /** The capacity (volume or other measure) of this kind of container. */
  capacity?: Maybe<FHIRQuantity>,
  /** The minimum volume to be conditioned in the container. */
  minimumVolumeQuantity?: Maybe<FHIRQuantity>,
  /** The minimum volume to be conditioned in the container. */
  minimumVolumeString?: Maybe<Scalars['String']>,
  /** 
 * Substance introduced in the kind of container to preserve, maintain or enhance
   * the specimen. Examples: Formalin, Citrate, EDTA.
 */
  additive?: Maybe<Array<Maybe<FHIRSpecimenDefinitiontypeTestedcontaineradditive>>>,
  /** Special processing that should be applied to the container for this kind of specimen. */
  preparation?: Maybe<Scalars['String']>,
};

export type FHIRSpecimenDefinitiontypeTestedcontaineradditive = {
   __typename?: 'FHIRSpecimenDefinitiontypeTestedcontaineradditive',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Substance introduced in the kind of container to preserve, maintain or enhance
   * the specimen. Examples: Formalin, Citrate, EDTA.
 */
  additiveCodeableConcept: FHIRCodeableConcept,
  /** 
 * Substance introduced in the kind of container to preserve, maintain or enhance
   * the specimen. Examples: Formalin, Citrate, EDTA.
 */
  additiveReference: FHIRSpecimenDefinitiontypeTestedcontaineradditiveadditiveReference_additiveReference_Union,
};

/** 
 * Substance introduced in the kind of container to preserve, maintain or enhance
 * the specimen. Examples: Formalin, Citrate, EDTA.
 */
export type FHIRSpecimenDefinitiontypeTestedcontaineradditiveadditiveReference_additiveReference_Union = FHIRSubstance;

export type FHIRSpecimenDefinitiontypeTestedhandling = {
   __typename?: 'FHIRSpecimenDefinitiontypeTestedhandling',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * It qualifies the interval of temperature, which characterizes an occurrence of
   * handling. Conditions that are not related to temperature may be handled in the
   * instruction element.
 */
  temperatureQualifier?: Maybe<FHIRCodeableConcept>,
  /** The temperature interval for this set of handling instructions. */
  temperatureRange?: Maybe<FHIRRange>,
  /** The maximum time interval of preservation of the specimen with these conditions. */
  maxDuration?: Maybe<FHIRDuration>,
  /** 
 * Additional textual instructions for the preservation or transport of the
   * specimen. For instance, 'Protect from light exposure'.
 */
  instruction?: Maybe<Scalars['String']>,
};

/** 
 * Reference to the parent (source) specimen which is used when the specimen was
 * either derived from or a component of another specimen.
 */
export type FHIRSpecimenparent_parent_Union = FHIRSpecimen;

export type FHIRSpecimenprocessing = {
   __typename?: 'FHIRSpecimenprocessing',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Textual description of procedure. */
  description?: Maybe<Scalars['String']>,
  /** A coded value specifying the procedure used to process the specimen. */
  procedure?: Maybe<FHIRCodeableConcept>,
  /** Material used in the processing step. */
  additive?: Maybe<Array<Maybe<FHIRSpecimenprocessingadditive_additive_Union>>>,
  /** 
 * A record of the time or period when the specimen processing occurred.  For
   * example the time of sample fixation or the period of time the sample was in formalin.
 */
  timeDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * A record of the time or period when the specimen processing occurred.  For
   * example the time of sample fixation or the period of time the sample was in formalin.
 */
  timePeriod?: Maybe<FHIRPeriod>,
};

/** Material used in the processing step. */
export type FHIRSpecimenprocessingadditive_additive_Union = FHIRSubstance;

/** Details concerning a service request that required a specimen to be collected. */
export type FHIRSpecimenrequest_request_Union = FHIRServiceRequest;

/** 
 * Where the specimen came from. This may be from patient(s), from a location
 * (e.g., the source of an environmental sample), or a sampling of a substance or a device.
 */
export type FHIRSpecimensubject_subject_Union = FHIRPatient | FHIRGroup | FHIRDevice | FHIRSubstance | FHIRLocation;

/** 
 * A definition of a FHIR structure. This resource is used to describe the
 * underlying resources, data types defined in FHIR, and also for describing
 * extensions and constraints on resources and data types.
 */
export type FHIRStructureDefinition = {
   __typename?: 'FHIRStructureDefinition',
  /** Type of resource */
  resourceType: FHIRStructureDefinition_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this structure definition when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this structure
   * definition is (or will be) published. This URL can be the target of a
   * canonical reference. It SHALL remain the same when the structure definition is
   * stored on different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * A formal identifier that is used to identify this structure definition when it
   * is represented in other formats, or referenced in a specification, model,
   * design or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the structure
   * definition when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the structure definition
   * author and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the structure definition. This name should
   * be usable as an identifier for the module by machine processing applications
   * such as code generation.
 */
  name: Scalars['String'],
  /** A short, descriptive, user-friendly title for the structure definition. */
  title?: Maybe<Scalars['String']>,
  /** The status of this structure definition. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this structure definition is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the structure definition was published.
   * The date must change when the business version changes and it must change if
   * the status code changes. In addition, it should change when the substantive
   * content of the structure definition changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the structure definition. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the structure definition from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate structure
   * definition instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the structure definition is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this structure definition is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the structure definition and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the structure definition.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * A set of key words or terms from external terminologies that may be used to
   * assist with indexing and searching of templates nby describing the use of this
   * structure definition, or the content it describes.
 */
  keyword?: Maybe<Array<Maybe<FHIRCoding>>>,
  /** 
 * The version of the FHIR specification on which this StructureDefinition is
   * based - this is the formal version of the specification, without the revision
   * number, e.g. [publication].[major].[minor], which is 4.0.0. for this version.
 */
  fhirVersion?: Maybe<Scalars['FHIRCode']>,
  /** An external specification that the content is mapped to. */
  mapping?: Maybe<Array<Maybe<FHIRStructureDefinitionmapping>>>,
  /** Defines the kind of structure that this definition is describing. */
  kind: Scalars['FHIRCode'],
  /** 
 * Whether structure this definition describes is abstract or not  - that is,
   * whether the structure is not intended to be instantiated. For Resources and
   * Data types, abstract types will never be exchanged  between systems.
 */
  abstract: Scalars['Boolean'],
  /** Identifies the types of resource or data type elements to which the extension can be applied. */
  context?: Maybe<Array<Maybe<FHIRStructureDefinitioncontext>>>,
  /** 
 * A set of rules as FHIRPath Invariants about when the extension can be used
   * (e.g. co-occurrence variants for the extension). All the rules must be true.
 */
  contextInvariant?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * The type this structure describes. If the derivation kind is 'specialization'
   * then this is the master definition for a type, and there is always one of
   * these (a data type, an extension, a resource, including abstract ones).
   * Otherwise the structure definition is a constraint on the stated type (and in
   * this case, the type cannot be an abstract type).  References are URLs that are
   * relative to http://hl7.org/fhir/StructureDefinition e.g. 'string' is a
   * reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are
   * only allowed in logical models.
 */
  type: Scalars['FHIRUri'],
  /** An absolute URI that is the base structure from which this type is derived, either by specialization or constraint. */
  baseDefinition?: Maybe<Scalars['FHIRCanonical']>,
  /** How the type relates to the baseDefinition. */
  derivation?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A snapshot view is expressed in a standalone form that can be used and
   * interpreted without considering the base StructureDefinition.
 */
  snapshot?: Maybe<FHIRStructureDefinitionsnapshot>,
  /** A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies. */
  differential?: Maybe<FHIRStructureDefinitiondifferential>,
};

export enum FHIRStructureDefinition_Enum_schema {
  StructureDefinition = 'StructureDefinition'
}

export type FHIRStructureDefinitioncontext = {
   __typename?: 'FHIRStructureDefinitioncontext',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Defines how to interpret the expression that defines what the context of the extension is. */
  type: Scalars['FHIRCode'],
  /** An expression that defines where an extension can be used in resources. */
  expression: Scalars['String'],
};

export type FHIRStructureDefinitiondifferential = {
   __typename?: 'FHIRStructureDefinitiondifferential',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Captures constraints on each element within the resource. */
  element?: Maybe<Array<FHIRElementDefinition>>,
};

export type FHIRStructureDefinitionmapping = {
   __typename?: 'FHIRStructureDefinitionmapping',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An Internal id that is used to identify this mapping set when specific mappings are made. */
  identity: Scalars['FHIRId'],
  /** An absolute URI that identifies the specification that this mapping is expressed to. */
  uri?: Maybe<Scalars['FHIRUri']>,
  /** A name for the specification that is being mapped to. */
  name?: Maybe<Scalars['String']>,
  /** Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage. */
  comment?: Maybe<Scalars['String']>,
};

export type FHIRStructureDefinitionsnapshot = {
   __typename?: 'FHIRStructureDefinitionsnapshot',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Captures constraints on each element within the resource. */
  element?: Maybe<Array<FHIRElementDefinition>>,
};

/** A Map of relationships between 2 structures that can be used to transform data. */
export type FHIRStructureMap = {
   __typename?: 'FHIRStructureMap',
  /** Type of resource */
  resourceType: FHIRStructureMap_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this structure map when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this structure map is
   * (or will be) published. This URL can be the target of a canonical reference.
   * It SHALL remain the same when the structure map is stored on different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * A formal identifier that is used to identify this structure map when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the structure map when
   * it is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the structure map author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the structure map. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name: Scalars['String'],
  /** A short, descriptive, user-friendly title for the structure map. */
  title?: Maybe<Scalars['String']>,
  /** The status of this structure map. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this structure map is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the structure map was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the structure map changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the structure map. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the structure map from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate structure map instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the structure map is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this structure map is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the structure map and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the structure map.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * A structure definition used by this map. The structure definition may describe
   * instances that are converted, or the instances that are produced.
 */
  structure?: Maybe<Array<Maybe<FHIRStructureMapstructure>>>,
  /** Other maps used by this map (canonical URLs). */
  import?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
  /** Organizes the mapping into manageable chunks for human review/ease of maintenance. */
  group?: Maybe<Array<FHIRStructureMapgroup>>,
};

export enum FHIRStructureMap_Enum_schema {
  StructureMap = 'StructureMap'
}

export type FHIRStructureMapgroup = {
   __typename?: 'FHIRStructureMapgroup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique name for the group for the convenience of human readers. */
  name: Scalars['FHIRId'],
  /** Another group that this group adds rules to. */
  extends?: Maybe<Scalars['FHIRId']>,
  /** If this is the default rule set to apply for the source type or this combination of types. */
  typeMode: Scalars['FHIRCode'],
  /** Additional supporting documentation that explains the purpose of the group and the types of mappings within it. */
  documentation?: Maybe<Scalars['String']>,
  /** A name assigned to an instance of data. The instance must be provided when the mapping is invoked. */
  input?: Maybe<Array<FHIRStructureMapgroupinput>>,
  /** Transform Rule from source to target. */
  rule?: Maybe<Array<FHIRStructureMapgrouprule>>,
};

export type FHIRStructureMapgroupinput = {
   __typename?: 'FHIRStructureMapgroupinput',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name for this instance of data. */
  name: Scalars['FHIRId'],
  /** Type for this instance of data. */
  type?: Maybe<Scalars['String']>,
  /** Mode for this instance of data. */
  mode: Scalars['FHIRCode'],
  /** Documentation for this instance of data. */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRStructureMapgrouprule = {
   __typename?: 'FHIRStructureMapgrouprule',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name of the rule for internal references. */
  name: Scalars['FHIRId'],
  /** Source inputs to the mapping. */
  source?: Maybe<Array<FHIRStructureMapgrouprulesource>>,
  /** Content to create because of this mapping rule. */
  target?: Maybe<Array<Maybe<FHIRStructureMapgroupruletarget>>>,
  /** Which other rules to apply in the context of this rule. */
  dependent?: Maybe<Array<Maybe<FHIRStructureMapgroupruledependent>>>,
  /** Documentation for this instance of data. */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRStructureMapgroupruledependent = {
   __typename?: 'FHIRStructureMapgroupruledependent',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name of a rule or group to apply. */
  name: Scalars['FHIRId'],
  /** Variable to pass to the rule or group. */
  variable?: Maybe<Array<Scalars['String']>>,
};

export type FHIRStructureMapgrouprulesource = {
   __typename?: 'FHIRStructureMapgrouprulesource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type or variable this rule applies to. */
  context: Scalars['FHIRId'],
  /** 
 * Specified minimum cardinality for the element. This is optional; if present,
   * it acts an implicit check on the input content.
 */
  min?: Maybe<Scalars['Int']>,
  /** 
 * Specified maximum cardinality for the element - a number or a '*'. This is
   * optional; if present, it acts an implicit check on the input content (* just
   * serves as documentation; it's the default value).
 */
  max?: Maybe<Scalars['String']>,
  /** Specified type for the element. This works as a condition on the mapping - use for polymorphic elements. */
  type?: Maybe<Scalars['String']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueBase64Binary?: Maybe<Scalars['FHIRBase64Binary']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueBoolean?: Maybe<Scalars['Boolean']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueCode?: Maybe<Scalars['FHIRCode']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDate?: Maybe<Scalars['FHIRDate']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDecimal?: Maybe<Scalars['Float']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueId?: Maybe<Scalars['FHIRId']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueInstant?: Maybe<Scalars['FHIRInstant']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueInteger?: Maybe<Scalars['Int']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueMarkdown?: Maybe<Scalars['String']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueOid?: Maybe<Scalars['FHIROid']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValuePositiveInt?: Maybe<Scalars['FHIRPositiveInt']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueString?: Maybe<Scalars['String']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueTime?: Maybe<Scalars['FHIRTime']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueUnsignedInt?: Maybe<Scalars['FHIRUnsignedInt']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueUri?: Maybe<Scalars['FHIRUri']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueUrl?: Maybe<Scalars['FHIRUrl']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueUuid?: Maybe<Scalars['FHIRUuid']>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueAddress?: Maybe<FHIRAddress>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueAge?: Maybe<FHIRAge>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueAnnotation?: Maybe<FHIRAnnotation>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueAttachment?: Maybe<FHIRAttachment>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueCoding?: Maybe<FHIRCoding>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueContactPoint?: Maybe<FHIRContactPoint>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueCount?: Maybe<FHIRCount>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDistance?: Maybe<FHIRDistance>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDuration?: Maybe<FHIRDuration>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueHumanName?: Maybe<FHIRHumanName>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueIdentifier?: Maybe<FHIRIdentifier>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueMoney?: Maybe<FHIRMoney>,
  /** A value to use if there is no existing value in the source object. */
  defaultValuePeriod?: Maybe<FHIRPeriod>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueQuantity?: Maybe<FHIRQuantity>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueRange?: Maybe<FHIRRange>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueRatio?: Maybe<FHIRRatio>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueReference?: Maybe<FHIRResourceList>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueSampledData?: Maybe<FHIRSampledData>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueSignature?: Maybe<FHIRSignature>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueTiming?: Maybe<FHIRTiming>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueContactDetail?: Maybe<FHIRContactDetail>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueContributor?: Maybe<FHIRContributor>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDataRequirement?: Maybe<FHIRDataRequirement>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueExpression?: Maybe<FHIRExpression>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueParameterDefinition?: Maybe<FHIRParameterDefinition>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueRelatedArtifact?: Maybe<FHIRRelatedArtifact>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueTriggerDefinition?: Maybe<FHIRTriggerDefinition>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueUsageContext?: Maybe<FHIRUsageContext>,
  /** A value to use if there is no existing value in the source object. */
  defaultValueDosage?: Maybe<FHIRDosage>,
  /** Optional field for this source. */
  element?: Maybe<Scalars['String']>,
  /** How to handle the list mode for this element. */
  listMode?: Maybe<Scalars['FHIRCode']>,
  /** Named context for field, if a field is specified. */
  variable?: Maybe<Scalars['FHIRId']>,
  /** FHIRPath expression  - must be true or the rule does not apply. */
  condition?: Maybe<Scalars['String']>,
  /** FHIRPath expression  - must be true or the mapping engine throws an error instead of completing. */
  check?: Maybe<Scalars['String']>,
  /** 
 * A FHIRPath expression which specifies a message to put in the transform log
   * when content matching the source rule is found.
 */
  logMessage?: Maybe<Scalars['String']>,
};

export type FHIRStructureMapgroupruletarget = {
   __typename?: 'FHIRStructureMapgroupruletarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Type or variable this rule applies to. */
  context?: Maybe<Scalars['FHIRId']>,
  /** How to interpret the context. */
  contextType?: Maybe<Scalars['FHIRCode']>,
  /** Field to create in the context. */
  element?: Maybe<Scalars['String']>,
  /** Named context for field, if desired, and a field is specified. */
  variable?: Maybe<Scalars['FHIRId']>,
  /** If field is a list, how to manage the list. */
  listMode?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Internal rule reference for shared list items. */
  listRuleId?: Maybe<Scalars['FHIRId']>,
  /** How the data is copied / created. */
  transform?: Maybe<Scalars['FHIRCode']>,
  /** Parameters to the transform. */
  parameter?: Maybe<Array<Maybe<FHIRStructureMapgroupruletargetparameter>>>,
};

export type FHIRStructureMapgroupruletargetparameter = {
   __typename?: 'FHIRStructureMapgroupruletargetparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Parameter value - variable or literal. */
  valueId: Scalars['FHIRId'],
  /** Parameter value - variable or literal. */
  valueString: Scalars['String'],
  /** Parameter value - variable or literal. */
  valueBoolean: Scalars['Boolean'],
  /** Parameter value - variable or literal. */
  valueInteger: Scalars['Int'],
  /** Parameter value - variable or literal. */
  valueDecimal: Scalars['Float'],
};

export type FHIRStructureMapstructure = {
   __typename?: 'FHIRStructureMapstructure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The canonical reference to the structure. */
  url: Scalars['FHIRCanonical'],
  /** How the referenced structure is used in this mapping. */
  mode: Scalars['FHIRCode'],
  /** The name used for this type in the map. */
  alias?: Maybe<Scalars['String']>,
  /** Documentation that describes how the structure is used in the mapping. */
  documentation?: Maybe<Scalars['String']>,
};

/** A homogeneous material with a definite composition. */
export type FHIRSubstance = {
   __typename?: 'FHIRSubstance',
  /** Type of resource */
  resourceType: FHIRSubstance_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Unique identifier for the substance. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A code to indicate if the substance is actively used. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** A code that classifies the general type of substance.  This is used  for searching, sorting and display purposes. */
  category?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** A code (or set of codes) that identify this substance. */
  code: FHIRCodeableConcept,
  /** A description of the substance - its appearance, handling requirements, and other usage notes. */
  description?: Maybe<Scalars['String']>,
  /** Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance. */
  instance?: Maybe<Array<Maybe<FHIRSubstanceinstance>>>,
  /** A substance can be composed of other substances. */
  ingredient?: Maybe<Array<Maybe<FHIRSubstanceingredient>>>,
};

export enum FHIRSubstance_Enum_schema {
  Substance = 'Substance'
}

/** 
 * Base StructureDefinition for SubstanceAmount Type: Chemical substances are a
 * single substance type whose primary defining element is the molecular structure.
 * Chemical substances shall be defined on the basis of their complete covalent
 * molecular structure; the presence of a salt (counter-ion) and/or solvates
 * (water, alcohols) is also captured. Purity, grade, physical form or particle
 * size are not taken into account in the definition of a chemical substance or in
 * the assignment of a Substance ID.
 */
export type FHIRSubstanceAmount = {
   __typename?: 'FHIRSubstanceAmount',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Used to capture quantitative values for a variety of elements. If only limits
   * are given, the arithmetic mean would be the average. If only a single definite
   * value for a given element is given, it would be captured in this field.
 */
  amountQuantity?: Maybe<FHIRQuantity>,
  /** 
 * Used to capture quantitative values for a variety of elements. If only limits
   * are given, the arithmetic mean would be the average. If only a single definite
   * value for a given element is given, it would be captured in this field.
 */
  amountRange?: Maybe<FHIRRange>,
  /** 
 * Used to capture quantitative values for a variety of elements. If only limits
   * are given, the arithmetic mean would be the average. If only a single definite
   * value for a given element is given, it would be captured in this field.
 */
  amountString?: Maybe<Scalars['String']>,
  /** 
 * Most elements that require a quantitative value will also have a field called
   * amount type. Amount type should always be specified because the actual value
   * of the amount is often dependent on it. EXAMPLE: In capturing the actual
   * relative amounts of substances or molecular fragments it is essential to
   * indicate whether the amount refers to a mole ratio or weight ratio. For any
   * given element an effort should be made to use same the amount type for all
   * related definitional elements.
 */
  amountType?: Maybe<FHIRCodeableConcept>,
  /** A textual comment on a numeric value. */
  amountText?: Maybe<Scalars['String']>,
  /** Reference range of possible or expected values. */
  referenceRange?: Maybe<FHIRElement>,
};

export type FHIRSubstanceingredient = {
   __typename?: 'FHIRSubstanceingredient',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The amount of the ingredient in the substance - a concentration ratio. */
  quantity?: Maybe<FHIRRatio>,
  /** Another substance that is a component of this substance. */
  substanceCodeableConcept: FHIRCodeableConcept,
  /** Another substance that is a component of this substance. */
  substanceReference: FHIRSubstanceingredientsubstanceReference_substanceReference_Union,
};

/** Another substance that is a component of this substance. */
export type FHIRSubstanceingredientsubstanceReference_substanceReference_Union = FHIRSubstance;

export type FHIRSubstanceinstance = {
   __typename?: 'FHIRSubstanceinstance',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier associated with the package/container (usually a label affixed directly). */
  identifier?: Maybe<FHIRIdentifier>,
  /** When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry. */
  expiry?: Maybe<Scalars['FHIRDateTime']>,
  /** The amount of the substance. */
  quantity?: Maybe<FHIRQuantity>,
};

/** 
 * Nucleic acids are defined by three distinct elements: the base, sugar and
 * linkage. Individual substance/moiety IDs will be created for each of these
 * elements. The nucleotide sequence will be always entered in the 5’-3’ direction.
 */
export type FHIRSubstanceNucleicAcid = {
   __typename?: 'FHIRSubstanceNucleicAcid',
  /** Type of resource */
  resourceType: FHIRSubstanceNucleicAcid_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of the sequence shall be specified based on a controlled vocabulary. */
  sequenceType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The number of linear sequences of nucleotides linked through phosphodiester
   * bonds shall be described. Subunits would be strands of nucleic acids that are
   * tightly associated typically through Watson-Crick base pairing. NOTE: If not
   * specified in the reference source, the assumption is that there is 1 subunit.
 */
  numberOfSubunits?: Maybe<Scalars['Int']>,
  /** 
 * The area of hybridisation shall be described if applicable for double stranded
   * RNA or DNA. The number associated with the subunit followed by the number
   * associated to the residue shall be specified in increasing order. The
   * underscore “” shall be used as separator as follows: “Subunitnumber Residue”.
 */
  areaOfHybridisation?: Maybe<Scalars['String']>,
  /** (TBC). */
  oligoNucleotideType?: Maybe<FHIRCodeableConcept>,
  /** 
 * Subunits are listed in order of decreasing length; sequences of the same
   * length will be ordered by molecular weight; subunits that have identical
   * sequences will be repeated multiple times.
 */
  subunit?: Maybe<Array<Maybe<FHIRSubstanceNucleicAcidsubunit>>>,
};

export enum FHIRSubstanceNucleicAcid_Enum_schema {
  SubstanceNucleicAcid = 'SubstanceNucleicAcid'
}

export type FHIRSubstanceNucleicAcidsubunit = {
   __typename?: 'FHIRSubstanceNucleicAcidsubunit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Index of linear sequences of nucleic acids in order of decreasing length.
   * Sequences of the same length will be ordered by molecular weight. Subunits
   * that have identical sequences will be repeated and have sequential subscripts.
 */
  subunit?: Maybe<Scalars['Int']>,
  /** 
 * Actual nucleotide sequence notation from 5' to 3' end using standard single
   * letter codes. In addition to the base sequence, sugar and type of phosphate or
   * non-phosphate linkage should also be captured.
 */
  sequence?: Maybe<Scalars['String']>,
  /** The length of the sequence shall be captured. */
  length?: Maybe<Scalars['Int']>,
  /** (TBC). */
  sequenceAttachment?: Maybe<FHIRAttachment>,
  /** 
 * The nucleotide present at the 5’ terminal shall be specified based on a
   * controlled vocabulary. Since the sequence is represented from the 5' to the 3'
   * end, the 5’ prime nucleotide is the letter at the first position in the
   * sequence. A separate representation would be redundant.
 */
  fivePrime?: Maybe<FHIRCodeableConcept>,
  /** 
 * The nucleotide present at the 3’ terminal shall be specified based on a
   * controlled vocabulary. Since the sequence is represented from the 5' to the 3'
   * end, the 5’ prime nucleotide is the letter at the last position in the
   * sequence. A separate representation would be redundant.
 */
  threePrime?: Maybe<FHIRCodeableConcept>,
  /** The linkages between sugar residues will also be captured. */
  linkage?: Maybe<Array<Maybe<FHIRSubstanceNucleicAcidsubunitlinkage>>>,
  /** 5.3.6.8.1 Sugar ID (Mandatory). */
  sugar?: Maybe<Array<Maybe<FHIRSubstanceNucleicAcidsubunitsugar>>>,
};

export type FHIRSubstanceNucleicAcidsubunitlinkage = {
   __typename?: 'FHIRSubstanceNucleicAcidsubunitlinkage',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The entity that links the sugar residues together should also be captured for
   * nearly all naturally occurring nucleic acid the linkage is a phosphate group.
   * For many synthetic oligonucleotides phosphorothioate linkages are often seen.
   * Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or
   * 5’-5’ this should be specified.
 */
  connectivity?: Maybe<Scalars['String']>,
  /** Each linkage will be registered as a fragment and have an ID. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage. */
  name?: Maybe<Scalars['String']>,
  /** Residues shall be captured as described in 5.3.6.8.3. */
  residueSite?: Maybe<Scalars['String']>,
};

export type FHIRSubstanceNucleicAcidsubunitsugar = {
   __typename?: 'FHIRSubstanceNucleicAcidsubunitsugar',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The Substance ID of the sugar or sugar-like component that make up the nucleotide. */
  identifier?: Maybe<FHIRIdentifier>,
  /** The name of the sugar or sugar-like component that make up the nucleotide. */
  name?: Maybe<Scalars['String']>,
  /** 
 * The residues that contain a given sugar will be captured. The order of given
   * residues will be captured in the 5‘-3‘direction consistent with the base
   * sequences listed above.
 */
  residueSite?: Maybe<Scalars['String']>,
};

/** Todo. */
export type FHIRSubstancePolymer = {
   __typename?: 'FHIRSubstancePolymer',
  /** Type of resource */
  resourceType: FHIRSubstancePolymer_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  class?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  geometry?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  copolymerConnectivity?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Todo. */
  modification?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Todo. */
  monomerSet?: Maybe<Array<Maybe<FHIRSubstancePolymermonomerSet>>>,
  /** Todo. */
  repeat?: Maybe<Array<Maybe<FHIRSubstancePolymerrepeat>>>,
};

export enum FHIRSubstancePolymer_Enum_schema {
  SubstancePolymer = 'SubstancePolymer'
}

export type FHIRSubstancePolymermonomerSet = {
   __typename?: 'FHIRSubstancePolymermonomerSet',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  ratioType?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  startingMaterial?: Maybe<Array<Maybe<FHIRSubstancePolymermonomerSetstartingMaterial>>>,
};

export type FHIRSubstancePolymermonomerSetstartingMaterial = {
   __typename?: 'FHIRSubstancePolymermonomerSetstartingMaterial',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  material?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  isDefining?: Maybe<Scalars['Boolean']>,
  /** Todo. */
  amount?: Maybe<FHIRSubstanceAmount>,
};

export type FHIRSubstancePolymerrepeat = {
   __typename?: 'FHIRSubstancePolymerrepeat',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  numberOfUnits?: Maybe<Scalars['Int']>,
  /** Todo. */
  averageMolecularFormula?: Maybe<Scalars['String']>,
  /** Todo. */
  repeatUnitAmountType?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  repeatUnit?: Maybe<Array<Maybe<FHIRSubstancePolymerrepeatrepeatUnit>>>,
};

export type FHIRSubstancePolymerrepeatrepeatUnit = {
   __typename?: 'FHIRSubstancePolymerrepeatrepeatUnit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  orientationOfPolymerisation?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  repeatUnit?: Maybe<Scalars['String']>,
  /** Todo. */
  amount?: Maybe<FHIRSubstanceAmount>,
  /** Todo. */
  degreeOfPolymerisation?: Maybe<Array<Maybe<FHIRSubstancePolymerrepeatrepeatUnitdegreeOfPolymerisation>>>,
  /** Todo. */
  structuralRepresentation?: Maybe<Array<Maybe<FHIRSubstancePolymerrepeatrepeatUnitstructuralRepresentation>>>,
};

export type FHIRSubstancePolymerrepeatrepeatUnitdegreeOfPolymerisation = {
   __typename?: 'FHIRSubstancePolymerrepeatrepeatUnitdegreeOfPolymerisation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  degree?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  amount?: Maybe<FHIRSubstanceAmount>,
};

export type FHIRSubstancePolymerrepeatrepeatUnitstructuralRepresentation = {
   __typename?: 'FHIRSubstancePolymerrepeatrepeatUnitstructuralRepresentation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  representation?: Maybe<Scalars['String']>,
  /** Todo. */
  attachment?: Maybe<FHIRAttachment>,
};

/** 
 * A SubstanceProtein is defined as a single unit of a linear amino acid sequence,
 * or a combination of subunits that are either covalently linked or have a defined
 * invariant stoichiometric relationship. This includes all synthetic, recombinant
 * and purified SubstanceProteins of defined sequence, whether the use is
 * therapeutic or prophylactic. This set of elements will be used to describe
 * albumins, coagulation factors, cytokines, growth factors,
 * peptide/SubstanceProtein hormones, enzymes, toxins, toxoids, recombinant
 * vaccines, and immunomodulators.
 */
export type FHIRSubstanceProtein = {
   __typename?: 'FHIRSubstanceProtein',
  /** Type of resource */
  resourceType: FHIRSubstanceProtein_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The SubstanceProtein descriptive elements will only be used when a complete or
   * partial amino acid sequence is available or derivable from a nucleic acid sequence.
 */
  sequenceType?: Maybe<FHIRCodeableConcept>,
  /** 
 * Number of linear sequences of amino acids linked through peptide bonds. The
   * number of subunits constituting the SubstanceProtein shall be described. It is
   * possible that the number of subunits can be variable.
 */
  numberOfSubunits?: Maybe<Scalars['Int']>,
  /** 
 * The disulphide bond between two cysteine residues either on the same subunit
   * or on two different subunits shall be described. The position of the disulfide
   * bonds in the SubstanceProtein shall be listed in increasing order of subunit
   * number and position within subunit followed by the abbreviation of the amino
   * acids involved. The disulfide linkage positions shall actually contain the
   * amino acid Cysteine at the respective positions.
 */
  disulfideLinkage?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * This subclause refers to the description of each subunit constituting the
   * SubstanceProtein. A subunit is a linear sequence of amino acids linked through
   * peptide bonds. The Subunit information shall be provided when the finished
   * SubstanceProtein is a complex of multiple sequences; subunits are not used to
   * delineate domains within a single sequence. Subunits are listed in order of
   * decreasing length; sequences of the same length will be ordered by decreasing
   * molecular weight; subunits that have identical sequences will be repeated
   * multiple times.
 */
  subunit?: Maybe<Array<Maybe<FHIRSubstanceProteinsubunit>>>,
};

export enum FHIRSubstanceProtein_Enum_schema {
  SubstanceProtein = 'SubstanceProtein'
}

export type FHIRSubstanceProteinsubunit = {
   __typename?: 'FHIRSubstanceProteinsubunit',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Index of primary sequences of amino acids linked through peptide bonds in
   * order of decreasing length. Sequences of the same length will be ordered by
   * molecular weight. Subunits that have identical sequences will be repeated and
   * have sequential subscripts.
 */
  subunit?: Maybe<Scalars['Int']>,
  /** 
 * The sequence information shall be provided enumerating the amino acids from N-
   * to C-terminal end using standard single-letter amino acid codes. Uppercase
   * shall be used for L-amino acids and lowercase for D-amino acids. Transcribed
   * SubstanceProteins will always be described using the translated sequence; for
   * synthetic peptide containing amino acids that are not represented with a
   * single letter code an X should be used within the sequence. The modified amino
   * acids will be distinguished by their position in the sequence.
 */
  sequence?: Maybe<Scalars['String']>,
  /** Length of linear sequences of amino acids contained in the subunit. */
  length?: Maybe<Scalars['Int']>,
  /** 
 * The sequence information shall be provided enumerating the amino acids from N-
   * to C-terminal end using standard single-letter amino acid codes. Uppercase
   * shall be used for L-amino acids and lowercase for D-amino acids. Transcribed
   * SubstanceProteins will always be described using the translated sequence; for
   * synthetic peptide containing amino acids that are not represented with a
   * single letter code an X should be used within the sequence. The modified amino
   * acids will be distinguished by their position in the sequence.
 */
  sequenceAttachment?: Maybe<FHIRAttachment>,
  /** Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. */
  nTerminalModificationId?: Maybe<FHIRIdentifier>,
  /** The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified. */
  nTerminalModification?: Maybe<Scalars['String']>,
  /** Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. */
  cTerminalModificationId?: Maybe<FHIRIdentifier>,
  /** The modification at the C-terminal shall be specified. */
  cTerminalModification?: Maybe<Scalars['String']>,
};

/** Todo. */
export type FHIRSubstanceReferenceInformation = {
   __typename?: 'FHIRSubstanceReferenceInformation',
  /** Type of resource */
  resourceType: FHIRSubstanceReferenceInformation_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  comment?: Maybe<Scalars['String']>,
  /** Todo. */
  gene?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationgene>>>,
  /** Todo. */
  geneElement?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationgeneElement>>>,
  /** Todo. */
  classification?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationclassification>>>,
  /** Todo. */
  target?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationtarget>>>,
};

export enum FHIRSubstanceReferenceInformation_Enum_schema {
  SubstanceReferenceInformation = 'SubstanceReferenceInformation'
}

export type FHIRSubstanceReferenceInformationclassification = {
   __typename?: 'FHIRSubstanceReferenceInformationclassification',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  domain?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  classification?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  subtype?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Todo. */
  source?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationclassificationsource_source_Union>>>,
};

/** Todo. */
export type FHIRSubstanceReferenceInformationclassificationsource_source_Union = FHIRDocumentReference;

export type FHIRSubstanceReferenceInformationgene = {
   __typename?: 'FHIRSubstanceReferenceInformationgene',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  geneSequenceOrigin?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  gene?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  source?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationgenesource_source_Union>>>,
};

export type FHIRSubstanceReferenceInformationgeneElement = {
   __typename?: 'FHIRSubstanceReferenceInformationgeneElement',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  element?: Maybe<FHIRIdentifier>,
  /** Todo. */
  source?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationgeneElementsource_source_Union>>>,
};

/** Todo. */
export type FHIRSubstanceReferenceInformationgeneElementsource_source_Union = FHIRDocumentReference;

/** Todo. */
export type FHIRSubstanceReferenceInformationgenesource_source_Union = FHIRDocumentReference;

export type FHIRSubstanceReferenceInformationtarget = {
   __typename?: 'FHIRSubstanceReferenceInformationtarget',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Todo. */
  target?: Maybe<FHIRIdentifier>,
  /** Todo. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  interaction?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  organism?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  organismType?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  amountQuantity?: Maybe<FHIRQuantity>,
  /** Todo. */
  amountRange?: Maybe<FHIRRange>,
  /** Todo. */
  amountString?: Maybe<Scalars['String']>,
  /** Todo. */
  amountType?: Maybe<FHIRCodeableConcept>,
  /** Todo. */
  source?: Maybe<Array<Maybe<FHIRSubstanceReferenceInformationtargetsource_source_Union>>>,
};

/** Todo. */
export type FHIRSubstanceReferenceInformationtargetsource_source_Union = FHIRDocumentReference;

/** 
 * Source material shall capture information on the taxonomic and anatomical
 * origins as well as the fraction of a material that can result in or can be
 * modified to form a substance. This set of data elements shall be used to define
 * polymer substances isolated from biological matrices. Taxonomic and anatomical
 * origins shall be described using a controlled vocabulary as required. This
 * information is captured for naturally derived polymers ( . starch) and
 * structurally diverse substances. For Organisms belonging to the Kingdom Plantae
 * the Substance level defines the fresh material of a single species or
 * infraspecies, the Herbal Drug and the Herbal preparation. For Herbal
 * preparations, the fraction information will be captured at the Substance
 * information level and additional information for herbal extracts will be
 * captured at the Specified Substance Group 1 information level. See for further
 * explanation the Substance Class: Structurally Diverse and the herbal annex.
 */
export type FHIRSubstanceSourceMaterial = {
   __typename?: 'FHIRSubstanceSourceMaterial',
  /** Type of resource */
  resourceType: FHIRSubstanceSourceMaterial_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** General high level classification of the source material specific to the origin of the material. */
  sourceMaterialClass?: Maybe<FHIRCodeableConcept>,
  /** 
 * The type of the source material shall be specified based on a controlled
   * vocabulary. For vaccines, this subclause refers to the class of infectious agent.
 */
  sourceMaterialType?: Maybe<FHIRCodeableConcept>,
  /** The state of the source material when extracted. */
  sourceMaterialState?: Maybe<FHIRCodeableConcept>,
  /** The unique identifier associated with the source material parent organism shall be specified. */
  organismId?: Maybe<FHIRIdentifier>,
  /** The organism accepted Scientific name shall be provided based on the organism taxonomy. */
  organismName?: Maybe<Scalars['String']>,
  /** 
 * The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the
   * substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
 */
  parentSubstanceId?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The parent substance of the Herbal Drug, or Herbal preparation. */
  parentSubstanceName?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * The country where the plant material is harvested or the countries where the
   * plasma is sourced from as laid down in accordance with the Plasma Master File.
   * For “Plasma-derived substances” the attribute country of origin provides
   * information about the countries used for the manufacturing of the Cryopoor
   * plama or Crioprecipitate.
 */
  countryOfOrigin?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The place/region where the plant is harvested or the places/regions where the animal source material has its habitat. */
  geographicalLocation?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** 
 * Stage of life for animals, plants, insects and microorganisms. This
   * information shall be provided only when the substance is significantly
   * different in these stages (e.g. foetal bovine serum).
 */
  developmentStage?: Maybe<FHIRCodeableConcept>,
  /** 
 * Many complex materials are fractions of parts of plants, animals, or minerals.
   * Fraction elements are often necessary to define both Substances and Specified
   * Group 1 Substances. For substances derived from Plants, fraction information
   * will be captured at the Substance information level ( . Oils, Juices and
   * Exudates). Additional information for Extracts, such as extraction solvent
   * composition, will be captured at the Specified Substance Group 1 information
   * level. For plasma-derived products fraction information will be captured at
   * the Substance and the Specified Substance Group 1 levels.
 */
  fractionDescription?: Maybe<Array<Maybe<FHIRSubstanceSourceMaterialfractionDescription>>>,
  /** 
 * This subclause describes the organism which the substance is derived from. For
   * vaccines, the parent organism shall be specified based on these subclause
   * elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
 */
  organism?: Maybe<FHIRSubstanceSourceMaterialorganism>,
  /** To do. */
  partDescription?: Maybe<Array<Maybe<FHIRSubstanceSourceMaterialpartDescription>>>,
};

export enum FHIRSubstanceSourceMaterial_Enum_schema {
  SubstanceSourceMaterial = 'SubstanceSourceMaterial'
}

export type FHIRSubstanceSourceMaterialfractionDescription = {
   __typename?: 'FHIRSubstanceSourceMaterialfractionDescription',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** This element is capturing information about the fraction of a plant part, or human plasma for fractionation. */
  fraction?: Maybe<Scalars['String']>,
  /** 
 * The specific type of the material constituting the component. For Herbal
   * preparations the particulars of the extracts (liquid/dry) is described in
   * Specified Substance Group 1.
 */
  materialType?: Maybe<FHIRCodeableConcept>,
};

export type FHIRSubstanceSourceMaterialorganism = {
   __typename?: 'FHIRSubstanceSourceMaterialorganism',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The family of an organism shall be specified. */
  family?: Maybe<FHIRCodeableConcept>,
  /** 
 * The genus of an organism shall be specified; refers to the Latin epithet of
   * the genus element of the plant/animal scientific name; it is present in names
   * for genera, species and infraspecies.
 */
  genus?: Maybe<FHIRCodeableConcept>,
  /** 
 * The species of an organism shall be specified; refers to the Latin epithet of
   * the species of the plant/animal; it is present in names for species and infraspecies.
 */
  species?: Maybe<FHIRCodeableConcept>,
  /** The Intraspecific type of an organism shall be specified. */
  intraspecificType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The intraspecific description of an organism shall be specified based on a
   * controlled vocabulary. For Influenza Vaccine, the intraspecific description
   * shall contain the syntax of the antigen in line with the WHO convention.
 */
  intraspecificDescription?: Maybe<Scalars['String']>,
  /** 4.9.13.6.1 Author type (Conditional). */
  author?: Maybe<Array<Maybe<FHIRSubstanceSourceMaterialorganismauthor>>>,
  /** 4.9.13.8.1 Hybrid species maternal organism ID (Optional). */
  hybrid?: Maybe<FHIRSubstanceSourceMaterialorganismhybrid>,
  /** 4.9.13.7.1 Kingdom (Conditional). */
  organismGeneral?: Maybe<FHIRSubstanceSourceMaterialorganismorganismGeneral>,
};

export type FHIRSubstanceSourceMaterialorganismauthor = {
   __typename?: 'FHIRSubstanceSourceMaterialorganismauthor',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The type of author of an organism species shall be specified. The
   * parenthetical author of an organism species refers to the first author who
   * published the plant/animal name (of any rank). The primary author of an
   * organism species refers to the first author(s), who validly published the
   * plant/animal name.
 */
  authorType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The author of an organism species shall be specified. The author year of an
   * organism shall also be specified when applicable; refers to the year in which
   * the first author(s) published the infraspecific plant/animal name (of any rank).
 */
  authorDescription?: Maybe<Scalars['String']>,
};

export type FHIRSubstanceSourceMaterialorganismhybrid = {
   __typename?: 'FHIRSubstanceSourceMaterialorganismhybrid',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The identifier of the maternal species constituting the hybrid organism shall
   * be specified based on a controlled vocabulary. For plants, the parents aren’t
   * always known, and it is unlikely that it will be known which is maternal and
   * which is paternal.
 */
  maternalOrganismId?: Maybe<Scalars['String']>,
  /** 
 * The name of the maternal species constituting the hybrid organism shall be
   * specified. For plants, the parents aren’t always known, and it is unlikely
   * that it will be known which is maternal and which is paternal.
 */
  maternalOrganismName?: Maybe<Scalars['String']>,
  /** 
 * The identifier of the paternal species constituting the hybrid organism shall
   * be specified based on a controlled vocabulary.
 */
  paternalOrganismId?: Maybe<Scalars['String']>,
  /** The name of the paternal species constituting the hybrid organism shall be specified. */
  paternalOrganismName?: Maybe<Scalars['String']>,
  /** The hybrid type of an organism shall be specified. */
  hybridType?: Maybe<FHIRCodeableConcept>,
};

export type FHIRSubstanceSourceMaterialorganismorganismGeneral = {
   __typename?: 'FHIRSubstanceSourceMaterialorganismorganismGeneral',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The kingdom of an organism shall be specified. */
  kingdom?: Maybe<FHIRCodeableConcept>,
  /** The phylum of an organism shall be specified. */
  phylum?: Maybe<FHIRCodeableConcept>,
  /** The class of an organism shall be specified. */
  class?: Maybe<FHIRCodeableConcept>,
  /** The order of an organism shall be specified,. */
  order?: Maybe<FHIRCodeableConcept>,
};

export type FHIRSubstanceSourceMaterialpartDescription = {
   __typename?: 'FHIRSubstanceSourceMaterialpartDescription',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Entity of anatomical origin of source material within an organism. */
  part?: Maybe<FHIRCodeableConcept>,
  /** 
 * The detailed anatomic location when the part can be extracted from different
   * anatomical locations of the organism. Multiple alternative locations may apply.
 */
  partLocation?: Maybe<FHIRCodeableConcept>,
};

/** The detailed description of a substance, typically at a level beyond what is used for prescribing. */
export type FHIRSubstanceSpecification = {
   __typename?: 'FHIRSubstanceSpecification',
  /** Type of resource */
  resourceType: FHIRSubstanceSpecification_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier by which this substance is known. */
  identifier?: Maybe<FHIRIdentifier>,
  /** High level categorization, e.g. polymer or nucleic acid. */
  type?: Maybe<FHIRCodeableConcept>,
  /** Status of substance within the catalogue e.g. approved. */
  status?: Maybe<FHIRCodeableConcept>,
  /** If the substance applies to only human or veterinary use. */
  domain?: Maybe<FHIRCodeableConcept>,
  /** Textual description of the substance. */
  description?: Maybe<Scalars['String']>,
  /** Supporting literature. */
  source?: Maybe<Array<Maybe<FHIRSubstanceSpecificationsource_source_Union>>>,
  /** Textual comment about this record of a substance. */
  comment?: Maybe<Scalars['String']>,
  /** Moiety, for structural modifications. */
  moiety?: Maybe<Array<Maybe<FHIRSubstanceSpecificationmoiety>>>,
  /** General specifications for this substance, including how it is related to other substances. */
  property?: Maybe<Array<Maybe<FHIRSubstanceSpecificationproperty>>>,
  /** General information detailing this substance. */
  referenceInformation?: Maybe<FHIRSubstanceSpecificationreferenceInformation_referenceInformation_Union>,
  /** Structural information. */
  structure?: Maybe<FHIRSubstanceSpecificationstructure>,
  /** Codes associated with the substance. */
  code?: Maybe<Array<Maybe<FHIRSubstanceSpecificationcode>>>,
  /** Names applicable to this substance. */
  name?: Maybe<Array<Maybe<FHIRSubstanceSpecificationname>>>,
  /** A link between this substance and another, with details of the relationship. */
  relationship?: Maybe<Array<Maybe<FHIRSubstanceSpecificationrelationship>>>,
  /** Data items specific to nucleic acids. */
  nucleicAcid?: Maybe<FHIRSubstanceSpecificationnucleicAcid_nucleicAcid_Union>,
  /** Data items specific to polymers. */
  polymer?: Maybe<FHIRSubstanceSpecificationpolymer_polymer_Union>,
  /** Data items specific to proteins. */
  protein?: Maybe<FHIRSubstanceSpecificationprotein_protein_Union>,
  /** Material or taxonomic/anatomical source for the substance. */
  sourceMaterial?: Maybe<FHIRSubstanceSpecificationsourceMaterial_sourceMaterial_Union>,
};

export enum FHIRSubstanceSpecification_Enum_schema {
  SubstanceSpecification = 'SubstanceSpecification'
}

export type FHIRSubstanceSpecificationcode = {
   __typename?: 'FHIRSubstanceSpecificationcode',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The specific code. */
  code?: Maybe<FHIRCodeableConcept>,
  /** Status of the code assignment. */
  status?: Maybe<FHIRCodeableConcept>,
  /** The date at which the code status is changed as part of the terminology maintenance. */
  statusDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Any comment can be provided in this field, if necessary. */
  comment?: Maybe<Scalars['String']>,
  /** Supporting literature. */
  source?: Maybe<Array<Maybe<FHIRSubstanceSpecificationcodesource_source_Union>>>,
};

/** Supporting literature. */
export type FHIRSubstanceSpecificationcodesource_source_Union = FHIRDocumentReference;

export type FHIRSubstanceSpecificationmoiety = {
   __typename?: 'FHIRSubstanceSpecificationmoiety',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Role that the moiety is playing. */
  role?: Maybe<FHIRCodeableConcept>,
  /** Identifier by which this moiety substance is known. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Textual name for this moiety substance. */
  name?: Maybe<Scalars['String']>,
  /** Stereochemistry type. */
  stereochemistry?: Maybe<FHIRCodeableConcept>,
  /** Optical activity type. */
  opticalActivity?: Maybe<FHIRCodeableConcept>,
  /** Molecular formula. */
  molecularFormula?: Maybe<Scalars['String']>,
  /** Quantitative value for this moiety. */
  amountQuantity?: Maybe<FHIRQuantity>,
  /** Quantitative value for this moiety. */
  amountString?: Maybe<Scalars['String']>,
};

export type FHIRSubstanceSpecificationname = {
   __typename?: 'FHIRSubstanceSpecificationname',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The actual name. */
  name: Scalars['String'],
  /** Name type. */
  type?: Maybe<FHIRCodeableConcept>,
  /** The status of the name. */
  status?: Maybe<FHIRCodeableConcept>,
  /** If this is the preferred name for this substance. */
  preferred?: Maybe<Scalars['Boolean']>,
  /** Language of the name. */
  language?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * The use context of this name for example if there is a different name a drug
   * active ingredient as opposed to a food colour additive.
 */
  domain?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The jurisdiction where this name applies. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Details of the official nature of this name. */
  official?: Maybe<Array<Maybe<FHIRSubstanceSpecificationnameofficial>>>,
  /** Supporting literature. */
  source?: Maybe<Array<Maybe<FHIRSubstanceSpecificationnamesource_source_Union>>>,
};

export type FHIRSubstanceSpecificationnameofficial = {
   __typename?: 'FHIRSubstanceSpecificationnameofficial',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Which authority uses this official name. */
  authority?: Maybe<FHIRCodeableConcept>,
  /** The status of the official name. */
  status?: Maybe<FHIRCodeableConcept>,
  /** Date of official name change. */
  date?: Maybe<Scalars['FHIRDateTime']>,
};

/** Supporting literature. */
export type FHIRSubstanceSpecificationnamesource_source_Union = FHIRDocumentReference;

/** Data items specific to nucleic acids. */
export type FHIRSubstanceSpecificationnucleicAcid_nucleicAcid_Union = FHIRSubstanceNucleicAcid;

/** Data items specific to polymers. */
export type FHIRSubstanceSpecificationpolymer_polymer_Union = FHIRSubstancePolymer;

export type FHIRSubstanceSpecificationproperty = {
   __typename?: 'FHIRSubstanceSpecificationproperty',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A category for this property, e.g. Physical, Chemical, Enzymatic. */
  category?: Maybe<FHIRCodeableConcept>,
  /** Property type e.g. viscosity, pH, isoelectric point. */
  code?: Maybe<FHIRCodeableConcept>,
  /** Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1). */
  parameters?: Maybe<Scalars['String']>,
  /** A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol). */
  definingSubstanceReference?: Maybe<FHIRSubstanceSpecificationpropertydefiningSubstanceReference_definingSubstanceReference_Union>,
  /** A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol). */
  definingSubstanceCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** Quantitative value for this property. */
  amountQuantity?: Maybe<FHIRQuantity>,
  /** Quantitative value for this property. */
  amountString?: Maybe<Scalars['String']>,
};

/** A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol). */
export type FHIRSubstanceSpecificationpropertydefiningSubstanceReference_definingSubstanceReference_Union = FHIRSubstanceSpecification | FHIRSubstance;

/** Data items specific to proteins. */
export type FHIRSubstanceSpecificationprotein_protein_Union = FHIRSubstanceProtein;

/** General information detailing this substance. */
export type FHIRSubstanceSpecificationreferenceInformation_referenceInformation_Union = FHIRSubstanceReferenceInformation;

export type FHIRSubstanceSpecificationrelationship = {
   __typename?: 'FHIRSubstanceSpecificationrelationship',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A pointer to another substance, as a resource or just a representational code. */
  substanceReference?: Maybe<FHIRSubstanceSpecificationrelationshipsubstanceReference_substanceReference_Union>,
  /** A pointer to another substance, as a resource or just a representational code. */
  substanceCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** For example 'salt to parent', 'active moiety', 'starting material'. */
  relationship?: Maybe<FHIRCodeableConcept>,
  /** 
 * For example where an enzyme strongly bonds with a particular substance, this
   * is a defining relationship for that enzyme, out of several possible substance relationships.
 */
  isDefining?: Maybe<Scalars['Boolean']>,
  /** 
 * A numeric factor for the relationship, for instance to express that the salt
   * of a substance has some percentage of the active substance in relation to some other.
 */
  amountQuantity?: Maybe<FHIRQuantity>,
  /** 
 * A numeric factor for the relationship, for instance to express that the salt
   * of a substance has some percentage of the active substance in relation to some other.
 */
  amountRange?: Maybe<FHIRRange>,
  /** 
 * A numeric factor for the relationship, for instance to express that the salt
   * of a substance has some percentage of the active substance in relation to some other.
 */
  amountRatio?: Maybe<FHIRRatio>,
  /** 
 * A numeric factor for the relationship, for instance to express that the salt
   * of a substance has some percentage of the active substance in relation to some other.
 */
  amountString?: Maybe<Scalars['String']>,
  /** For use when the numeric. */
  amountRatioLowLimit?: Maybe<FHIRRatio>,
  /** An operator for the amount, for example 'average', 'approximately', 'less than'. */
  amountType?: Maybe<FHIRCodeableConcept>,
  /** Supporting literature. */
  source?: Maybe<Array<Maybe<FHIRSubstanceSpecificationrelationshipsource_source_Union>>>,
};

/** Supporting literature. */
export type FHIRSubstanceSpecificationrelationshipsource_source_Union = FHIRDocumentReference;

/** A pointer to another substance, as a resource or just a representational code. */
export type FHIRSubstanceSpecificationrelationshipsubstanceReference_substanceReference_Union = FHIRSubstanceSpecification;

/** Supporting literature. */
export type FHIRSubstanceSpecificationsource_source_Union = FHIRDocumentReference;

/** Material or taxonomic/anatomical source for the substance. */
export type FHIRSubstanceSpecificationsourceMaterial_sourceMaterial_Union = FHIRSubstanceSourceMaterial;

export type FHIRSubstanceSpecificationstructure = {
   __typename?: 'FHIRSubstanceSpecificationstructure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Stereochemistry type. */
  stereochemistry?: Maybe<FHIRCodeableConcept>,
  /** Optical activity type. */
  opticalActivity?: Maybe<FHIRCodeableConcept>,
  /** Molecular formula. */
  molecularFormula?: Maybe<Scalars['String']>,
  /** 
 * Specified per moiety according to the Hill system, i.e. first C, then H, then
   * alphabetical, each moiety separated by a dot.
 */
  molecularFormulaByMoiety?: Maybe<Scalars['String']>,
  /** Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio. */
  isotope?: Maybe<Array<Maybe<FHIRSubstanceSpecificationstructureisotope>>>,
  /** Supporting literature. */
  source?: Maybe<Array<Maybe<FHIRSubstanceSpecificationstructuresource_source_Union>>>,
  /** Molecular structural representation. */
  representation?: Maybe<Array<Maybe<FHIRSubstanceSpecificationstructurerepresentation>>>,
};

export type FHIRSubstanceSpecificationstructureisotope = {
   __typename?: 'FHIRSubstanceSpecificationstructureisotope',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Substance identifier for each non-natural or radioisotope. */
  identifier?: Maybe<FHIRIdentifier>,
  /** Substance name for each non-natural or radioisotope. */
  name?: Maybe<FHIRCodeableConcept>,
  /** The type of isotopic substitution present in a single substance. */
  substitution?: Maybe<FHIRCodeableConcept>,
  /** Half life - for a non-natural nuclide. */
  halfLife?: Maybe<FHIRQuantity>,
  /** The molecular weight or weight range (for proteins, polymers or nucleic acids). */
  molecularWeight?: Maybe<FHIRSubstanceSpecificationstructureisotopemolecularWeight>,
};

export type FHIRSubstanceSpecificationstructureisotopemolecularWeight = {
   __typename?: 'FHIRSubstanceSpecificationstructureisotopemolecularWeight',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The method by which the molecular weight was determined. */
  method?: Maybe<FHIRCodeableConcept>,
  /** Type of molecular weight such as exact, average (also known as. number average), weight average. */
  type?: Maybe<FHIRCodeableConcept>,
  /** 
 * Used to capture quantitative values for a variety of elements. If only limits
   * are given, the arithmetic mean would be the average. If only a single definite
   * value for a given element is given, it would be captured in this field.
 */
  amount?: Maybe<FHIRQuantity>,
};

export type FHIRSubstanceSpecificationstructurerepresentation = {
   __typename?: 'FHIRSubstanceSpecificationstructurerepresentation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of structure (e.g. Full, Partial, Representative). */
  type?: Maybe<FHIRCodeableConcept>,
  /** The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX. */
  representation?: Maybe<Scalars['String']>,
  /** An attached file with the structural representation. */
  attachment?: Maybe<FHIRAttachment>,
};

/** Supporting literature. */
export type FHIRSubstanceSpecificationstructuresource_source_Union = FHIRDocumentReference;

/** Record of delivery of what is supplied. */
export type FHIRSupplyDelivery = {
   __typename?: 'FHIRSupplyDelivery',
  /** Type of resource */
  resourceType: FHIRSupplyDelivery_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the supply delivery event that is used to identify it across multiple disparate systems. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** A plan, proposal or order that is fulfilled in whole or in part by this event. */
  basedOn?: Maybe<Array<Maybe<FHIRSupplyDeliverybasedOn_basedOn_Union>>>,
  /** A larger event of which this particular event is a component or step. */
  partOf?: Maybe<Array<Maybe<FHIRSupplyDeliverypartOf_partOf_Union>>>,
  /** A code specifying the state of the dispense event. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** A link to a resource representing the person whom the delivered item is for. */
  patient?: Maybe<FHIRSupplyDeliverypatient_patient_Union>,
  /** 
 * Indicates the type of dispensing event that is performed. Examples include:
   * Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
 */
  type?: Maybe<FHIRCodeableConcept>,
  /** The item that is being delivered or has been supplied. */
  suppliedItem?: Maybe<FHIRSupplyDeliverysuppliedItem>,
  /** The date or time(s) the activity occurred. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** The date or time(s) the activity occurred. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** The date or time(s) the activity occurred. */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** The individual responsible for dispensing the medication, supplier or device. */
  supplier?: Maybe<FHIRSupplyDeliverysupplier_supplier_Union>,
  /** Identification of the facility/location where the Supply was shipped to, as part of the dispense event. */
  destination?: Maybe<FHIRSupplyDeliverydestination_destination_Union>,
  /** Identifies the person who picked up the Supply. */
  receiver?: Maybe<Array<Maybe<FHIRSupplyDeliveryreceiver_receiver_Union>>>,
};

export enum FHIRSupplyDelivery_Enum_schema {
  SupplyDelivery = 'SupplyDelivery'
}

/** A plan, proposal or order that is fulfilled in whole or in part by this event. */
export type FHIRSupplyDeliverybasedOn_basedOn_Union = FHIRSupplyRequest;

/** Identification of the facility/location where the Supply was shipped to, as part of the dispense event. */
export type FHIRSupplyDeliverydestination_destination_Union = FHIRLocation;

/** A larger event of which this particular event is a component or step. */
export type FHIRSupplyDeliverypartOf_partOf_Union = FHIRSupplyDelivery | FHIRContract;

/** A link to a resource representing the person whom the delivered item is for. */
export type FHIRSupplyDeliverypatient_patient_Union = FHIRPatient;

/** Identifies the person who picked up the Supply. */
export type FHIRSupplyDeliveryreceiver_receiver_Union = FHIRPractitioner | FHIRPractitionerRole;

export type FHIRSupplyDeliverysuppliedItem = {
   __typename?: 'FHIRSupplyDeliverysuppliedItem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The amount of supply that has been dispensed. Includes unit of measure. */
  quantity?: Maybe<FHIRQuantity>,
  /** 
 * Identifies the medication, substance or device being dispensed. This is either
   * a link to a resource representing the details of the item or a code that
   * identifies the item from a known list.
 */
  itemCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** 
 * Identifies the medication, substance or device being dispensed. This is either
   * a link to a resource representing the details of the item or a code that
   * identifies the item from a known list.
 */
  itemReference?: Maybe<FHIRSupplyDeliverysuppliedItemitemReference_itemReference_Union>,
};

/** 
 * Identifies the medication, substance or device being dispensed. This is either a
 * link to a resource representing the details of the item or a code that
 * identifies the item from a known list.
 */
export type FHIRSupplyDeliverysuppliedItemitemReference_itemReference_Union = FHIRMedication | FHIRSubstance | FHIRDevice;

/** The individual responsible for dispensing the medication, supplier or device. */
export type FHIRSupplyDeliverysupplier_supplier_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

/** A record of a request for a medication, substance or device used in the healthcare setting. */
export type FHIRSupplyRequest = {
   __typename?: 'FHIRSupplyRequest',
  /** Type of resource */
  resourceType: FHIRSupplyRequest_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Business identifiers assigned to this SupplyRequest by the author and/or other
   * systems. These identifiers remain constant as the resource is updated and
   * propagates from server to server.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** Status of the supply request. */
  status?: Maybe<Scalars['FHIRCode']>,
  /** Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process. */
  category?: Maybe<FHIRCodeableConcept>,
  /** Indicates how quickly this SupplyRequest should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The item that is requested to be supplied. This is either a link to a resource
   * representing the details of the item or a code that identifies the item from a known list.
 */
  itemCodeableConcept: FHIRCodeableConcept,
  /** 
 * The item that is requested to be supplied. This is either a link to a resource
   * representing the details of the item or a code that identifies the item from a known list.
 */
  itemReference: FHIRSupplyRequestitemReference_itemReference_Union,
  /** The amount that is being ordered of the indicated item. */
  quantity: FHIRQuantity,
  /** Specific parameters for the ordered item.  For example, the size of the indicated item. */
  parameter?: Maybe<Array<Maybe<FHIRSupplyRequestparameter>>>,
  /** When the request should be fulfilled. */
  occurrenceDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** When the request should be fulfilled. */
  occurrencePeriod?: Maybe<FHIRPeriod>,
  /** When the request should be fulfilled. */
  occurrenceTiming?: Maybe<FHIRTiming>,
  /** When the request was made. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The device, practitioner, etc. who initiated the request. */
  requester?: Maybe<FHIRSupplyRequestrequester_requester_Union>,
  /** Who is intended to fulfill the request. */
  supplier?: Maybe<Array<Maybe<FHIRSupplyRequestsupplier_supplier_Union>>>,
  /** The reason why the supply item was requested. */
  reasonCode?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** The reason why the supply item was requested. */
  reasonReference?: Maybe<Array<Maybe<FHIRSupplyRequestreasonReference_reasonReference_Union>>>,
  /** Where the supply is expected to come from. */
  deliverFrom?: Maybe<FHIRSupplyRequestdeliverFrom_deliverFrom_Union>,
  /** Where the supply is destined to go. */
  deliverTo?: Maybe<FHIRSupplyRequestdeliverTo_deliverTo_Union>,
};

export enum FHIRSupplyRequest_Enum_schema {
  SupplyRequest = 'SupplyRequest'
}

/** Where the supply is expected to come from. */
export type FHIRSupplyRequestdeliverFrom_deliverFrom_Union = FHIROrganization | FHIRLocation;

/** Where the supply is destined to go. */
export type FHIRSupplyRequestdeliverTo_deliverTo_Union = FHIROrganization | FHIRLocation | FHIRPatient;

/** 
 * The item that is requested to be supplied. This is either a link to a resource
 * representing the details of the item or a code that identifies the item from a known list.
 */
export type FHIRSupplyRequestitemReference_itemReference_Union = FHIRMedication | FHIRSubstance | FHIRDevice;

export type FHIRSupplyRequestparameter = {
   __typename?: 'FHIRSupplyRequestparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code or string that identifies the device detail being asserted. */
  code?: Maybe<FHIRCodeableConcept>,
  /** The value of the device detail. */
  valueCodeableConcept?: Maybe<FHIRCodeableConcept>,
  /** The value of the device detail. */
  valueQuantity?: Maybe<FHIRQuantity>,
  /** The value of the device detail. */
  valueRange?: Maybe<FHIRRange>,
  /** The value of the device detail. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
};

/** The reason why the supply item was requested. */
export type FHIRSupplyRequestreasonReference_reasonReference_Union = FHIRCondition | FHIRObservation | FHIRDiagnosticReport | FHIRDocumentReference;

/** The device, practitioner, etc. who initiated the request. */
export type FHIRSupplyRequestrequester_requester_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRPatient | FHIRRelatedPerson | FHIRDevice;

/** Who is intended to fulfill the request. */
export type FHIRSupplyRequestsupplier_supplier_Union = FHIROrganization | FHIRHealthcareService;

/** A task to be performed. */
export type FHIRTask = {
   __typename?: 'FHIRTask',
  /** Type of resource */
  resourceType: FHIRTask_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The business identifier for this task. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other
   * definition that is adhered to in whole or in part by this Task.
 */
  instantiatesCanonical?: Maybe<Scalars['FHIRCanonical']>,
  /** 
 * The URL pointing to an *externally* maintained  protocol, guideline, orderset
   * or other definition that is adhered to in whole or in part by this Task.
 */
  instantiatesUri?: Maybe<Scalars['FHIRUri']>,
  /** 
 * BasedOn refers to a higher-level authorization that triggered the creation of
   * the task.  It references a 'request' resource such as a ServiceRequest,
   * MedicationRequest, ServiceRequest, CarePlan, etc. which is distinct from the
   * 'request' resource the task is seeking to fulfill.  This latter resource is
   * referenced by FocusOn.  For example, based on a ServiceRequest (= BasedOn), a
   * task is created to fulfill a procedureRequest ( = FocusOn ) to collect a
   * specimen from a patient.
 */
  basedOn?: Maybe<Array<Maybe<FHIRTaskbasedOn_basedOn_Union>>>,
  /** An identifier that links together multiple tasks and other requests that were created in the same context. */
  groupIdentifier?: Maybe<FHIRIdentifier>,
  /** Task that this particular task is part of. */
  partOf?: Maybe<Array<Maybe<FHIRTaskpartOf_partOf_Union>>>,
  /** The current status of the task. */
  status: Scalars['FHIRCode'],
  /** An explanation as to why this task is held, failed, was refused, etc. */
  statusReason?: Maybe<FHIRCodeableConcept>,
  /** Contains business-specific nuances of the business state. */
  businessStatus?: Maybe<FHIRCodeableConcept>,
  /** 
 * Indicates the 'level' of actionability associated with the Task, i.e. i+R[9]Cs
   * this a proposed task, a planned task, an actionable task, etc.
 */
  intent: Scalars['FHIRCode'],
  /** Indicates how quickly the Task should be addressed with respect to other requests. */
  priority?: Maybe<Scalars['FHIRCode']>,
  /** A name or code (or both) briefly describing what the task involves. */
  code?: Maybe<FHIRCodeableConcept>,
  /** A free-text description of what is to be performed. */
  description?: Maybe<Scalars['String']>,
  /** The request being actioned or the resource being manipulated by this task. */
  focus?: Maybe<FHIRTaskfocus_focus_Union>,
  /** The entity who benefits from the performance of the service specified in the task (e.g., the patient). */
  for?: Maybe<FHIRTaskfor_for_Union>,
  /** The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. */
  encounter?: Maybe<FHIRTaskencounter_encounter_Union>,
  /** 
 * Identifies the time action was first taken against the task (start) and/or the
   * time final action was taken against the task prior to marking it as completed (end).
 */
  executionPeriod?: Maybe<FHIRPeriod>,
  /** The date and time this task was created. */
  authoredOn?: Maybe<Scalars['FHIRDateTime']>,
  /** The date and time of last modification to this task. */
  lastModified?: Maybe<Scalars['FHIRDateTime']>,
  /** The creator of the task. */
  requester?: Maybe<FHIRTaskrequester_requester_Union>,
  /** The kind of participant that should perform the task. */
  performerType?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Individual organization or Device currently responsible for task execution. */
  owner?: Maybe<FHIRTaskowner_owner_Union>,
  /** Principal physical location where the this task is performed. */
  location?: Maybe<FHIRTasklocation_location_Union>,
  /** A description or code indicating why this task needs to be performed. */
  reasonCode?: Maybe<FHIRCodeableConcept>,
  /** A resource reference indicating why this task needs to be performed. */
  reasonReference?: Maybe<FHIRTaskreasonReference_reasonReference_Union>,
  /** Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task. */
  insurance?: Maybe<Array<Maybe<FHIRTaskinsurance_insurance_Union>>>,
  /** Free-text information captured about the task as it progresses. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
  /** 
 * Links to Provenance records for past versions of this Task that identify key
   * state transitions or updates that are likely to be relevant to a user looking
   * at the current version of the task.
 */
  relevantHistory?: Maybe<Array<Maybe<FHIRTaskrelevantHistory_relevantHistory_Union>>>,
  /** 
 * If the Task.focus is a request resource and the task is seeking fulfillment
   * (i.e. is asking for the request to be actioned), this element identifies any
   * limitations on what parts of the referenced request should be actioned.
 */
  restriction?: Maybe<FHIRTaskrestriction>,
  /** Additional information that may be needed in the execution of the task. */
  input?: Maybe<Array<Maybe<FHIRTaskinput>>>,
  /** Outputs produced by the Task. */
  output?: Maybe<Array<Maybe<FHIRTaskoutput>>>,
};

export enum FHIRTask_Enum_schema {
  Task = 'Task'
}

/** 
 * BasedOn refers to a higher-level authorization that triggered the creation of
 * the task.  It references a 'request' resource such as a ServiceRequest,
 * MedicationRequest, ServiceRequest, CarePlan, etc. which is distinct from the
 * 'request' resource the task is seeking to fulfill.  This latter resource is
 * referenced by FocusOn.  For example, based on a ServiceRequest (= BasedOn), a
 * task is created to fulfill a procedureRequest ( = FocusOn ) to collect a
 * specimen from a patient.
 */
export type FHIRTaskbasedOn_basedOn_Union = FHIRResource;

/** The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. */
export type FHIRTaskencounter_encounter_Union = FHIREncounter;

/** The request being actioned or the resource being manipulated by this task. */
export type FHIRTaskfocus_focus_Union = FHIRResource;

/** The entity who benefits from the performance of the service specified in the task (e.g., the patient). */
export type FHIRTaskfor_for_Union = FHIRResource;

export type FHIRTaskinput = {
   __typename?: 'FHIRTaskinput',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code or description indicating how the input is intended to be used as part of the task execution. */
  type: FHIRCodeableConcept,
  /** The value of the input parameter as a basic type. */
  valueBase64Binary: Scalars['FHIRBase64Binary'],
  /** The value of the input parameter as a basic type. */
  valueBoolean: Scalars['Boolean'],
  /** The value of the input parameter as a basic type. */
  valueCanonical: Scalars['FHIRCanonical'],
  /** The value of the input parameter as a basic type. */
  valueCode: Scalars['FHIRCode'],
  /** The value of the input parameter as a basic type. */
  valueDate: Scalars['FHIRDate'],
  /** The value of the input parameter as a basic type. */
  valueDateTime: Scalars['FHIRDateTime'],
  /** The value of the input parameter as a basic type. */
  valueDecimal: Scalars['Float'],
  /** The value of the input parameter as a basic type. */
  valueId: Scalars['FHIRId'],
  /** The value of the input parameter as a basic type. */
  valueInstant: Scalars['FHIRInstant'],
  /** The value of the input parameter as a basic type. */
  valueInteger: Scalars['Int'],
  /** The value of the input parameter as a basic type. */
  valueMarkdown: Scalars['String'],
  /** The value of the input parameter as a basic type. */
  valueOid: Scalars['FHIROid'],
  /** The value of the input parameter as a basic type. */
  valuePositiveInt: Scalars['FHIRPositiveInt'],
  /** The value of the input parameter as a basic type. */
  valueString: Scalars['String'],
  /** The value of the input parameter as a basic type. */
  valueTime: Scalars['FHIRTime'],
  /** The value of the input parameter as a basic type. */
  valueUnsignedInt: Scalars['FHIRUnsignedInt'],
  /** The value of the input parameter as a basic type. */
  valueUri: Scalars['FHIRUri'],
  /** The value of the input parameter as a basic type. */
  valueUrl: Scalars['FHIRUrl'],
  /** The value of the input parameter as a basic type. */
  valueUuid: Scalars['FHIRUuid'],
  /** The value of the input parameter as a basic type. */
  valueAddress: FHIRAddress,
  /** The value of the input parameter as a basic type. */
  valueAge: FHIRAge,
  /** The value of the input parameter as a basic type. */
  valueAnnotation: FHIRAnnotation,
  /** The value of the input parameter as a basic type. */
  valueAttachment: FHIRAttachment,
  /** The value of the input parameter as a basic type. */
  valueCodeableConcept: FHIRCodeableConcept,
  /** The value of the input parameter as a basic type. */
  valueCoding: FHIRCoding,
  /** The value of the input parameter as a basic type. */
  valueContactPoint: FHIRContactPoint,
  /** The value of the input parameter as a basic type. */
  valueCount: FHIRCount,
  /** The value of the input parameter as a basic type. */
  valueDistance: FHIRDistance,
  /** The value of the input parameter as a basic type. */
  valueDuration: FHIRDuration,
  /** The value of the input parameter as a basic type. */
  valueHumanName: FHIRHumanName,
  /** The value of the input parameter as a basic type. */
  valueIdentifier: FHIRIdentifier,
  /** The value of the input parameter as a basic type. */
  valueMoney: FHIRMoney,
  /** The value of the input parameter as a basic type. */
  valuePeriod: FHIRPeriod,
  /** The value of the input parameter as a basic type. */
  valueQuantity: FHIRQuantity,
  /** The value of the input parameter as a basic type. */
  valueRange: FHIRRange,
  /** The value of the input parameter as a basic type. */
  valueRatio: FHIRRatio,
  /** The value of the input parameter as a basic type. */
  valueReference: FHIRResourceList,
  /** The value of the input parameter as a basic type. */
  valueSampledData: FHIRSampledData,
  /** The value of the input parameter as a basic type. */
  valueSignature: FHIRSignature,
  /** The value of the input parameter as a basic type. */
  valueTiming: FHIRTiming,
  /** The value of the input parameter as a basic type. */
  valueContactDetail: FHIRContactDetail,
  /** The value of the input parameter as a basic type. */
  valueContributor: FHIRContributor,
  /** The value of the input parameter as a basic type. */
  valueDataRequirement: FHIRDataRequirement,
  /** The value of the input parameter as a basic type. */
  valueExpression: FHIRExpression,
  /** The value of the input parameter as a basic type. */
  valueParameterDefinition: FHIRParameterDefinition,
  /** The value of the input parameter as a basic type. */
  valueRelatedArtifact: FHIRRelatedArtifact,
  /** The value of the input parameter as a basic type. */
  valueTriggerDefinition: FHIRTriggerDefinition,
  /** The value of the input parameter as a basic type. */
  valueUsageContext: FHIRUsageContext,
  /** The value of the input parameter as a basic type. */
  valueDosage: FHIRDosage,
};

/** Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task. */
export type FHIRTaskinsurance_insurance_Union = FHIRCoverage | FHIRClaimResponse;

/** Principal physical location where the this task is performed. */
export type FHIRTasklocation_location_Union = FHIRLocation;

export type FHIRTaskoutput = {
   __typename?: 'FHIRTaskoutput',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of the Output parameter. */
  type: FHIRCodeableConcept,
  /** The value of the Output parameter as a basic type. */
  valueBase64Binary: Scalars['FHIRBase64Binary'],
  /** The value of the Output parameter as a basic type. */
  valueBoolean: Scalars['Boolean'],
  /** The value of the Output parameter as a basic type. */
  valueCanonical: Scalars['FHIRCanonical'],
  /** The value of the Output parameter as a basic type. */
  valueCode: Scalars['FHIRCode'],
  /** The value of the Output parameter as a basic type. */
  valueDate: Scalars['FHIRDate'],
  /** The value of the Output parameter as a basic type. */
  valueDateTime: Scalars['FHIRDateTime'],
  /** The value of the Output parameter as a basic type. */
  valueDecimal: Scalars['Float'],
  /** The value of the Output parameter as a basic type. */
  valueId: Scalars['FHIRId'],
  /** The value of the Output parameter as a basic type. */
  valueInstant: Scalars['FHIRInstant'],
  /** The value of the Output parameter as a basic type. */
  valueInteger: Scalars['Int'],
  /** The value of the Output parameter as a basic type. */
  valueMarkdown: Scalars['String'],
  /** The value of the Output parameter as a basic type. */
  valueOid: Scalars['FHIROid'],
  /** The value of the Output parameter as a basic type. */
  valuePositiveInt: Scalars['FHIRPositiveInt'],
  /** The value of the Output parameter as a basic type. */
  valueString: Scalars['String'],
  /** The value of the Output parameter as a basic type. */
  valueTime: Scalars['FHIRTime'],
  /** The value of the Output parameter as a basic type. */
  valueUnsignedInt: Scalars['FHIRUnsignedInt'],
  /** The value of the Output parameter as a basic type. */
  valueUri: Scalars['FHIRUri'],
  /** The value of the Output parameter as a basic type. */
  valueUrl: Scalars['FHIRUrl'],
  /** The value of the Output parameter as a basic type. */
  valueUuid: Scalars['FHIRUuid'],
  /** The value of the Output parameter as a basic type. */
  valueAddress: FHIRAddress,
  /** The value of the Output parameter as a basic type. */
  valueAge: FHIRAge,
  /** The value of the Output parameter as a basic type. */
  valueAnnotation: FHIRAnnotation,
  /** The value of the Output parameter as a basic type. */
  valueAttachment: FHIRAttachment,
  /** The value of the Output parameter as a basic type. */
  valueCodeableConcept: FHIRCodeableConcept,
  /** The value of the Output parameter as a basic type. */
  valueCoding: FHIRCoding,
  /** The value of the Output parameter as a basic type. */
  valueContactPoint: FHIRContactPoint,
  /** The value of the Output parameter as a basic type. */
  valueCount: FHIRCount,
  /** The value of the Output parameter as a basic type. */
  valueDistance: FHIRDistance,
  /** The value of the Output parameter as a basic type. */
  valueDuration: FHIRDuration,
  /** The value of the Output parameter as a basic type. */
  valueHumanName: FHIRHumanName,
  /** The value of the Output parameter as a basic type. */
  valueIdentifier: FHIRIdentifier,
  /** The value of the Output parameter as a basic type. */
  valueMoney: FHIRMoney,
  /** The value of the Output parameter as a basic type. */
  valuePeriod: FHIRPeriod,
  /** The value of the Output parameter as a basic type. */
  valueQuantity: FHIRQuantity,
  /** The value of the Output parameter as a basic type. */
  valueRange: FHIRRange,
  /** The value of the Output parameter as a basic type. */
  valueRatio: FHIRRatio,
  /** The value of the Output parameter as a basic type. */
  valueReference: FHIRResourceList,
  /** The value of the Output parameter as a basic type. */
  valueSampledData: FHIRSampledData,
  /** The value of the Output parameter as a basic type. */
  valueSignature: FHIRSignature,
  /** The value of the Output parameter as a basic type. */
  valueTiming: FHIRTiming,
  /** The value of the Output parameter as a basic type. */
  valueContactDetail: FHIRContactDetail,
  /** The value of the Output parameter as a basic type. */
  valueContributor: FHIRContributor,
  /** The value of the Output parameter as a basic type. */
  valueDataRequirement: FHIRDataRequirement,
  /** The value of the Output parameter as a basic type. */
  valueExpression: FHIRExpression,
  /** The value of the Output parameter as a basic type. */
  valueParameterDefinition: FHIRParameterDefinition,
  /** The value of the Output parameter as a basic type. */
  valueRelatedArtifact: FHIRRelatedArtifact,
  /** The value of the Output parameter as a basic type. */
  valueTriggerDefinition: FHIRTriggerDefinition,
  /** The value of the Output parameter as a basic type. */
  valueUsageContext: FHIRUsageContext,
  /** The value of the Output parameter as a basic type. */
  valueDosage: FHIRDosage,
};

/** Individual organization or Device currently responsible for task execution. */
export type FHIRTaskowner_owner_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization | FHIRCareTeam | FHIRHealthcareService | FHIRPatient | FHIRDevice | FHIRRelatedPerson;

/** Task that this particular task is part of. */
export type FHIRTaskpartOf_partOf_Union = FHIRTask;

/** A resource reference indicating why this task needs to be performed. */
export type FHIRTaskreasonReference_reasonReference_Union = FHIRResource;

/** 
 * Links to Provenance records for past versions of this Task that identify key
 * state transitions or updates that are likely to be relevant to a user looking at
 * the current version of the task.
 */
export type FHIRTaskrelevantHistory_relevantHistory_Union = FHIRProvenance;

/** The creator of the task. */
export type FHIRTaskrequester_requester_Union = FHIRDevice | FHIROrganization | FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson;

export type FHIRTaskrestriction = {
   __typename?: 'FHIRTaskrestriction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Indicates the number of times the requested action should occur. */
  repetitions?: Maybe<Scalars['FHIRPositiveInt']>,
  /** Over what time-period is fulfillment sought. */
  period?: Maybe<FHIRPeriod>,
  /** For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought? */
  recipient?: Maybe<Array<Maybe<FHIRTaskrestrictionrecipient_recipient_Union>>>,
};

/** For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought? */
export type FHIRTaskrestrictionrecipient_recipient_Union = FHIRPatient | FHIRPractitioner | FHIRPractitionerRole | FHIRRelatedPerson | FHIRGroup | FHIROrganization;

/** 
 * A TerminologyCapabilities resource documents a set of capabilities (behaviors)
 * of a FHIR Terminology Server that may be used as a statement of actual server
 * functionality or a statement of required or desired server implementation.
 */
export type FHIRTerminologyCapabilities = {
   __typename?: 'FHIRTerminologyCapabilities',
  /** Type of resource */
  resourceType: FHIRTerminologyCapabilities_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this terminology capabilities when it
   * is referenced in a specification, model, design or an instance; also called
   * its canonical identifier. This SHOULD be globally unique and SHOULD be a
   * literal address at which at which an authoritative instance of this
   * terminology capabilities is (or will be) published. This URL can be the target
   * of a canonical reference. It SHALL remain the same when the terminology
   * capabilities is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * The identifier that is used to identify this version of the terminology
   * capabilities when it is referenced in a specification, model, design or
   * instance. This is an arbitrary value managed by the terminology capabilities
   * author and is not expected to be globally unique. For example, it might be a
   * timestamp (e.g. yyyymmdd) if a managed version is not available. There is also
   * no expectation that versions can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the terminology capabilities. This name
   * should be usable as an identifier for the module by machine processing
   * applications such as code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the terminology capabilities. */
  title?: Maybe<Scalars['String']>,
  /** The status of this terminology capabilities. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this terminology capabilities is authored for
   * testing purposes (or education/evaluation/marketing) and is not intended to be
   * used for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the terminology capabilities was
   * published. The date must change when the business version changes and it must
   * change if the status code changes. In addition, it should change when the
   * substantive content of the terminology capabilities changes.
 */
  date: Scalars['FHIRDateTime'],
  /** The name of the organization or individual that published the terminology capabilities. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** 
 * A free text natural language description of the terminology capabilities from
   * a consumer's perspective. Typically, this is used when the capability
   * statement describes a desired rather than an actual solution, for example as a
   * formal expression of requirements as part of an RFP.
 */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate terminology
   * capabilities instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the terminology capabilities is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this terminology capabilities is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the terminology capabilities and/or its
   * contents. Copyright statements are generally legal restrictions on the use and
   * publishing of the terminology capabilities.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * The way that this statement is intended to be used, to describe an actual
   * running instance of software, a particular product (kind, not instance of
   * software) or a class of implementation (e.g. a desired purchase).
 */
  kind: Scalars['FHIRCode'],
  /** 
 * Software that is covered by this terminology capability statement.  It is used
   * when the statement describes the capabilities of a particular software
   * version, independent of an installation.
 */
  software?: Maybe<FHIRTerminologyCapabilitiessoftware>,
  /** 
 * Identifies a specific implementation instance that is described by the
   * terminology capability statement - i.e. a particular installation, rather than
   * the capabilities of a software program.
 */
  implementation?: Maybe<FHIRTerminologyCapabilitiesimplementation>,
  /** Whether the server supports lockedDate. */
  lockedDate?: Maybe<Scalars['Boolean']>,
  /** 
 * Identifies a code system that is supported by the server. If there is a no
   * code system URL, then this declares the general assumptions a client can make
   * about support for any CodeSystem resource.
 */
  codeSystem?: Maybe<Array<Maybe<FHIRTerminologyCapabilitiescodeSystem>>>,
  /** Information about the [ValueSet/$expand](valueset-operation-expand.html) operation. */
  expansion?: Maybe<FHIRTerminologyCapabilitiesexpansion>,
  /** The degree to which the server supports the code search parameter on ValueSet, if it is supported. */
  codeSearch?: Maybe<Scalars['FHIRCode']>,
  /** Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation. */
  validateCode?: Maybe<FHIRTerminologyCapabilitiesvalidateCode>,
  /** Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation. */
  translation?: Maybe<FHIRTerminologyCapabilitiestranslation>,
  /** Whether the $closure operation is supported. */
  closure?: Maybe<FHIRTerminologyCapabilitiesclosure>,
};

export enum FHIRTerminologyCapabilities_Enum_schema {
  TerminologyCapabilities = 'TerminologyCapabilities'
}

export type FHIRTerminologyCapabilitiesclosure = {
   __typename?: 'FHIRTerminologyCapabilitiesclosure',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** If cross-system closure is supported. */
  translation?: Maybe<Scalars['Boolean']>,
};

export type FHIRTerminologyCapabilitiescodeSystem = {
   __typename?: 'FHIRTerminologyCapabilitiescodeSystem',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** URI for the Code System. */
  uri?: Maybe<Scalars['FHIRCanonical']>,
  /** For the code system, a list of versions that are supported by the server. */
  version?: Maybe<Array<Maybe<FHIRTerminologyCapabilitiescodeSystemversion>>>,
  /** True if subsumption is supported for this version of the code system. */
  subsumption?: Maybe<Scalars['Boolean']>,
};

export type FHIRTerminologyCapabilitiescodeSystemversion = {
   __typename?: 'FHIRTerminologyCapabilitiescodeSystemversion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** For version-less code systems, there should be a single version with no identifier. */
  code?: Maybe<Scalars['String']>,
  /** If this is the default version for this code system. */
  isDefault?: Maybe<Scalars['Boolean']>,
  /** If the compositional grammar defined by the code system is supported. */
  compositional?: Maybe<Scalars['Boolean']>,
  /** Language Displays supported. */
  language?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
  /** Filter Properties supported. */
  filter?: Maybe<Array<Maybe<FHIRTerminologyCapabilitiescodeSystemversionfilter>>>,
  /** Properties supported for $lookup. */
  property?: Maybe<Array<Maybe<Scalars['FHIRCode']>>>,
};

export type FHIRTerminologyCapabilitiescodeSystemversionfilter = {
   __typename?: 'FHIRTerminologyCapabilitiescodeSystemversionfilter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Code of the property supported. */
  code: Scalars['FHIRCode'],
  /** Operations supported for the property. */
  op?: Maybe<Array<Scalars['FHIRCode']>>,
};

export type FHIRTerminologyCapabilitiesexpansion = {
   __typename?: 'FHIRTerminologyCapabilitiesexpansion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Whether the server can return nested value sets. */
  hierarchical?: Maybe<Scalars['Boolean']>,
  /** Whether the server supports paging on expansion. */
  paging?: Maybe<Scalars['Boolean']>,
  /** Allow request for incomplete expansions? */
  incomplete?: Maybe<Scalars['Boolean']>,
  /** Supported expansion parameter. */
  parameter?: Maybe<Array<Maybe<FHIRTerminologyCapabilitiesexpansionparameter>>>,
  /** Documentation about text searching works. */
  textFilter?: Maybe<Scalars['String']>,
};

export type FHIRTerminologyCapabilitiesexpansionparameter = {
   __typename?: 'FHIRTerminologyCapabilitiesexpansionparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Expansion Parameter name. */
  name: Scalars['FHIRCode'],
  /** Description of support for parameter. */
  documentation?: Maybe<Scalars['String']>,
};

export type FHIRTerminologyCapabilitiesimplementation = {
   __typename?: 'FHIRTerminologyCapabilitiesimplementation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Information about the specific installation that this terminology capability statement relates to. */
  description: Scalars['String'],
  /** An absolute base URL for the implementation. */
  url?: Maybe<Scalars['FHIRUrl']>,
};

export type FHIRTerminologyCapabilitiessoftware = {
   __typename?: 'FHIRTerminologyCapabilitiessoftware',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Name the software is known by. */
  name: Scalars['String'],
  /** The version identifier for the software covered by this statement. */
  version?: Maybe<Scalars['String']>,
};

export type FHIRTerminologyCapabilitiestranslation = {
   __typename?: 'FHIRTerminologyCapabilitiestranslation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Whether the client must identify the map. */
  needsMap: Scalars['Boolean'],
};

export type FHIRTerminologyCapabilitiesvalidateCode = {
   __typename?: 'FHIRTerminologyCapabilitiesvalidateCode',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Whether translations are validated. */
  translations: Scalars['Boolean'],
};

/** A summary of information based on the results of executing a TestScript. */
export type FHIRTestReport = {
   __typename?: 'FHIRTestReport',
  /** Type of resource */
  resourceType: FHIRTestReport_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifier for the TestScript assigned for external purposes outside the context of FHIR. */
  identifier?: Maybe<FHIRIdentifier>,
  /** A free text natural language name identifying the executed TestScript. */
  name?: Maybe<Scalars['String']>,
  /** The current state of this test report. */
  status: Scalars['FHIRCode'],
  /** 
 * Ideally this is an absolute URL that is used to identify the version-specific
   * TestScript that was executed, matching the `TestScript.url`.
 */
  testScript: FHIRTestReporttestScript_testScript_Union,
  /** The overall result from the execution of the TestScript. */
  result: Scalars['FHIRCode'],
  /** The final score (percentage of tests passed) resulting from the execution of the TestScript. */
  score?: Maybe<Scalars['Float']>,
  /** Name of the tester producing this report (Organization or individual). */
  tester?: Maybe<Scalars['String']>,
  /** When the TestScript was executed and this TestReport was generated. */
  issued?: Maybe<Scalars['FHIRDateTime']>,
  /** A participant in the test execution, either the execution engine, a client, or a server. */
  participant?: Maybe<Array<Maybe<FHIRTestReportparticipant>>>,
  /** The results of the series of required setup operations before the tests were executed. */
  setup?: Maybe<FHIRTestReportsetup>,
  /** A test executed from the test script. */
  test?: Maybe<Array<Maybe<FHIRTestReporttest>>>,
  /** 
 * The results of the series of operations required to clean up after all the
   * tests were executed (successfully or otherwise).
 */
  teardown?: Maybe<FHIRTestReportteardown>,
};

export enum FHIRTestReport_Enum_schema {
  TestReport = 'TestReport'
}

export type FHIRTestReportparticipant = {
   __typename?: 'FHIRTestReportparticipant',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of participant. */
  type: Scalars['FHIRCode'],
  /** The uri of the participant. An absolute URL is preferred. */
  uri: Scalars['FHIRUri'],
  /** The display name of the participant. */
  display?: Maybe<Scalars['String']>,
};

export type FHIRTestReportsetup = {
   __typename?: 'FHIRTestReportsetup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Action would contain either an operation or an assertion. */
  action?: Maybe<Array<FHIRTestReportsetupaction>>,
};

export type FHIRTestReportsetupaction = {
   __typename?: 'FHIRTestReportsetupaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The operation performed. */
  operation?: Maybe<FHIRTestReportsetupactionoperation>,
  /** The results of the assertion performed on the previous operations. */
  assert?: Maybe<FHIRTestReportsetupactionassert>,
};

export type FHIRTestReportsetupactionassert = {
   __typename?: 'FHIRTestReportsetupactionassert',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The result of this assertion. */
  result: Scalars['FHIRCode'],
  /** An explanatory message associated with the result. */
  message?: Maybe<Scalars['String']>,
  /** A link to further details on the result. */
  detail?: Maybe<Scalars['String']>,
};

export type FHIRTestReportsetupactionoperation = {
   __typename?: 'FHIRTestReportsetupactionoperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The result of this operation. */
  result: Scalars['FHIRCode'],
  /** An explanatory message associated with the result. */
  message?: Maybe<Scalars['String']>,
  /** A link to further details on the result. */
  detail?: Maybe<Scalars['FHIRUri']>,
};

export type FHIRTestReportteardown = {
   __typename?: 'FHIRTestReportteardown',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The teardown action will only contain an operation. */
  action?: Maybe<Array<FHIRTestReportteardownaction>>,
};

export type FHIRTestReportteardownaction = {
   __typename?: 'FHIRTestReportteardownaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

export type FHIRTestReporttest = {
   __typename?: 'FHIRTestReporttest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of this test used for tracking/logging purposes by test engines. */
  name?: Maybe<Scalars['String']>,
  /** A short description of the test used by test engines for tracking and reporting purposes. */
  description?: Maybe<Scalars['String']>,
  /** Action would contain either an operation or an assertion. */
  action?: Maybe<Array<FHIRTestReporttestaction>>,
};

export type FHIRTestReporttestaction = {
   __typename?: 'FHIRTestReporttestaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

/** 
 * Ideally this is an absolute URL that is used to identify the version-specific
 * TestScript that was executed, matching the `TestScript.url`.
 */
export type FHIRTestReporttestScript_testScript_Union = FHIRTestScript;

/** 
 * A structured set of tests against a FHIR server or client implementation to
 * determine compliance against the FHIR specification.
 */
export type FHIRTestScript = {
   __typename?: 'FHIRTestScript',
  /** Type of resource */
  resourceType: FHIRTestScript_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this test script when it is
   * referenced in a specification, model, design or an instance; also called its
   * canonical identifier. This SHOULD be globally unique and SHOULD be a literal
   * address at which at which an authoritative instance of this test script is (or
   * will be) published. This URL can be the target of a canonical reference. It
   * SHALL remain the same when the test script is stored on different servers.
 */
  url: Scalars['FHIRUri'],
  /** 
 * A formal identifier that is used to identify this test script when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<FHIRIdentifier>,
  /** 
 * The identifier that is used to identify this version of the test script when
   * it is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the test script author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the test script. This name should be
   * usable as an identifier for the module by machine processing applications such
   * as code generation.
 */
  name: Scalars['String'],
  /** A short, descriptive, user-friendly title for the test script. */
  title?: Maybe<Scalars['String']>,
  /** The status of this test script. Enables tracking the life-cycle of the content. */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this test script is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** 
 * The date  (and optionally time) when the test script was published. The date
   * must change when the business version changes and it must change if the status
   * code changes. In addition, it should change when the substantive content of
   * the test script changes.
 */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the test script. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** A free text natural language description of the test script from a consumer's perspective. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate test script instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the test script is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Explanation of why this test script is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the test script and/or its contents.
   * Copyright statements are generally legal restrictions on the use and
   * publishing of the test script.
 */
  copyright?: Maybe<Scalars['String']>,
  /** An abstract server used in operations within this test script in the origin element. */
  origin?: Maybe<Array<Maybe<FHIRTestScriptorigin>>>,
  /** An abstract server used in operations within this test script in the destination element. */
  destination?: Maybe<Array<Maybe<FHIRTestScriptdestination>>>,
  /** The required capability must exist and are assumed to function correctly on the FHIR server being tested. */
  metadata?: Maybe<FHIRTestScriptmetadata>,
  /** Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute. */
  fixture?: Maybe<Array<Maybe<FHIRTestScriptfixture>>>,
  /** Reference to the profile to be used for validation. */
  profile?: Maybe<Array<Maybe<FHIRTestScriptprofile_profile_Union>>>,
  /** Variable is set based either on element value in response body or on header field value in the response headers. */
  variable?: Maybe<Array<Maybe<FHIRTestScriptvariable>>>,
  /** A series of required setup operations before tests are executed. */
  setup?: Maybe<FHIRTestScriptsetup>,
  /** A test in this script. */
  test?: Maybe<Array<Maybe<FHIRTestScripttest>>>,
  /** A series of operations required to clean up after all the tests are executed (successfully or otherwise). */
  teardown?: Maybe<FHIRTestScriptteardown>,
};

export enum FHIRTestScript_Enum_schema {
  TestScript = 'TestScript'
}

export type FHIRTestScriptdestination = {
   __typename?: 'FHIRTestScriptdestination',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Abstract name given to a destination server in this test script.  The name is provided as a number starting at 1. */
  index: Scalars['Int'],
  /** The type of destination profile the test system supports. */
  profile: FHIRCoding,
};

export type FHIRTestScriptfixture = {
   __typename?: 'FHIRTestScriptfixture',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Whether or not to implicitly create the fixture during setup. If true, the
   * fixture is automatically created on each server being tested during setup,
   * therefore no create operation is required for this fixture in the
   * TestScript.setup section.
 */
  autocreate: Scalars['Boolean'],
  /** 
 * Whether or not to implicitly delete the fixture during teardown. If true, the
   * fixture is automatically deleted on each server being tested during teardown,
   * therefore no delete operation is required for this fixture in the
   * TestScript.teardown section.
 */
  autodelete: Scalars['Boolean'],
  /** Reference to the resource (containing the contents of the resource needed for operations). */
  resource?: Maybe<FHIRTestScriptfixtureresource_resource_Union>,
};

/** Reference to the resource (containing the contents of the resource needed for operations). */
export type FHIRTestScriptfixtureresource_resource_Union = FHIRResource;

export type FHIRTestScriptmetadata = {
   __typename?: 'FHIRTestScriptmetadata',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A link to the FHIR specification that this test is covering. */
  link?: Maybe<Array<Maybe<FHIRTestScriptmetadatalink>>>,
  /** Capabilities that must exist and are assumed to function correctly on the FHIR server being tested. */
  capability?: Maybe<Array<FHIRTestScriptmetadatacapability>>,
};

export type FHIRTestScriptmetadatacapability = {
   __typename?: 'FHIRTestScriptmetadatacapability',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Whether or not the test execution will require the given capabilities of the
   * server in order for this test script to execute.
 */
  required: Scalars['Boolean'],
  /** 
 * Whether or not the test execution will validate the given capabilities of the
   * server in order for this test script to execute.
 */
  validated: Scalars['Boolean'],
  /** Description of the capabilities that this test script is requiring the server to support. */
  description?: Maybe<Scalars['String']>,
  /** Which origin server these requirements apply to. */
  origin?: Maybe<Array<Maybe<Scalars['Int']>>>,
  /** Which server these requirements apply to. */
  destination?: Maybe<Scalars['Int']>,
  /** Links to the FHIR specification that describes this interaction and the resources involved in more detail. */
  link?: Maybe<Array<Maybe<Scalars['FHIRUri']>>>,
  /** 
 * Minimum capabilities required of server for test script to execute
   * successfully.   If server does not meet at a minimum the referenced capability
   * statement, then all tests in this script are skipped.
 */
  capabilities: Scalars['FHIRCanonical'],
};

export type FHIRTestScriptmetadatalink = {
   __typename?: 'FHIRTestScriptmetadatalink',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** URL to a particular requirement or feature within the FHIR specification. */
  url: Scalars['FHIRUri'],
  /** Short description of the link. */
  description?: Maybe<Scalars['String']>,
};

export type FHIRTestScriptorigin = {
   __typename?: 'FHIRTestScriptorigin',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Abstract name given to an origin server in this test script.  The name is provided as a number starting at 1. */
  index: Scalars['Int'],
  /** The type of origin profile the test system supports. */
  profile: FHIRCoding,
};

/** Reference to the profile to be used for validation. */
export type FHIRTestScriptprofile_profile_Union = FHIRResource;

export type FHIRTestScriptsetup = {
   __typename?: 'FHIRTestScriptsetup',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Action would contain either an operation or an assertion. */
  action?: Maybe<Array<FHIRTestScriptsetupaction>>,
};

export type FHIRTestScriptsetupaction = {
   __typename?: 'FHIRTestScriptsetupaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The operation to perform. */
  operation?: Maybe<FHIRTestScriptsetupactionoperation>,
  /** Evaluates the results of previous operations to determine if the server under test behaves appropriately. */
  assert?: Maybe<FHIRTestScriptsetupactionassert>,
};

export type FHIRTestScriptsetupactionassert = {
   __typename?: 'FHIRTestScriptsetupactionassert',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The label would be used for tracking/logging purposes by test engines. */
  label?: Maybe<Scalars['String']>,
  /** The description would be used by test engines for tracking and reporting purposes. */
  description?: Maybe<Scalars['String']>,
  /** The direction to use for the assertion. */
  direction?: Maybe<Scalars['FHIRCode']>,
  /** 
 * Id of the source fixture used as the contents to be evaluated by either the
   * 'source/expression' or 'sourceId/path' definition.
 */
  compareToSourceId?: Maybe<Scalars['String']>,
  /** 
 * The FHIRPath expression to evaluate against the source fixture. When
   * compareToSourceId is defined, either compareToSourceExpression or
   * compareToSourcePath must be defined, but not both.
 */
  compareToSourceExpression?: Maybe<Scalars['String']>,
  /** 
 * XPath or JSONPath expression to evaluate against the source fixture. When
   * compareToSourceId is defined, either compareToSourceExpression or
   * compareToSourcePath must be defined, but not both.
 */
  compareToSourcePath?: Maybe<Scalars['String']>,
  /** The mime-type contents to compare against the request or response message 'Content-Type' header. */
  contentType?: Maybe<Scalars['FHIRCode']>,
  /** The FHIRPath expression to be evaluated against the request or response message contents - HTTP headers and payload. */
  expression?: Maybe<Scalars['String']>,
  /** The HTTP header field name e.g. 'Location'. */
  headerField?: Maybe<Scalars['String']>,
  /** The ID of a fixture.  Asserts that the response contains at a minimum the fixture specified by minimumId. */
  minimumId?: Maybe<Scalars['String']>,
  /** Whether or not the test execution performs validation on the bundle navigation links. */
  navigationLinks?: Maybe<Scalars['Boolean']>,
  /** The operator type defines the conditional behavior of the assert. If not defined, the default is equals. */
  operator?: Maybe<Scalars['FHIRCode']>,
  /** The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server. */
  path?: Maybe<Scalars['String']>,
  /** The request method or HTTP operation code to compare against that used by the client system under test. */
  requestMethod?: Maybe<Scalars['FHIRCode']>,
  /** The value to use in a comparison against the request URL path string. */
  requestURL?: Maybe<Scalars['String']>,
  /** The type of the resource.  See http://build.fhir.org/resourcelist.html. */
  resource?: Maybe<Scalars['FHIRCode']>,
  /** 
 * okay | created | noContent | notModified | bad | forbidden | notFound |
   * methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
 */
  response?: Maybe<Scalars['FHIRCode']>,
  /** The value of the HTTP response code to be tested. */
  responseCode?: Maybe<Scalars['String']>,
  /** Fixture to evaluate the XPath/JSONPath expression or the headerField  against. */
  sourceId?: Maybe<Scalars['FHIRId']>,
  /** The ID of the Profile to validate against. */
  validateProfileId?: Maybe<Scalars['FHIRId']>,
  /** The value to compare to. */
  value?: Maybe<Scalars['String']>,
  /** Whether or not the test execution will produce a warning only on error for this assert. */
  warningOnly: Scalars['Boolean'],
};

export type FHIRTestScriptsetupactionoperation = {
   __typename?: 'FHIRTestScriptsetupactionoperation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Server interaction or operation type. */
  type?: Maybe<FHIRCoding>,
  /** The type of the resource.  See http://build.fhir.org/resourcelist.html. */
  resource?: Maybe<Scalars['FHIRCode']>,
  /** The label would be used for tracking/logging purposes by test engines. */
  label?: Maybe<Scalars['String']>,
  /** The description would be used by test engines for tracking and reporting purposes. */
  description?: Maybe<Scalars['String']>,
  /** The mime-type to use for RESTful operation in the 'Accept' header. */
  accept?: Maybe<Scalars['FHIRCode']>,
  /** The mime-type to use for RESTful operation in the 'Content-Type' header. */
  contentType?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The server where the request message is destined for.  Must be one of the
   * server numbers listed in TestScript.destination section.
 */
  destination?: Maybe<Scalars['Int']>,
  /** 
 * Whether or not to implicitly send the request url in encoded format. The
   * default is true to match the standard RESTful client behavior. Set to false
   * when communicating with a server that does not support encoded url paths.
 */
  encodeRequestUrl: Scalars['Boolean'],
  /** The HTTP method the test engine MUST use for this operation regardless of any other operation details. */
  method?: Maybe<Scalars['FHIRCode']>,
  /** 
 * The server where the request message originates from.  Must be one of the
   * server numbers listed in TestScript.origin section.
 */
  origin?: Maybe<Scalars['Int']>,
  /** Path plus parameters after [type].  Used to set parts of the request URL explicitly. */
  params?: Maybe<Scalars['String']>,
  /** Header elements would be used to set HTTP headers. */
  requestHeader?: Maybe<Array<Maybe<FHIRTestScriptsetupactionoperationrequestHeader>>>,
  /** The fixture id (maybe new) to map to the request. */
  requestId?: Maybe<Scalars['FHIRId']>,
  /** The fixture id (maybe new) to map to the response. */
  responseId?: Maybe<Scalars['FHIRId']>,
  /** The id of the fixture used as the body of a PUT or POST request. */
  sourceId?: Maybe<Scalars['FHIRId']>,
  /** Id of fixture used for extracting the [id],  [type], and [vid] for GET requests. */
  targetId?: Maybe<Scalars['FHIRId']>,
  /** Complete request URL. */
  url?: Maybe<Scalars['String']>,
};

export type FHIRTestScriptsetupactionoperationrequestHeader = {
   __typename?: 'FHIRTestScriptsetupactionoperationrequestHeader',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The HTTP header field e.g. 'Accept'. */
  field: Scalars['String'],
  /** The value of the header e.g. 'application/fhir+xml'. */
  value: Scalars['String'],
};

export type FHIRTestScriptteardown = {
   __typename?: 'FHIRTestScriptteardown',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The teardown action will only contain an operation. */
  action?: Maybe<Array<FHIRTestScriptteardownaction>>,
};

export type FHIRTestScriptteardownaction = {
   __typename?: 'FHIRTestScriptteardownaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

export type FHIRTestScripttest = {
   __typename?: 'FHIRTestScripttest',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The name of this test used for tracking/logging purposes by test engines. */
  name?: Maybe<Scalars['String']>,
  /** A short description of the test used by test engines for tracking and reporting purposes. */
  description?: Maybe<Scalars['String']>,
  /** Action would contain either an operation or an assertion. */
  action?: Maybe<Array<FHIRTestScripttestaction>>,
};

export type FHIRTestScripttestaction = {
   __typename?: 'FHIRTestScripttestaction',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
};

export type FHIRTestScriptvariable = {
   __typename?: 'FHIRTestScriptvariable',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Descriptive name for this variable. */
  name: Scalars['String'],
  /** A default, hard-coded, or user-defined value for this variable. */
  defaultValue?: Maybe<Scalars['String']>,
  /** A free text natural language description of the variable and its purpose. */
  description?: Maybe<Scalars['String']>,
  /** 
 * The FHIRPath expression to evaluate against the fixture body. When variables
   * are defined, only one of either expression, headerField or path must be specified.
 */
  expression?: Maybe<Scalars['String']>,
  /** Will be used to grab the HTTP header field value from the headers that sourceId is pointing to. */
  headerField?: Maybe<Scalars['String']>,
  /** Displayable text string with hint help information to the user when entering a default value. */
  hint?: Maybe<Scalars['String']>,
  /** 
 * XPath or JSONPath to evaluate against the fixture body.  When variables are
   * defined, only one of either expression, headerField or path must be specified.
 */
  path?: Maybe<Scalars['String']>,
  /** Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable. */
  sourceId?: Maybe<Scalars['FHIRId']>,
};


/** 
 * Base StructureDefinition for Timing Type: Specifies an event that may occur
 * multiple times. Timing schedules are used to record when things are planned,
 * expected or requested to occur. The most common usage is in dosage instructions
 * for medications. They are also used when planning care of various kinds, and may
 * be used for reporting the schedule to which past regular activities were carried out.
 */
export type FHIRTiming = {
   __typename?: 'FHIRTiming',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies specific times when the event occurs. */
  event?: Maybe<Array<Maybe<Scalars['FHIRDateTime']>>>,
  /** A set of rules that describe when the event is scheduled. */
  repeat?: Maybe<FHIRElement>,
  /** 
 * A code for the timing schedule (or just text in code.text). Some codes such as
   * BID are ubiquitous, but many institutions define their own additional codes.
   * If a code is provided, the code is understood to be a complete statement of
   * whatever is specified in the structured timing data, and either the code or
   * the data may be used to interpret the Timing, with the exception that
   * .repeat.bounds still applies over the code (and is not contained in the code).
 */
  code?: Maybe<FHIRCodeableConcept>,
};

/** 
 * Base StructureDefinition for Timing Type: Specifies an event that may occur
 * multiple times. Timing schedules are used to record when things are planned,
 * expected or requested to occur. The most common usage is in dosage instructions
 * for medications. They are also used when planning care of various kinds, and may
 * be used for reporting the schedule to which past regular activities were carried out.
 */
export type FHIRTiming_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** Identifies specific times when the event occurs. */
  _event?: Maybe<FHIRElement_Input>,
  /** Identifies specific times when the event occurs. */
  event?: Maybe<Array<Maybe<Scalars['FHIRDateTime']>>>,
  /** A set of rules that describe when the event is scheduled. */
  repeat?: Maybe<FHIRElement_Input>,
  /** 
 * A code for the timing schedule (or just text in code.text). Some codes such as
   * BID are ubiquitous, but many institutions define their own additional codes.
   * If a code is provided, the code is understood to be a complete statement of
   * whatever is specified in the structured timing data, and either the code or
   * the data may be used to interpret the Timing, with the exception that
   * .repeat.bounds still applies over the code (and is not contained in the code).
 */
  code?: Maybe<FHIRCodeableConcept_Input>,
};

/** 
 * Base StructureDefinition for TriggerDefinition Type: A description of a
 * triggering event. Triggering events can be named events, data events, or
 * periodic, as determined by the type element.
 */
export type FHIRTriggerDefinition = {
   __typename?: 'FHIRTriggerDefinition',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The type of triggering event. */
  type: Scalars['FHIRCode'],
  /** 
 * A formal name for the event. This may be an absolute URI that identifies the
   * event formally (e.g. from a trigger registry), or a simple relative URI that
   * identifies the event in a local context.
 */
  name?: Maybe<Scalars['String']>,
  /** The timing of the event (if this is a periodic trigger). */
  timingTiming?: Maybe<FHIRTiming>,
  /** The timing of the event (if this is a periodic trigger). */
  timingReference?: Maybe<FHIRTriggerDefinitiontimingReference_timingReference_Union>,
  /** The timing of the event (if this is a periodic trigger). */
  timingDate?: Maybe<Scalars['FHIRDate']>,
  /** The timing of the event (if this is a periodic trigger). */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The triggering data of the event (if this is a data trigger). If more than one
   * data is requirement is specified, then all the data requirements must be true.
 */
  data?: Maybe<Array<Maybe<FHIRDataRequirement>>>,
  /** 
 * A boolean-valued expression that is evaluated in the context of the container
   * of the trigger definition and returns whether or not the trigger fires.
 */
  condition?: Maybe<FHIRExpression>,
};

/** 
 * Base StructureDefinition for TriggerDefinition Type: A description of a
 * triggering event. Triggering events can be named events, data events, or
 * periodic, as determined by the type element.
 */
export type FHIRTriggerDefinition_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** The type of triggering event. */
  _type?: Maybe<FHIRElement_Input>,
  /** The type of triggering event. */
  type: Scalars['FHIRCode'],
  /** 
 * A formal name for the event. This may be an absolute URI that identifies the
   * event formally (e.g. from a trigger registry), or a simple relative URI that
   * identifies the event in a local context.
 */
  _name?: Maybe<FHIRElement_Input>,
  /** 
 * A formal name for the event. This may be an absolute URI that identifies the
   * event formally (e.g. from a trigger registry), or a simple relative URI that
   * identifies the event in a local context.
 */
  name?: Maybe<Scalars['String']>,
  /** The timing of the event (if this is a periodic trigger). */
  timingTiming?: Maybe<FHIRTiming_Input>,
  /** The timing of the event (if this is a periodic trigger). */
  timingReference?: Maybe<Scalars['String']>,
  /** The timing of the event (if this is a periodic trigger). */
  _timingDate?: Maybe<FHIRElement_Input>,
  /** The timing of the event (if this is a periodic trigger). */
  timingDate?: Maybe<Scalars['FHIRDate']>,
  /** The timing of the event (if this is a periodic trigger). */
  _timingDateTime?: Maybe<FHIRElement_Input>,
  /** The timing of the event (if this is a periodic trigger). */
  timingDateTime?: Maybe<Scalars['FHIRDateTime']>,
  /** 
 * The triggering data of the event (if this is a data trigger). If more than one
   * data is requirement is specified, then all the data requirements must be true.
 */
  data?: Maybe<Array<Maybe<FHIRDataRequirement_Input>>>,
  /** 
 * A boolean-valued expression that is evaluated in the context of the container
   * of the trigger definition and returns whether or not the trigger fires.
 */
  condition?: Maybe<FHIRExpression_Input>,
};

/** The timing of the event (if this is a periodic trigger). */
export type FHIRTriggerDefinitiontimingReference_timingReference_Union = FHIRSchedule;




/** 
 * Base StructureDefinition for UsageContext Type: Specifies clinical/business/etc.
 * metadata that can be used to retrieve, index and/or categorize an artifact. This
 * metadata can either be specific to the applicable population (e.g., age
 * category, DRG) or the specific context of care (e.g., venue, care setting,
 * provider of care).
 */
export type FHIRUsageContext = {
   __typename?: 'FHIRUsageContext',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code that identifies the type of context being specified by this usage context. */
  code: FHIRCoding,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueCodeableConcept: FHIRCodeableConcept,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueQuantity: FHIRQuantity,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueRange: FHIRRange,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueReference: FHIRUsageContextvalueReference_valueReference_Union,
};

/** 
 * Base StructureDefinition for UsageContext Type: Specifies clinical/business/etc.
 * metadata that can be used to retrieve, index and/or categorize an artifact. This
 * metadata can either be specific to the applicable population (e.g., age
 * category, DRG) or the specific context of care (e.g., venue, care setting,
 * provider of care).
 */
export type FHIRUsageContext_Input = {
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  _id?: Maybe<FHIRElement_Input>,
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension_Input>>>,
  /** A code that identifies the type of context being specified by this usage context. */
  code: FHIRCoding_Input,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueCodeableConcept: FHIRCodeableConcept_Input,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueQuantity: FHIRQuantity_Input,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueRange: FHIRRange_Input,
  /** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
  valueReference: Scalars['String'],
};

/** A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. */
export type FHIRUsageContextvalueReference_valueReference_Union = FHIRPlanDefinition | FHIRResearchStudy | FHIRInsurancePlan | FHIRHealthcareService | FHIRGroup | FHIRLocation | FHIROrganization;


/** 
 * A ValueSet resource instance specifies a set of codes drawn from one or more
 * code systems, intended for use in a particular context. Value sets link between
 * [[[CodeSystem]]] definitions and their use in [coded
 * elements](terminologies.html).
 */
export type FHIRValueSet = {
   __typename?: 'FHIRValueSet',
  /** Type of resource */
  resourceType: FHIRValueSet_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An absolute URI that is used to identify this value set when it is referenced
   * in a specification, model, design or an instance; also called its canonical
   * identifier. This SHOULD be globally unique and SHOULD be a literal address at
   * which at which an authoritative instance of this value set is (or will be)
   * published. This URL can be the target of a canonical reference. It SHALL
   * remain the same when the value set is stored on different servers.
 */
  url?: Maybe<Scalars['FHIRUri']>,
  /** 
 * A formal identifier that is used to identify this value set when it is
   * represented in other formats, or referenced in a specification, model, design
   * or an instance.
 */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** 
 * The identifier that is used to identify this version of the value set when it
   * is referenced in a specification, model, design or instance. This is an
   * arbitrary value managed by the value set author and is not expected to be
   * globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
   * managed version is not available. There is also no expectation that versions
   * can be placed in a lexicographical sequence.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * A natural language name identifying the value set. This name should be usable
   * as an identifier for the module by machine processing applications such as
   * code generation.
 */
  name?: Maybe<Scalars['String']>,
  /** A short, descriptive, user-friendly title for the value set. */
  title?: Maybe<Scalars['String']>,
  /** 
 * The status of this value set. Enables tracking the life-cycle of the content.
   * The status of the value set applies to the value set definition
   * (ValueSet.compose) and the associated ValueSet metadata. Expansions do not have a state.
 */
  status: Scalars['FHIRCode'],
  /** 
 * A Boolean value to indicate that this value set is authored for testing
   * purposes (or education/evaluation/marketing) and is not intended to be used
   * for genuine usage.
 */
  experimental?: Maybe<Scalars['Boolean']>,
  /** The date (and optionally time) when the value set was created or revised (e.g. the 'content logical definition'). */
  date?: Maybe<Scalars['FHIRDateTime']>,
  /** The name of the organization or individual that published the value set. */
  publisher?: Maybe<Scalars['String']>,
  /** Contact details to assist a user in finding and communicating with the publisher. */
  contact?: Maybe<Array<Maybe<FHIRContactDetail>>>,
  /** 
 * A free text natural language description of the value set from a consumer's
   * perspective. The textual description specifies the span of meanings for
   * concepts to be included within the Value Set Expansion, and also may specify
   * the intended use and limitations of the Value Set.
 */
  description?: Maybe<Scalars['String']>,
  /** 
 * The content was developed with a focus and intent of supporting the contexts
   * that are listed. These contexts may be general categories (gender, age, ...)
   * or may be references to specific programs (insurance plans, studies, ...) and
   * may be used to assist with indexing and searching for appropriate value set instances.
 */
  useContext?: Maybe<Array<Maybe<FHIRUsageContext>>>,
  /** A legal or geographic region in which the value set is intended to be used. */
  jurisdiction?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** 
 * If this is set to 'true', then no new versions of the content logical
   * definition can be created.  Note: Other metadata might still change.
 */
  immutable?: Maybe<Scalars['Boolean']>,
  /** Explanation of why this value set is needed and why it has been designed as it has. */
  purpose?: Maybe<Scalars['String']>,
  /** 
 * A copyright statement relating to the value set and/or its contents. Copyright
   * statements are generally legal restrictions on the use and publishing of the value set.
 */
  copyright?: Maybe<Scalars['String']>,
  /** 
 * A set of criteria that define the contents of the value set by including or
   * excluding codes selected from the specified code system(s) that the value set
   * draws from. This is also known as the Content Logical Definition (CLD).
 */
  compose?: Maybe<FHIRValueSetcompose>,
  /** 
 * A value set can also be 'expanded', where the value set is turned into a
   * simple collection of enumerated codes. This element holds the expansion, if it
   * has been performed.
 */
  expansion?: Maybe<FHIRValueSetexpansion>,
};

export enum FHIRValueSet_Enum_schema {
  ValueSet = 'ValueSet'
}

export type FHIRValueSetcompose = {
   __typename?: 'FHIRValueSetcompose',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * The Locked Date is  the effective date that is used to determine the version
   * of all referenced Code Systems and Value Set Definitions included in the
   * compose that are not already tied to a specific version.
 */
  lockedDate?: Maybe<Scalars['FHIRDate']>,
  /** 
 * Whether inactive codes - codes that are not approved for current use - are in
   * the value set. If inactive = true, inactive codes are to be included in the
   * expansion, if inactive = false, the inactive codes will not be included in the
   * expansion. If absent, the behavior is determined by the implementation, or by
   * the applicable $expand parameters (but generally, inactive codes would be
   * expected to be included).
 */
  inactive?: Maybe<Scalars['Boolean']>,
  /** Include one or more codes from a code system or other value set(s). */
  include?: Maybe<Array<FHIRValueSetcomposeinclude>>,
};

export type FHIRValueSetcomposeinclude = {
   __typename?: 'FHIRValueSetcomposeinclude',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An absolute URI which is the code system from which the selected codes come from. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** The version of the code system that the codes are selected from, or the special version '*' for all versions. */
  version?: Maybe<Scalars['String']>,
  /** Specifies a concept to be included or excluded. */
  concept?: Maybe<Array<Maybe<FHIRValueSetcomposeincludeconcept>>>,
  /** 
 * Select concepts by specify a matching criterion based on the properties
   * (including relationships) defined by the system, or on filters defined by the
   * system. If multiple filters are specified, they SHALL all be true.
 */
  filter?: Maybe<Array<Maybe<FHIRValueSetcomposeincludefilter>>>,
  /** 
 * Selects the concepts found in this value set (based on its value set
   * definition). This is an absolute URI that is a reference to ValueSet.url.  If
   * multiple value sets are specified this includes the union of the contents of
   * all of the referenced value sets.
 */
  valueSet?: Maybe<Array<Maybe<Scalars['FHIRCanonical']>>>,
};

export type FHIRValueSetcomposeincludeconcept = {
   __typename?: 'FHIRValueSetcomposeincludeconcept',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Specifies a code for the concept to be included or excluded. */
  code: Scalars['FHIRCode'],
  /** 
 * The text to display to the user for this concept in the context of this
   * valueset. If no display is provided, then applications using the value set use
   * the display specified for the code by the system.
 */
  display?: Maybe<Scalars['String']>,
  /** 
 * Additional representations for this concept when used in this value set -
   * other languages, aliases, specialized purposes, used for particular purposes, etc.
 */
  designation?: Maybe<Array<Maybe<FHIRValueSetcomposeincludeconceptdesignation>>>,
};

export type FHIRValueSetcomposeincludeconceptdesignation = {
   __typename?: 'FHIRValueSetcomposeincludeconceptdesignation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The language this designation is defined for. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** A code that represents types of uses of designations. */
  use?: Maybe<FHIRCoding>,
  /** The text value for this designation. */
  value: Scalars['String'],
};

export type FHIRValueSetcomposeincludefilter = {
   __typename?: 'FHIRValueSetcomposeincludefilter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A code that identifies a property or a filter defined in the code system. */
  property: Scalars['FHIRCode'],
  /** The kind of operation to perform as a part of the filter criteria. */
  op: Scalars['FHIRCode'],
  /** 
 * The match value may be either a code defined by the system, or a string value,
   * which is a regex match on the literal string of the property value  (if the
   * filter represents a property defined in CodeSystem) or of the system filter
   * value (if the filter represents a filter defined in CodeSystem) when the
   * operation is 'regex', or one of the values (true and false), when the
   * operation is 'exists'.
 */
  value: Scalars['String'],
};

export type FHIRValueSetexpansion = {
   __typename?: 'FHIRValueSetexpansion',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * An identifier that uniquely identifies this expansion of the valueset, based
   * on a unique combination of the provided parameters, the system default
   * parameters, and the underlying system code system versions etc. Systems may
   * re-use the same identifier as long as those factors remain the same, and the
   * expansion is the same, but are not required to do so. This is a business identifier.
 */
  identifier?: Maybe<Scalars['FHIRUri']>,
  /** The time at which the expansion was produced by the expanding system. */
  timestamp: Scalars['FHIRDateTime'],
  /** 
 * The total number of concepts in the expansion. If the number of concept nodes
   * in this resource is less than the stated number, then the server can return
   * more using the offset parameter.
 */
  total?: Maybe<Scalars['Int']>,
  /** 
 * If paging is being used, the offset at which this resource starts.  I.e. this
   * resource is a partial view into the expansion. If paging is not being used,
   * this element SHALL NOT be present.
 */
  offset?: Maybe<Scalars['Int']>,
  /** 
 * A parameter that controlled the expansion process. These parameters may be
   * used by users of expanded value sets to check whether the expansion is
   * suitable for a particular purpose, or to pick the correct expansion.
 */
  parameter?: Maybe<Array<Maybe<FHIRValueSetexpansionparameter>>>,
  /** The codes that are contained in the value set expansion. */
  contains?: Maybe<Array<Maybe<FHIRValueSetexpansioncontains>>>,
};

export type FHIRValueSetexpansioncontains = {
   __typename?: 'FHIRValueSetexpansioncontains',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** An absolute URI which is the code system in which the code for this item in the expansion is defined. */
  system?: Maybe<Scalars['FHIRUri']>,
  /** 
 * If true, this entry is included in the expansion for navigational purposes,
   * and the user cannot select the code directly as a proper value.
 */
  abstract?: Maybe<Scalars['Boolean']>,
  /** 
 * If the concept is inactive in the code system that defines it. Inactive codes
   * are those that are no longer to be used, but are maintained by the code system
   * for understanding legacy data. It might not be known or specified whether an
   * concept is inactive (and it may depend on the context of use).
 */
  inactive?: Maybe<Scalars['Boolean']>,
  /** 
 * The version of the code system from this code was taken. Note that a
   * well-maintained code system does not need the version reported, because the
   * meaning of codes is consistent across versions. However this cannot
   * consistently be assured, and when the meaning is not guaranteed to be
   * consistent, the version SHOULD be exchanged.
 */
  version?: Maybe<Scalars['String']>,
  /** 
 * The code for this item in the expansion hierarchy. If this code is missing the
   * entry in the hierarchy is a place holder (abstract) and does not represent a
   * valid code in the value set.
 */
  code?: Maybe<Scalars['FHIRCode']>,
  /** The recommended display for this item in the expansion. */
  display?: Maybe<Scalars['String']>,
};

export type FHIRValueSetexpansionparameter = {
   __typename?: 'FHIRValueSetexpansionparameter',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * Name of the input parameter to the $expand operation; may be a server-assigned
   * name for additional default or other server-supplied parameters used to
   * control the expansion process.
 */
  name: Scalars['String'],
  /** The value of the parameter. */
  valueString?: Maybe<Scalars['String']>,
  /** The value of the parameter. */
  valueBoolean?: Maybe<Scalars['Boolean']>,
  /** The value of the parameter. */
  valueInteger?: Maybe<Scalars['Int']>,
  /** The value of the parameter. */
  valueDecimal?: Maybe<Scalars['Float']>,
  /** The value of the parameter. */
  valueUri?: Maybe<Scalars['FHIRUri']>,
  /** The value of the parameter. */
  valueCode?: Maybe<Scalars['FHIRCode']>,
  /** The value of the parameter. */
  valueDateTime?: Maybe<Scalars['FHIRDateTime']>,
};

/** Describes validation requirements, source(s), status and dates for one or more elements. */
export type FHIRVerificationResult = {
   __typename?: 'FHIRVerificationResult',
  /** Type of resource */
  resourceType: FHIRVerificationResult_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A resource that was validated. */
  target?: Maybe<Array<Maybe<FHIRVerificationResulttarget_target_Union>>>,
  /** The fhirpath location(s) within the resource that was validated. */
  targetLocation?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** The frequency with which the target must be validated (none; initial; periodic). */
  need?: Maybe<FHIRCodeableConcept>,
  /** 
 * The validation status of the target (attested; validated; in process; requires
   * revalidation; validation failed; revalidation failed).
 */
  status: Scalars['FHIRCode'],
  /** When the validation status was updated. */
  statusDate?: Maybe<Scalars['FHIRDateTime']>,
  /** What the target is validated against (nothing; primary source; multiple sources). */
  validationType?: Maybe<FHIRCodeableConcept>,
  /** 
 * The primary process by which the target is validated (edit check; value set;
   * primary source; multiple sources; standalone; in context).
 */
  validationProcess?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Frequency of revalidation. */
  frequency?: Maybe<FHIRTiming>,
  /** The date/time validation was last completed (including failed validations). */
  lastPerformed?: Maybe<Scalars['FHIRDateTime']>,
  /** The date when target is next validated, if appropriate. */
  nextScheduled?: Maybe<Scalars['FHIRDate']>,
  /** The result if validation fails (fatal; warning; record only; none). */
  failureAction?: Maybe<FHIRCodeableConcept>,
  /** Information about the primary source(s) involved in validation. */
  primarySource?: Maybe<Array<Maybe<FHIRVerificationResultprimarySource>>>,
  /** Information about the entity attesting to information. */
  attestation?: Maybe<FHIRVerificationResultattestation>,
  /** Information about the entity validating information. */
  validator?: Maybe<Array<Maybe<FHIRVerificationResultvalidator>>>,
};

export enum FHIRVerificationResult_Enum_schema {
  VerificationResult = 'VerificationResult'
}

export type FHIRVerificationResultattestation = {
   __typename?: 'FHIRVerificationResultattestation',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** The individual or organization attesting to information. */
  who?: Maybe<FHIRVerificationResultattestationwho_who_Union>,
  /** When the who is asserting on behalf of another (organization or individual). */
  onBehalfOf?: Maybe<FHIRVerificationResultattestationonBehalfOf_onBehalfOf_Union>,
  /** The method by which attested information was submitted/retrieved (manual; API; Push). */
  communicationMethod?: Maybe<FHIRCodeableConcept>,
  /** The date the information was attested to. */
  date?: Maybe<Scalars['FHIRDate']>,
  /** A digital identity certificate associated with the attestation source. */
  sourceIdentityCertificate?: Maybe<Scalars['String']>,
  /** 
 * A digital identity certificate associated with the proxy entity submitting
   * attested information on behalf of the attestation source.
 */
  proxyIdentityCertificate?: Maybe<Scalars['String']>,
  /** 
 * Signed assertion by the proxy entity indicating that they have the right to
   * submit attested information on behalf of the attestation source.
 */
  proxySignature?: Maybe<FHIRSignature>,
  /** Signed assertion by the attestation source that they have attested to the information. */
  sourceSignature?: Maybe<FHIRSignature>,
};

/** When the who is asserting on behalf of another (organization or individual). */
export type FHIRVerificationResultattestationonBehalfOf_onBehalfOf_Union = FHIROrganization | FHIRPractitioner | FHIRPractitionerRole;

/** The individual or organization attesting to information. */
export type FHIRVerificationResultattestationwho_who_Union = FHIRPractitioner | FHIRPractitionerRole | FHIROrganization;

export type FHIRVerificationResultprimarySource = {
   __typename?: 'FHIRVerificationResultprimarySource',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Reference to the primary source. */
  who?: Maybe<FHIRVerificationResultprimarySourcewho_who_Union>,
  /** 
 * Type of primary source (License Board; Primary Education; Continuing
   * Education; Postal Service; Relationship owner; Registration Authority; legal
   * source; issuing source; authoritative source).
 */
  type?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Method for communicating with the primary source (manual; API; Push). */
  communicationMethod?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
  /** Status of the validation of the target against the primary source (successful; failed; unknown). */
  validationStatus?: Maybe<FHIRCodeableConcept>,
  /** When the target was validated against the primary source. */
  validationDate?: Maybe<Scalars['FHIRDateTime']>,
  /** Ability of the primary source to push updates/alerts (yes; no; undetermined). */
  canPushUpdates?: Maybe<FHIRCodeableConcept>,
  /** Type of alerts/updates the primary source can send (specific requested changes; any changes; as defined by source). */
  pushTypeAvailable?: Maybe<Array<Maybe<FHIRCodeableConcept>>>,
};

/** Reference to the primary source. */
export type FHIRVerificationResultprimarySourcewho_who_Union = FHIROrganization | FHIRPractitioner | FHIRPractitionerRole;

/** A resource that was validated. */
export type FHIRVerificationResulttarget_target_Union = FHIRResource;

export type FHIRVerificationResultvalidator = {
   __typename?: 'FHIRVerificationResultvalidator',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Reference to the organization validating information. */
  organization: FHIRVerificationResultvalidatororganization_organization_Union,
  /** A digital identity certificate associated with the validator. */
  identityCertificate?: Maybe<Scalars['String']>,
  /** Signed assertion by the validator that they have validated the information. */
  attestationSignature?: Maybe<FHIRSignature>,
};

/** Reference to the organization validating information. */
export type FHIRVerificationResultvalidatororganization_organization_Union = FHIROrganization;

/** An authorization for the provision of glasses and/or contact lenses to a patient. */
export type FHIRVisionPrescription = {
   __typename?: 'FHIRVisionPrescription',
  /** Type of resource */
  resourceType: FHIRVisionPrescription_Enum_schema,
  /** The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes. */
  id?: Maybe<Scalars['FHIRId']>,
  /** 
 * The metadata about the resource. This is content that is maintained by the
   * infrastructure. Changes to the content might not always be associated with
   * version changes to the resource.
 */
  meta?: Maybe<FHIRMeta>,
  /** 
 * A reference to a set of rules that were followed when the resource was
   * constructed, and which must be understood when processing the content. Often,
   * this is a reference to an implementation guide that defines the special rules
   * along with other profiles etc.
 */
  implicitRules?: Maybe<Scalars['FHIRUri']>,
  /** The base language in which the resource is written. */
  language?: Maybe<Scalars['FHIRCode']>,
  /** 
 * A human-readable narrative that contains a summary of the resource and can be
   * used to represent the content of the resource to a human. The narrative need
   * not encode all the structured data, but is required to contain sufficient
   * detail to make it 'clinically safe' for a human to just read the narrative.
   * Resource definitions may define what content should be represented in the
   * narrative to ensure clinical safety.
 */
  text?: Maybe<FHIRNarrative>,
  /** 
 * These resources do not have an independent existence apart from the resource
   * that contains them - they cannot be identified independently, and nor can they
   * have their own independent transaction scope.
 */
  contained?: Maybe<Array<Maybe<FHIRResourceList>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the resource and that modifies the understanding of the element
   * that contains it and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer is allowed to define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension. Applications
   * processing a resource are required to check for modifier extensions.  Modifier
   * extensions SHALL NOT change the meaning of any elements on Resource or
   * DomainResource (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** A unique identifier assigned to this vision prescription. */
  identifier?: Maybe<Array<Maybe<FHIRIdentifier>>>,
  /** The status of the resource instance. */
  status: Scalars['FHIRCode'],
  /** The date this resource was created. */
  created: Scalars['FHIRDateTime'],
  /** A resource reference to the person to whom the vision prescription applies. */
  patient: FHIRVisionPrescriptionpatient_patient_Union,
  /** 
 * A reference to a resource that identifies the particular occurrence of contact
   * between patient and health care provider during which the prescription was issued.
 */
  encounter?: Maybe<FHIRVisionPrescriptionencounter_encounter_Union>,
  /** The date (and perhaps time) when the prescription was written. */
  dateWritten: Scalars['FHIRDateTime'],
  /** The healthcare professional responsible for authorizing the prescription. */
  prescriber: FHIRVisionPrescriptionprescriber_prescriber_Union,
  /** 
 * Contain the details of  the individual lens specifications and serves as the
   * authorization for the fullfillment by certified professionals.
 */
  lensSpecification?: Maybe<Array<FHIRVisionPrescriptionlensSpecification>>,
};

export enum FHIRVisionPrescription_Enum_schema {
  VisionPrescription = 'VisionPrescription'
}

/** 
 * A reference to a resource that identifies the particular occurrence of contact
 * between patient and health care provider during which the prescription was issued.
 */
export type FHIRVisionPrescriptionencounter_encounter_Union = FHIREncounter;

export type FHIRVisionPrescriptionlensSpecification = {
   __typename?: 'FHIRVisionPrescriptionlensSpecification',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Identifies the type of vision correction product which is required for the patient. */
  product: FHIRCodeableConcept,
  /** The eye for which the lens specification applies. */
  eye: Scalars['FHIRCode'],
  /** Lens power measured in dioptres (0.25 units). */
  sphere?: Maybe<Scalars['Float']>,
  /** Power adjustment for astigmatism measured in dioptres (0.25 units). */
  cylinder?: Maybe<Scalars['Float']>,
  /** Adjustment for astigmatism measured in integer degrees. */
  axis?: Maybe<Scalars['Int']>,
  /** Allows for adjustment on two axis. */
  prism?: Maybe<Array<Maybe<FHIRVisionPrescriptionlensSpecificationprism>>>,
  /** Power adjustment for multifocal lenses measured in dioptres (0.25 units). */
  add?: Maybe<Scalars['Float']>,
  /** Contact lens power measured in dioptres (0.25 units). */
  power?: Maybe<Scalars['Float']>,
  /** Back curvature measured in millimetres. */
  backCurve?: Maybe<Scalars['Float']>,
  /** Contact lens diameter measured in millimetres. */
  diameter?: Maybe<Scalars['Float']>,
  /** The recommended maximum wear period for the lens. */
  duration?: Maybe<FHIRQuantity>,
  /** Special color or pattern. */
  color?: Maybe<Scalars['String']>,
  /** Brand recommendations or restrictions. */
  brand?: Maybe<Scalars['String']>,
  /** Notes for special requirements such as coatings and lens materials. */
  note?: Maybe<Array<Maybe<FHIRAnnotation>>>,
};

export type FHIRVisionPrescriptionlensSpecificationprism = {
   __typename?: 'FHIRVisionPrescriptionlensSpecificationprism',
  /** 
 * Unique id for the element within a resource (for internal references). This
   * may be any string value that does not contain spaces.
 */
  id?: Maybe<Scalars['String']>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element. To make the use of extensions safe and manageable,
   * there is a strict set of governance  applied to the definition and use of
   * extensions. Though any implementer can define an extension, there is a set of
   * requirements that SHALL be met as part of the definition of the extension.
 */
  extension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** 
 * May be used to represent additional information that is not part of the basic
   * definition of the element and that modifies the understanding of the element
   * in which it is contained and/or the understanding of the containing element's
   * descendants. Usually modifier elements provide negation or qualification. To
   * make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements that SHALL
   * be met as part of the definition of the extension. Applications processing a
   * resource are required to check for modifier extensions.  Modifier extensions
   * SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
 */
  modifierExtension?: Maybe<Array<Maybe<FHIRExtension>>>,
  /** Amount of prism to compensate for eye alignment in fractional units. */
  amount: Scalars['Float'],
  /** The relative base, or reference lens edge, for the prism. */
  base: Scalars['FHIRCode'],
};

/** A resource reference to the person to whom the vision prescription applies. */
export type FHIRVisionPrescriptionpatient_patient_Union = FHIRPatient;

/** The healthcare professional responsible for authorizing the prescription. */
export type FHIRVisionPrescriptionprescriber_prescriber_Union = FHIRPractitioner | FHIRPractitionerRole;


/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Float']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Float']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Float']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Float']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Float']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Float']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Float']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Float']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Float']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Float']>,
};

/** All input for the `forgotPassword` mutation. */
export type ForgotPasswordInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
};

/** The output of our `forgotPassword` mutation. */
export type ForgotPasswordPayload = {
   __typename?: 'ForgotPasswordPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  boolean?: Maybe<Scalars['Boolean']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

export enum Gender {
  MALE = 'MALE',
  FEMALE = 'FEMALE',
  OTHER = 'OTHER',
  UNKNOWN = 'UNKNOWN'
}

/** A filter to be used against Gender fields. All fields are combined with a logical ‘and.’ */
export type GenderFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Gender>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Gender>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Gender>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Gender>,
  /** Included in the specified list. */
  in?: Maybe<Array<Gender>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Gender>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Gender>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Gender>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Gender>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Gender>,
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>,
};


/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JSONFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['JSON']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['JSON']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['JSON']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['JSON']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['JSON']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['JSON']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['JSON']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['JSON']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['JSON']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['JSON']>,
  /** Contains the specified JSON. */
  jsonbContains?: Maybe<Scalars['JSON']>,
  /** Contains the specified key. */
  containsKey?: Maybe<Scalars['String']>,
  /** Contains all of the specified keys. */
  containsAllKeys?: Maybe<Array<Scalars['String']>>,
  /** Contains any of the specified keys. */
  containsAnyKeys?: Maybe<Array<Scalars['String']>>,
  /** Contained by the specified JSON. */
  jsonbContainedBy?: Maybe<Scalars['JSON']>,
};

export type Langual = Node & {
   __typename?: 'Langual',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  code: Scalars['String'],
  description: Scalars['String'],
  /** Reads and enables pagination through a set of `ConsumableLangual`. */
  consumableLangualsByLangualCode: ConsumableLangualsConnection,
};


export type LangualconsumableLangualsByLangualCodeArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableLangualsOrderBy>>,
  condition?: Maybe<ConsumableLangualCondition>,
  filter?: Maybe<ConsumableLangualFilter>
};

/** A condition to be used against `Langual` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LangualCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>,
};

/** A filter to be used against `Langual` object types. All fields are combined with a logical ‘and.’ */
export type LangualFilter = {
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>,
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LangualFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LangualFilter>>,
  /** Negates the expression. */
  not?: Maybe<LangualFilter>,
};

/** A connection to a list of `Langual` values. */
export type LangualsConnection = {
   __typename?: 'LangualsConnection',
  /** A list of `Langual` objects. */
  nodes: Array<Langual>,
  /** A list of edges which contains the `Langual` and cursor to aid in pagination. */
  edges: Array<LangualsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Langual` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Langual` edge in the connection. */
export type LangualsEdge = {
   __typename?: 'LangualsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Langual` at the end of the edge. */
  node: Langual,
};

/** Methods to use when ordering `Langual`. */
export enum LangualsOrderBy {
  NATURAL = 'NATURAL',
  CODE_ASC = 'CODE_ASC',
  CODE_DESC = 'CODE_DESC',
  DESCRIPTION_ASC = 'DESCRIPTION_ASC',
  DESCRIPTION_DESC = 'DESCRIPTION_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Meal = Node & {
   __typename?: 'Meal',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  userId?: Maybe<Scalars['Int']>,
  copyOfMealId?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  description: Scalars['String'],
  lastCalculatedAt: Scalars['Datetime'],
  calculationIsStale: Scalars['Boolean'],
  isPublic: Scalars['Boolean'],
  mealConsumablesCount: Scalars['Int'],
  mealtimeId?: Maybe<Scalars['Int']>,
  feedingFigure?: Maybe<Scalars['Int']>,
  suggestedName: Scalars['String'],
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** Reads and enables pagination through a set of `Meal`. */
  mealsByCopyOfMealId: MealsConnection,
  /** Reads and enables pagination through a set of `MealConsumable`. */
  mealConsumablesByMealId: MealConsumablesConnection,
  /** Reads and enables pagination through a set of `MenuTemplateMeal`. */
  menuTemplateMealsByMealId: MenuTemplateMealsConnection,
  /** Reads and enables pagination through a set of `MealNutrient`. */
  mealNutrientsByMealId: MealNutrientsConnection,
  /** Reads and enables pagination through a set of `MealTag`. */
  mealTagsByMealId: MealTagsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByMealId: ProfileScheduledMealtimesConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByOriginalMealId: ProfileScheduledMealtimesConnection,
  tags?: Maybe<Array<Maybe<Scalars['String']>>>,
};


export type MealmealsByCopyOfMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


export type MealmealConsumablesByMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>,
  condition?: Maybe<MealConsumableCondition>,
  filter?: Maybe<MealConsumableFilter>
};


export type MealmenuTemplateMealsByMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>,
  condition?: Maybe<MenuTemplateMealCondition>,
  filter?: Maybe<MenuTemplateMealFilter>
};


export type MealmealNutrientsByMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealNutrientsOrderBy>>,
  condition?: Maybe<MealNutrientCondition>,
  filter?: Maybe<MealNutrientFilter>
};


export type MealmealTagsByMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealTagsOrderBy>>,
  condition?: Maybe<MealTagCondition>,
  filter?: Maybe<MealTagFilter>
};


export type MealprofileScheduledMealtimesByMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};


export type MealprofileScheduledMealtimesByOriginalMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** A condition to be used against `Meal` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MealCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `copyOfMealId` field. */
  copyOfMealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `lastCalculatedAt` field. */
  lastCalculatedAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `calculationIsStale` field. */
  calculationIsStale?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `mealConsumablesCount` field. */
  mealConsumablesCount?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `feedingFigure` field. */
  feedingFigure?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `suggestedName` field. */
  suggestedName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `profileScheduledMealtimeId` field. */
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
  /** Filters the meals to only those matching this search string. */
  search?: Maybe<Scalars['String']>,
};

export type MealConsumable = Node & {
   __typename?: 'MealConsumable',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  mealId: Scalars['Int'],
  consumableId: Scalars['Int'],
  mealConsumableCategoryId?: Maybe<Scalars['Int']>,
  consumableMeasureQuantity: Scalars['Float'],
  consumableMeasureId: Scalars['Int'],
  name?: Maybe<Scalars['String']>,
  position: Scalars['Int'],
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `Meal` that is related to this `MealConsumable`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Consumable` that is related to this `MealConsumable`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableIdAndConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** Reads a single `MealConsumableCategory` that is related to this `MealConsumable`. */
  mealConsumableCategoryByMealConsumableCategoryId?: Maybe<MealConsumableCategory>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableMeasureId?: Maybe<ConsumableMeasure>,
};

/** A connection to a list of `MealConsumableCategory` values. */
export type MealConsumableCategoriesConnection = {
   __typename?: 'MealConsumableCategoriesConnection',
  /** A list of `MealConsumableCategory` objects. */
  nodes: Array<MealConsumableCategory>,
  /** A list of edges which contains the `MealConsumableCategory` and cursor to aid in pagination. */
  edges: Array<MealConsumableCategoriesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MealConsumableCategory` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MealConsumableCategory` edge in the connection. */
export type MealConsumableCategoriesEdge = {
   __typename?: 'MealConsumableCategoriesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MealConsumableCategory` at the end of the edge. */
  node: MealConsumableCategory,
};

/** Methods to use when ordering `MealConsumableCategory`. */
export enum MealConsumableCategoriesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIORITY_ASC = 'PRIORITY_ASC',
  PRIORITY_DESC = 'PRIORITY_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type MealConsumableCategory = Node & {
   __typename?: 'MealConsumableCategory',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  name: Scalars['String'],
  priority: Scalars['Int'],
  /** Reads and enables pagination through a set of `MealConsumable`. */
  mealConsumablesByMealConsumableCategoryId: MealConsumablesConnection,
};


export type MealConsumableCategorymealConsumablesByMealConsumableCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>,
  condition?: Maybe<MealConsumableCondition>,
  filter?: Maybe<MealConsumableFilter>
};

/** 
 * A condition to be used against `MealConsumableCategory` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MealConsumableCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `priority` field. */
  priority?: Maybe<Scalars['Int']>,
};

/** A filter to be used against `MealConsumableCategory` object types. All fields are combined with a logical ‘and.’ */
export type MealConsumableCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `priority` field. */
  priority?: Maybe<IntFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealConsumableCategoryFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealConsumableCategoryFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealConsumableCategoryFilter>,
};

/** 
 * A condition to be used against `MealConsumable` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MealConsumableCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `consumableId` field. */
  consumableId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `mealConsumableCategoryId` field. */
  mealConsumableCategoryId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `consumableMeasureQuantity` field. */
  consumableMeasureQuantity?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `consumableMeasureId` field. */
  consumableMeasureId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `MealConsumable` object types. All fields are combined with a logical ‘and.’ */
export type MealConsumableFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `mealId` field. */
  mealId?: Maybe<IntFilter>,
  /** Filter by the object’s `consumableId` field. */
  consumableId?: Maybe<IntFilter>,
  /** Filter by the object’s `mealConsumableCategoryId` field. */
  mealConsumableCategoryId?: Maybe<IntFilter>,
  /** Filter by the object’s `consumableMeasureQuantity` field. */
  consumableMeasureQuantity?: Maybe<FloatFilter>,
  /** Filter by the object’s `consumableMeasureId` field. */
  consumableMeasureId?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `position` field. */
  position?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealConsumableFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealConsumableFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealConsumableFilter>,
};

/** An input for mutations affecting `MealConsumable` */
export type MealConsumableInput = {
  mealId: Scalars['Int'],
  consumableId: Scalars['Int'],
  mealConsumableCategoryId?: Maybe<Scalars['Int']>,
  consumableMeasureQuantity?: Maybe<Scalars['Float']>,
  consumableMeasureId?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  position?: Maybe<Scalars['Int']>,
};

/** Represents an update to a `MealConsumable`. Fields that are set will be updated. */
export type MealConsumablePatch = {
  consumableId?: Maybe<Scalars['Int']>,
  mealConsumableCategoryId?: Maybe<Scalars['Int']>,
  consumableMeasureQuantity?: Maybe<Scalars['Float']>,
  consumableMeasureId?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  position?: Maybe<Scalars['Int']>,
};

/** A connection to a list of `MealConsumable` values. */
export type MealConsumablesConnection = {
   __typename?: 'MealConsumablesConnection',
  /** A list of `MealConsumable` objects. */
  nodes: Array<MealConsumable>,
  /** A list of edges which contains the `MealConsumable` and cursor to aid in pagination. */
  edges: Array<MealConsumablesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MealConsumable` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MealConsumable` edge in the connection. */
export type MealConsumablesEdge = {
   __typename?: 'MealConsumablesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MealConsumable` at the end of the edge. */
  node: MealConsumable,
};

/** Methods to use when ordering `MealConsumable`. */
export enum MealConsumablesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  MEAL_ID_ASC = 'MEAL_ID_ASC',
  MEAL_ID_DESC = 'MEAL_ID_DESC',
  CONSUMABLE_ID_ASC = 'CONSUMABLE_ID_ASC',
  CONSUMABLE_ID_DESC = 'CONSUMABLE_ID_DESC',
  MEAL_CONSUMABLE_CATEGORY_ID_ASC = 'MEAL_CONSUMABLE_CATEGORY_ID_ASC',
  MEAL_CONSUMABLE_CATEGORY_ID_DESC = 'MEAL_CONSUMABLE_CATEGORY_ID_DESC',
  CONSUMABLE_MEASURE_QUANTITY_ASC = 'CONSUMABLE_MEASURE_QUANTITY_ASC',
  CONSUMABLE_MEASURE_QUANTITY_DESC = 'CONSUMABLE_MEASURE_QUANTITY_DESC',
  CONSUMABLE_MEASURE_ID_ASC = 'CONSUMABLE_MEASURE_ID_ASC',
  CONSUMABLE_MEASURE_ID_DESC = 'CONSUMABLE_MEASURE_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `Meal` object types. All fields are combined with a logical ‘and.’ */
export type MealFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `copyOfMealId` field. */
  copyOfMealId?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>,
  /** Filter by the object’s `lastCalculatedAt` field. */
  lastCalculatedAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `calculationIsStale` field. */
  calculationIsStale?: Maybe<BooleanFilter>,
  /** Filter by the object’s `isPublic` field. */
  isPublic?: Maybe<BooleanFilter>,
  /** Filter by the object’s `mealConsumablesCount` field. */
  mealConsumablesCount?: Maybe<IntFilter>,
  /** Filter by the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<IntFilter>,
  /** Filter by the object’s `feedingFigure` field. */
  feedingFigure?: Maybe<IntFilter>,
  /** Filter by the object’s `suggestedName` field. */
  suggestedName?: Maybe<StringFilter>,
  /** Filter by the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `profileScheduledMealtimeId` field. */
  profileScheduledMealtimeId?: Maybe<IntFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealFilter>,
};

/** An input for mutations affecting `Meal` */
export type MealInput = {
  copyOfMealId?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  mealtimeId?: Maybe<Scalars['Int']>,
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
};

export type MealNutrient = Node & {
   __typename?: 'MealNutrient',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  mealId: Scalars['Int'],
  nutrientId: Scalars['Int'],
  valueInNutrientUnits: Scalars['Float'],
  /** Reads a single `Meal` that is related to this `MealNutrient`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Nutrient` that is related to this `MealNutrient`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
};

/** 
 * A condition to be used against `MealNutrient` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MealNutrientCondition = {
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `nutrientId` field. */
  nutrientId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `valueInNutrientUnits` field. */
  valueInNutrientUnits?: Maybe<Scalars['Float']>,
};

/** A filter to be used against `MealNutrient` object types. All fields are combined with a logical ‘and.’ */
export type MealNutrientFilter = {
  /** Filter by the object’s `mealId` field. */
  mealId?: Maybe<IntFilter>,
  /** Filter by the object’s `nutrientId` field. */
  nutrientId?: Maybe<IntFilter>,
  /** Filter by the object’s `valueInNutrientUnits` field. */
  valueInNutrientUnits?: Maybe<FloatFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealNutrientFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealNutrientFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealNutrientFilter>,
};

/** An input for mutations affecting `MealNutrientRange` */
export type MealNutrientRangeInput = {
  nutrientId?: Maybe<Scalars['Int']>,
  minimumValueInNutrientUnits?: Maybe<Scalars['Float']>,
  maximumValueInNutrientUnits?: Maybe<Scalars['Float']>,
};

/** A connection to a list of `MealNutrient` values. */
export type MealNutrientsConnection = {
   __typename?: 'MealNutrientsConnection',
  /** A list of `MealNutrient` objects. */
  nodes: Array<MealNutrient>,
  /** A list of edges which contains the `MealNutrient` and cursor to aid in pagination. */
  edges: Array<MealNutrientsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MealNutrient` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MealNutrient` edge in the connection. */
export type MealNutrientsEdge = {
   __typename?: 'MealNutrientsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MealNutrient` at the end of the edge. */
  node: MealNutrient,
};

/** Methods to use when ordering `MealNutrient`. */
export enum MealNutrientsOrderBy {
  NATURAL = 'NATURAL',
  MEAL_ID_ASC = 'MEAL_ID_ASC',
  MEAL_ID_DESC = 'MEAL_ID_DESC',
  NUTRIENT_ID_ASC = 'NUTRIENT_ID_ASC',
  NUTRIENT_ID_DESC = 'NUTRIENT_ID_DESC',
  VALUE_IN_NUTRIENT_UNITS_ASC = 'VALUE_IN_NUTRIENT_UNITS_ASC',
  VALUE_IN_NUTRIENT_UNITS_DESC = 'VALUE_IN_NUTRIENT_UNITS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Meal`. Fields that are set will be updated. */
export type MealPatch = {
  name?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  isPublic?: Maybe<Scalars['Boolean']>,
  mealtimeId?: Maybe<Scalars['Int']>,
};

/** A connection to a list of `Meal` values. */
export type MealsConnection = {
   __typename?: 'MealsConnection',
  /** A list of `Meal` objects. */
  nodes: Array<Meal>,
  /** A list of edges which contains the `Meal` and cursor to aid in pagination. */
  edges: Array<MealsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Meal` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Meal` edge in the connection. */
export type MealsEdge = {
   __typename?: 'MealsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Meal` at the end of the edge. */
  node: Meal,
};

/** Methods to use when ordering `Meal`. */
export enum MealsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  COPY_OF_MEAL_ID_ASC = 'COPY_OF_MEAL_ID_ASC',
  COPY_OF_MEAL_ID_DESC = 'COPY_OF_MEAL_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  DESCRIPTION_ASC = 'DESCRIPTION_ASC',
  DESCRIPTION_DESC = 'DESCRIPTION_DESC',
  LAST_CALCULATED_AT_ASC = 'LAST_CALCULATED_AT_ASC',
  LAST_CALCULATED_AT_DESC = 'LAST_CALCULATED_AT_DESC',
  CALCULATION_IS_STALE_ASC = 'CALCULATION_IS_STALE_ASC',
  CALCULATION_IS_STALE_DESC = 'CALCULATION_IS_STALE_DESC',
  IS_PUBLIC_ASC = 'IS_PUBLIC_ASC',
  IS_PUBLIC_DESC = 'IS_PUBLIC_DESC',
  MEAL_CONSUMABLES_COUNT_ASC = 'MEAL_CONSUMABLES_COUNT_ASC',
  MEAL_CONSUMABLES_COUNT_DESC = 'MEAL_CONSUMABLES_COUNT_DESC',
  MEALTIME_ID_ASC = 'MEALTIME_ID_ASC',
  MEALTIME_ID_DESC = 'MEALTIME_ID_DESC',
  FEEDING_FIGURE_ASC = 'FEEDING_FIGURE_ASC',
  FEEDING_FIGURE_DESC = 'FEEDING_FIGURE_DESC',
  SUGGESTED_NAME_ASC = 'SUGGESTED_NAME_ASC',
  SUGGESTED_NAME_DESC = 'SUGGESTED_NAME_DESC',
  MENU_TEMPLATE_MEAL_ID_ASC = 'MENU_TEMPLATE_MEAL_ID_ASC',
  MENU_TEMPLATE_MEAL_ID_DESC = 'MENU_TEMPLATE_MEAL_ID_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PROFILE_SCHEDULED_MEALTIME_ID_ASC = 'PROFILE_SCHEDULED_MEALTIME_ID_ASC',
  PROFILE_SCHEDULED_MEALTIME_ID_DESC = 'PROFILE_SCHEDULED_MEALTIME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type MealTag = Node & {
   __typename?: 'MealTag',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  mealId: Scalars['Int'],
  tagId: Scalars['Int'],
  /** Reads a single `Meal` that is related to this `MealTag`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Tag` that is related to this `MealTag`. */
  tagByTagId?: Maybe<Tag>,
};

/** A condition to be used against `MealTag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MealTagCondition = {
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['Int']>,
};

/** A filter to be used against `MealTag` object types. All fields are combined with a logical ‘and.’ */
export type MealTagFilter = {
  /** Filter by the object’s `mealId` field. */
  mealId?: Maybe<IntFilter>,
  /** Filter by the object’s `tagId` field. */
  tagId?: Maybe<IntFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealTagFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealTagFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealTagFilter>,
};

/** An input for mutations affecting `MealTag` */
export type MealTagInput = {
  mealId: Scalars['Int'],
  tagId: Scalars['Int'],
};

/** A connection to a list of `MealTag` values. */
export type MealTagsConnection = {
   __typename?: 'MealTagsConnection',
  /** A list of `MealTag` objects. */
  nodes: Array<MealTag>,
  /** A list of edges which contains the `MealTag` and cursor to aid in pagination. */
  edges: Array<MealTagsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MealTag` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MealTag` edge in the connection. */
export type MealTagsEdge = {
   __typename?: 'MealTagsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MealTag` at the end of the edge. */
  node: MealTag,
};

/** Methods to use when ordering `MealTag`. */
export enum MealTagsOrderBy {
  NATURAL = 'NATURAL',
  MEAL_ID_ASC = 'MEAL_ID_ASC',
  MEAL_ID_DESC = 'MEAL_ID_DESC',
  TAG_ID_ASC = 'TAG_ID_ASC',
  TAG_ID_DESC = 'TAG_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Mealtime = Node & {
   __typename?: 'Mealtime',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  includedByDefault: Scalars['Boolean'],
  name: Scalars['String'],
  nameAbbreviated: Scalars['String'],
  defaultTimeRange: TimeRange,
  /** Reads and enables pagination through a set of `Meal`. */
  mealsByMealtimeId: MealsConnection,
  /** Reads and enables pagination through a set of `MenuTemplateMeal`. */
  menuTemplateMealsByMealtimeId: MenuTemplateMealsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByMealtimeId: ProfileScheduledMealtimesConnection,
};


export type MealtimemealsByMealtimeIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


export type MealtimemenuTemplateMealsByMealtimeIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>,
  condition?: Maybe<MenuTemplateMealCondition>,
  filter?: Maybe<MenuTemplateMealFilter>
};


export type MealtimeprofileScheduledMealtimesByMealtimeIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** 
 * A condition to be used against `Mealtime` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MealtimeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `includedByDefault` field. */
  includedByDefault?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `nameAbbreviated` field. */
  nameAbbreviated?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `defaultTimeRange` field. */
  defaultTimeRange?: Maybe<TimeRangeInput>,
};

/** A filter to be used against `Mealtime` object types. All fields are combined with a logical ‘and.’ */
export type MealtimeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `includedByDefault` field. */
  includedByDefault?: Maybe<BooleanFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `nameAbbreviated` field. */
  nameAbbreviated?: Maybe<StringFilter>,
  /** Filter by the object’s `defaultTimeRange` field. */
  defaultTimeRange?: Maybe<TimeRangeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MealtimeFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MealtimeFilter>>,
  /** Negates the expression. */
  not?: Maybe<MealtimeFilter>,
};

/** A connection to a list of `Mealtime` values. */
export type MealtimesConnection = {
   __typename?: 'MealtimesConnection',
  /** A list of `Mealtime` objects. */
  nodes: Array<Mealtime>,
  /** A list of edges which contains the `Mealtime` and cursor to aid in pagination. */
  edges: Array<MealtimesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Mealtime` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Mealtime` edge in the connection. */
export type MealtimesEdge = {
   __typename?: 'MealtimesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Mealtime` at the end of the edge. */
  node: Mealtime,
};

/** Methods to use when ordering `Mealtime`. */
export enum MealtimesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  INCLUDED_BY_DEFAULT_ASC = 'INCLUDED_BY_DEFAULT_ASC',
  INCLUDED_BY_DEFAULT_DESC = 'INCLUDED_BY_DEFAULT_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NAME_ABBREVIATED_ASC = 'NAME_ABBREVIATED_ASC',
  NAME_ABBREVIATED_DESC = 'NAME_ABBREVIATED_DESC',
  DEFAULT_TIME_RANGE_ASC = 'DEFAULT_TIME_RANGE_ASC',
  DEFAULT_TIME_RANGE_DESC = 'DEFAULT_TIME_RANGE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type MeasureUnit = Node & {
   __typename?: 'MeasureUnit',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  name: Scalars['String'],
};

/** 
 * A condition to be used against `MeasureUnit` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MeasureUnitCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
};

/** A filter to be used against `MeasureUnit` object types. All fields are combined with a logical ‘and.’ */
export type MeasureUnitFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MeasureUnitFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MeasureUnitFilter>>,
  /** Negates the expression. */
  not?: Maybe<MeasureUnitFilter>,
};

/** A connection to a list of `MeasureUnit` values. */
export type MeasureUnitsConnection = {
   __typename?: 'MeasureUnitsConnection',
  /** A list of `MeasureUnit` objects. */
  nodes: Array<MeasureUnit>,
  /** A list of edges which contains the `MeasureUnit` and cursor to aid in pagination. */
  edges: Array<MeasureUnitsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MeasureUnit` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MeasureUnit` edge in the connection. */
export type MeasureUnitsEdge = {
   __typename?: 'MeasureUnitsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MeasureUnit` at the end of the edge. */
  node: MeasureUnit,
};

/** Methods to use when ordering `MeasureUnit`. */
export enum MeasureUnitsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Menu = Node & {
   __typename?: 'Menu',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  authorId: Scalars['Int'],
  /** If this menu is a fork of a different menu, this represents the source menu (which may itself be a fork) */
  parentMenuId?: Maybe<Scalars['Int']>,
  name: Scalars['String'],
  /** E.g. calorie, protein, sodium etc targets */
  targets: Scalars['JSON'],
  /** The day of the week that this menu is expected to start; if omitted then days should be named ‘Day 1’, ‘Day 2’, etc */
  startDay?: Maybe<DaysOfWeek>,
  /** Whilst commonly a multiple of 7, it need not be. 10-day menus are perfectly valid */
  durationInDays: Scalars['Int'],
  isPublic: Scalars['Boolean'],
  profileId?: Maybe<Scalars['Int']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads and enables pagination through a set of `Menu`. */
  menusByParentMenuId: MenusConnection,
  /** Reads and enables pagination through a set of `MenuTemplateMeal`. */
  menuTemplateMealsByMenuId: MenuTemplateMealsConnection,
  /** Reads and enables pagination through a set of `MenuNutrientStatistic`. */
  menuNutrientStatisticsByMenuId: MenuNutrientStatisticsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByMenuId: ProfileScheduledMealtimesConnection,
};


export type MenumenusByParentMenuIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenusOrderBy>>,
  condition?: Maybe<MenuCondition>,
  filter?: Maybe<MenuFilter>
};


export type MenumenuTemplateMealsByMenuIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>,
  condition?: Maybe<MenuTemplateMealCondition>,
  filter?: Maybe<MenuTemplateMealFilter>
};


export type MenumenuNutrientStatisticsByMenuIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuNutrientStatisticsOrderBy>>,
  condition?: Maybe<MenuNutrientStatisticCondition>,
  filter?: Maybe<MenuNutrientStatisticFilter>
};


export type MenuprofileScheduledMealtimesByMenuIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** A condition to be used against `Menu` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MenuCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `parentMenuId` field. */
  parentMenuId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `targets` field. */
  targets?: Maybe<Scalars['JSON']>,
  /** Checks for equality with the object’s `startDay` field. */
  startDay?: Maybe<DaysOfWeek>,
  /** Checks for equality with the object’s `durationInDays` field. */
  durationInDays?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `profileId` field. */
  profileId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
  /** Filters the menus to only those matching this search string. */
  search?: Maybe<Scalars['String']>,
};

/** A filter to be used against `Menu` object types. All fields are combined with a logical ‘and.’ */
export type MenuFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `authorId` field. */
  authorId?: Maybe<IntFilter>,
  /** Filter by the object’s `parentMenuId` field. */
  parentMenuId?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `targets` field. */
  targets?: Maybe<JSONFilter>,
  /** Filter by the object’s `startDay` field. */
  startDay?: Maybe<DaysOfWeekFilter>,
  /** Filter by the object’s `durationInDays` field. */
  durationInDays?: Maybe<IntFilter>,
  /** Filter by the object’s `isPublic` field. */
  isPublic?: Maybe<BooleanFilter>,
  /** Filter by the object’s `profileId` field. */
  profileId?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MenuFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MenuFilter>>,
  /** Negates the expression. */
  not?: Maybe<MenuFilter>,
};

/** An input for mutations affecting `Menu` */
export type MenuInput = {
  /** If this menu is a fork of a different menu, this represents the source menu (which may itself be a fork) */
  parentMenuId?: Maybe<Scalars['Int']>,
  name: Scalars['String'],
  /** E.g. calorie, protein, sodium etc targets */
  targets?: Maybe<Scalars['JSON']>,
  /** The day of the week that this menu is expected to start; if omitted then days should be named ‘Day 1’, ‘Day 2’, etc */
  startDay?: Maybe<DaysOfWeek>,
  /** Whilst commonly a multiple of 7, it need not be. 10-day menus are perfectly valid */
  durationInDays?: Maybe<Scalars['Int']>,
  isPublic?: Maybe<Scalars['Boolean']>,
  profileId?: Maybe<Scalars['Int']>,
};

export type MenuNutrientStatistic = Node & {
   __typename?: 'MenuNutrientStatistic',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  menuId: Scalars['Int'],
  nutrientId: Scalars['Int'],
  averageDailyValueInNutrientUnit: Scalars['Float'],
  minimumDailyValueInNutrientUnit: Scalars['Float'],
  maximumDailyValueInNutrientUnit: Scalars['Float'],
  /** Reads a single `Menu` that is related to this `MenuNutrientStatistic`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Nutrient` that is related to this `MenuNutrientStatistic`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
};

/** 
 * A condition to be used against `MenuNutrientStatistic` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MenuNutrientStatisticCondition = {
  /** Checks for equality with the object’s `menuId` field. */
  menuId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `nutrientId` field. */
  nutrientId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `averageDailyValueInNutrientUnit` field. */
  averageDailyValueInNutrientUnit?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `minimumDailyValueInNutrientUnit` field. */
  minimumDailyValueInNutrientUnit?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `maximumDailyValueInNutrientUnit` field. */
  maximumDailyValueInNutrientUnit?: Maybe<Scalars['Float']>,
};

/** A filter to be used against `MenuNutrientStatistic` object types. All fields are combined with a logical ‘and.’ */
export type MenuNutrientStatisticFilter = {
  /** Filter by the object’s `menuId` field. */
  menuId?: Maybe<IntFilter>,
  /** Filter by the object’s `nutrientId` field. */
  nutrientId?: Maybe<IntFilter>,
  /** Filter by the object’s `averageDailyValueInNutrientUnit` field. */
  averageDailyValueInNutrientUnit?: Maybe<FloatFilter>,
  /** Filter by the object’s `minimumDailyValueInNutrientUnit` field. */
  minimumDailyValueInNutrientUnit?: Maybe<FloatFilter>,
  /** Filter by the object’s `maximumDailyValueInNutrientUnit` field. */
  maximumDailyValueInNutrientUnit?: Maybe<FloatFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MenuNutrientStatisticFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MenuNutrientStatisticFilter>>,
  /** Negates the expression. */
  not?: Maybe<MenuNutrientStatisticFilter>,
};

/** A connection to a list of `MenuNutrientStatistic` values. */
export type MenuNutrientStatisticsConnection = {
   __typename?: 'MenuNutrientStatisticsConnection',
  /** A list of `MenuNutrientStatistic` objects. */
  nodes: Array<MenuNutrientStatistic>,
  /** A list of edges which contains the `MenuNutrientStatistic` and cursor to aid in pagination. */
  edges: Array<MenuNutrientStatisticsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MenuNutrientStatistic` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MenuNutrientStatistic` edge in the connection. */
export type MenuNutrientStatisticsEdge = {
   __typename?: 'MenuNutrientStatisticsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MenuNutrientStatistic` at the end of the edge. */
  node: MenuNutrientStatistic,
};

/** Methods to use when ordering `MenuNutrientStatistic`. */
export enum MenuNutrientStatisticsOrderBy {
  NATURAL = 'NATURAL',
  MENU_ID_ASC = 'MENU_ID_ASC',
  MENU_ID_DESC = 'MENU_ID_DESC',
  NUTRIENT_ID_ASC = 'NUTRIENT_ID_ASC',
  NUTRIENT_ID_DESC = 'NUTRIENT_ID_DESC',
  AVERAGE_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC = 'AVERAGE_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC',
  AVERAGE_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC = 'AVERAGE_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC',
  MINIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC = 'MINIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC',
  MINIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC = 'MINIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC',
  MAXIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC = 'MAXIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_ASC',
  MAXIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC = 'MAXIMUM_DAILY_VALUE_IN_NUTRIENT_UNIT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Menu`. Fields that are set will be updated. */
export type MenuPatch = {
  name?: Maybe<Scalars['String']>,
  /** E.g. calorie, protein, sodium etc targets */
  targets?: Maybe<Scalars['JSON']>,
  /** The day of the week that this menu is expected to start; if omitted then days should be named ‘Day 1’, ‘Day 2’, etc */
  startDay?: Maybe<DaysOfWeek>,
  /** Whilst commonly a multiple of 7, it need not be. 10-day menus are perfectly valid */
  durationInDays?: Maybe<Scalars['Int']>,
  isPublic?: Maybe<Scalars['Boolean']>,
};

/** A connection to a list of `Menu` values. */
export type MenusConnection = {
   __typename?: 'MenusConnection',
  /** A list of `Menu` objects. */
  nodes: Array<Menu>,
  /** A list of edges which contains the `Menu` and cursor to aid in pagination. */
  edges: Array<MenusEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Menu` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Menu` edge in the connection. */
export type MenusEdge = {
   __typename?: 'MenusEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Menu` at the end of the edge. */
  node: Menu,
};

/** Methods to use when ordering `Menu`. */
export enum MenusOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  AUTHOR_ID_ASC = 'AUTHOR_ID_ASC',
  AUTHOR_ID_DESC = 'AUTHOR_ID_DESC',
  PARENT_MENU_ID_ASC = 'PARENT_MENU_ID_ASC',
  PARENT_MENU_ID_DESC = 'PARENT_MENU_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  TARGETS_ASC = 'TARGETS_ASC',
  TARGETS_DESC = 'TARGETS_DESC',
  START_DAY_ASC = 'START_DAY_ASC',
  START_DAY_DESC = 'START_DAY_DESC',
  DURATION_IN_DAYS_ASC = 'DURATION_IN_DAYS_ASC',
  DURATION_IN_DAYS_DESC = 'DURATION_IN_DAYS_DESC',
  IS_PUBLIC_ASC = 'IS_PUBLIC_ASC',
  IS_PUBLIC_DESC = 'IS_PUBLIC_DESC',
  PROFILE_ID_ASC = 'PROFILE_ID_ASC',
  PROFILE_ID_DESC = 'PROFILE_ID_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type MenuTemplateMeal = Node & {
   __typename?: 'MenuTemplateMeal',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  menuId: Scalars['Int'],
  mealtimeId: Scalars['Int'],
  authorId: Scalars['Int'],
  isPublic: Scalars['Boolean'],
  mealId?: Maybe<Scalars['Int']>,
  dayNumber: Scalars['Int'],
  /** If unset, use the meal’s name, otherwise use this (e.g. to give a seasonal override to the meal name) */
  name?: Maybe<Scalars['String']>,
  timeRange: TimeRange,
  /** if false, timeRange is for guidance only, otherwise timeRange might be medically significant */
  timeRangeIsStrict: Scalars['Boolean'],
  /** To update this, use moveMenuTemplateMeal */
  position: Scalars['Int'],
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `Menu` that is related to this `MenuTemplateMeal`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Mealtime` that is related to this `MenuTemplateMeal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `User` that is related to this `MenuTemplateMeal`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `MenuTemplateMeal`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `MenuTemplateMeal` that is related to this `MenuTemplateMeal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads and enables pagination through a set of `Meal`. */
  mealsByMenuTemplateMealId: MealsConnection,
  /** Reads and enables pagination through a set of `MenuTemplateMeal`. */
  menuTemplateMealsByMenuTemplateMealId: MenuTemplateMealsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByMenuTemplateMealId: ProfileScheduledMealtimesConnection,
};


export type MenuTemplateMealmealsByMenuTemplateMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


export type MenuTemplateMealmenuTemplateMealsByMenuTemplateMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>,
  condition?: Maybe<MenuTemplateMealCondition>,
  filter?: Maybe<MenuTemplateMealFilter>
};


export type MenuTemplateMealprofileScheduledMealtimesByMenuTemplateMealIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** 
 * A condition to be used against `MenuTemplateMeal` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MenuTemplateMealCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuId` field. */
  menuId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `isPublic` field. */
  isPublic?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `dayNumber` field. */
  dayNumber?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `timeRange` field. */
  timeRange?: Maybe<TimeRangeInput>,
  /** Checks for equality with the object’s `timeRangeIsStrict` field. */
  timeRangeIsStrict?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `MenuTemplateMeal` object types. All fields are combined with a logical ‘and.’ */
export type MenuTemplateMealFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `menuId` field. */
  menuId?: Maybe<IntFilter>,
  /** Filter by the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<IntFilter>,
  /** Filter by the object’s `authorId` field. */
  authorId?: Maybe<IntFilter>,
  /** Filter by the object’s `isPublic` field. */
  isPublic?: Maybe<BooleanFilter>,
  /** Filter by the object’s `mealId` field. */
  mealId?: Maybe<IntFilter>,
  /** Filter by the object’s `dayNumber` field. */
  dayNumber?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `timeRange` field. */
  timeRange?: Maybe<TimeRangeFilter>,
  /** Filter by the object’s `timeRangeIsStrict` field. */
  timeRangeIsStrict?: Maybe<BooleanFilter>,
  /** Filter by the object’s `position` field. */
  position?: Maybe<IntFilter>,
  /** Filter by the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MenuTemplateMealFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MenuTemplateMealFilter>>,
  /** Negates the expression. */
  not?: Maybe<MenuTemplateMealFilter>,
};

/** An input for mutations affecting `MenuTemplateMeal` */
export type MenuTemplateMealInput = {
  menuId: Scalars['Int'],
  mealtimeId?: Maybe<Scalars['Int']>,
  mealId?: Maybe<Scalars['Int']>,
  dayNumber?: Maybe<Scalars['Int']>,
  /** If unset, use the meal’s name, otherwise use this (e.g. to give a seasonal override to the meal name) */
  name?: Maybe<Scalars['String']>,
  timeRange?: Maybe<TimeRangeInput>,
  /** if false, timeRange is for guidance only, otherwise timeRange might be medically significant */
  timeRangeIsStrict?: Maybe<Scalars['Boolean']>,
  /** To update this, use moveMenuTemplateMeal */
  position?: Maybe<Scalars['Int']>,
};

/** Represents an update to a `MenuTemplateMeal`. Fields that are set will be updated. */
export type MenuTemplateMealPatch = {
  mealtimeId?: Maybe<Scalars['Int']>,
  mealId?: Maybe<Scalars['Int']>,
  dayNumber?: Maybe<Scalars['Int']>,
  /** If unset, use the meal’s name, otherwise use this (e.g. to give a seasonal override to the meal name) */
  name?: Maybe<Scalars['String']>,
  timeRange?: Maybe<TimeRangeInput>,
  /** if false, timeRange is for guidance only, otherwise timeRange might be medically significant */
  timeRangeIsStrict?: Maybe<Scalars['Boolean']>,
  /** To update this, use moveMenuTemplateMeal */
  position?: Maybe<Scalars['Int']>,
};

/** A connection to a list of `MenuTemplateMeal` values. */
export type MenuTemplateMealsConnection = {
   __typename?: 'MenuTemplateMealsConnection',
  /** A list of `MenuTemplateMeal` objects. */
  nodes: Array<MenuTemplateMeal>,
  /** A list of edges which contains the `MenuTemplateMeal` and cursor to aid in pagination. */
  edges: Array<MenuTemplateMealsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `MenuTemplateMeal` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `MenuTemplateMeal` edge in the connection. */
export type MenuTemplateMealsEdge = {
   __typename?: 'MenuTemplateMealsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `MenuTemplateMeal` at the end of the edge. */
  node: MenuTemplateMeal,
};

/** Methods to use when ordering `MenuTemplateMeal`. */
export enum MenuTemplateMealsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  MENU_ID_ASC = 'MENU_ID_ASC',
  MENU_ID_DESC = 'MENU_ID_DESC',
  MEALTIME_ID_ASC = 'MEALTIME_ID_ASC',
  MEALTIME_ID_DESC = 'MEALTIME_ID_DESC',
  AUTHOR_ID_ASC = 'AUTHOR_ID_ASC',
  AUTHOR_ID_DESC = 'AUTHOR_ID_DESC',
  IS_PUBLIC_ASC = 'IS_PUBLIC_ASC',
  IS_PUBLIC_DESC = 'IS_PUBLIC_DESC',
  MEAL_ID_ASC = 'MEAL_ID_ASC',
  MEAL_ID_DESC = 'MEAL_ID_DESC',
  DAY_NUMBER_ASC = 'DAY_NUMBER_ASC',
  DAY_NUMBER_DESC = 'DAY_NUMBER_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  TIME_RANGE_ASC = 'TIME_RANGE_ASC',
  TIME_RANGE_DESC = 'TIME_RANGE_DESC',
  TIME_RANGE_IS_STRICT_ASC = 'TIME_RANGE_IS_STRICT_ASC',
  TIME_RANGE_IS_STRICT_DESC = 'TIME_RANGE_IS_STRICT_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  MENU_TEMPLATE_MEAL_ID_ASC = 'MENU_TEMPLATE_MEAL_ID_ASC',
  MENU_TEMPLATE_MEAL_ID_DESC = 'MENU_TEMPLATE_MEAL_ID_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `moveMenuTemplateMeal` mutation. */
export type MoveMenuTemplateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  newDayNumber?: Maybe<Scalars['Int']>,
  newPosition?: Maybe<Scalars['Int']>,
};

/** The output of our `moveMenuTemplateMeal` mutation. */
export type MoveMenuTemplateMealPayload = {
   __typename?: 'MoveMenuTemplateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  menuTemplateMeal?: Maybe<MenuTemplateMeal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Menu` that is related to this `MenuTemplateMeal`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Mealtime` that is related to this `MenuTemplateMeal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `User` that is related to this `MenuTemplateMeal`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `MenuTemplateMeal`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `MenuTemplateMeal` that is related to this `MenuTemplateMeal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** An edge for our `MenuTemplateMeal`. May be used by Relay 1. */
  menuTemplateMealEdge?: Maybe<MenuTemplateMealsEdge>,
};


/** The output of our `moveMenuTemplateMeal` mutation. */
export type MoveMenuTemplateMealPayloadmenuTemplateMealEdgeArgs = {
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
   __typename?: 'Mutation',
  /** Creates a single `Consumable`. */
  createConsumable?: Maybe<CreateConsumablePayload>,
  /** Creates a single `MealConsumable`. */
  createMealConsumable?: Maybe<CreateMealConsumablePayload>,
  /** Creates a single `MealTag`. */
  createMealTag?: Maybe<CreateMealTagPayload>,
  /** Creates a single `Meal`. */
  createMeal?: Maybe<CreateMealPayload>,
  /** Creates a single `MenuTemplateMeal`. */
  createMenuTemplateMeal?: Maybe<CreateMenuTemplateMealPayload>,
  /** Creates a single `Menu`. */
  createMenu?: Maybe<CreateMenuPayload>,
  /** Creates a single `NutrientRange`. */
  createNutrientRange?: Maybe<CreateNutrientRangePayload>,
  /** Creates a single `Organization`. */
  createOrganization?: Maybe<CreateOrganizationPayload>,
  /** Creates a single `ProfileScheduledMealtime`. */
  createProfileScheduledMealtime?: Maybe<CreateProfileScheduledMealtimePayload>,
  /** Creates a single `Profile`. */
  createProfile?: Maybe<CreateProfilePayload>,
  /** Creates a single `Tag`. */
  createTag?: Maybe<CreateTagPayload>,
  /** Creates a single `UserDatum`. */
  createUserDatum?: Maybe<CreateUserDatumPayload>,
  /** Creates a single `UserRole`. */
  createUserRole?: Maybe<CreateUserRolePayload>,
  /** Updates a single `Consumable` using its globally unique id and a patch. */
  updateConsumable?: Maybe<UpdateConsumablePayload>,
  /** Updates a single `Consumable` using a unique key and a patch. */
  updateConsumableById?: Maybe<UpdateConsumablePayload>,
  /** Updates a single `Consumable` using a unique key and a patch. */
  updateConsumableBySourceAndIdentifier?: Maybe<UpdateConsumablePayload>,
  /** Updates a single `MealConsumable` using its globally unique id and a patch. */
  updateMealConsumable?: Maybe<UpdateMealConsumablePayload>,
  /** Updates a single `MealConsumable` using a unique key and a patch. */
  updateMealConsumableById?: Maybe<UpdateMealConsumablePayload>,
  /** Updates a single `Meal` using its globally unique id and a patch. */
  updateMeal?: Maybe<UpdateMealPayload>,
  /** Updates a single `Meal` using a unique key and a patch. */
  updateMealById?: Maybe<UpdateMealPayload>,
  /** Updates a single `MenuTemplateMeal` using its globally unique id and a patch. */
  updateMenuTemplateMeal?: Maybe<UpdateMenuTemplateMealPayload>,
  /** Updates a single `MenuTemplateMeal` using a unique key and a patch. */
  updateMenuTemplateMealById?: Maybe<UpdateMenuTemplateMealPayload>,
  /** Updates a single `Menu` using its globally unique id and a patch. */
  updateMenu?: Maybe<UpdateMenuPayload>,
  /** Updates a single `Menu` using a unique key and a patch. */
  updateMenuById?: Maybe<UpdateMenuPayload>,
  /** Updates a single `NutrientRange` using its globally unique id and a patch. */
  updateNutrientRange?: Maybe<UpdateNutrientRangePayload>,
  /** Updates a single `NutrientRange` using a unique key and a patch. */
  updateNutrientRangeById?: Maybe<UpdateNutrientRangePayload>,
  /** Updates a single `NutrientRange` using a unique key and a patch. */
  updateNutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientId?: Maybe<UpdateNutrientRangePayload>,
  /** Updates a single `Organization` using its globally unique id and a patch. */
  updateOrganization?: Maybe<UpdateOrganizationPayload>,
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganizationById?: Maybe<UpdateOrganizationPayload>,
  /** Updates a single `ProfileDatum` using its globally unique id and a patch. */
  updateProfileDatum?: Maybe<UpdateProfileDatumPayload>,
  /** Updates a single `ProfileDatum` using a unique key and a patch. */
  updateProfileDatumByProfileId?: Maybe<UpdateProfileDatumPayload>,
  /** Updates a single `ProfileScheduledMealtime` using its globally unique id and a patch. */
  updateProfileScheduledMealtime?: Maybe<UpdateProfileScheduledMealtimePayload>,
  /** Updates a single `ProfileScheduledMealtime` using a unique key and a patch. */
  updateProfileScheduledMealtimeById?: Maybe<UpdateProfileScheduledMealtimePayload>,
  /** Updates a single `Profile` using its globally unique id and a patch. */
  updateProfile?: Maybe<UpdateProfilePayload>,
  /** Updates a single `Profile` using a unique key and a patch. */
  updateProfileById?: Maybe<UpdateProfilePayload>,
  /** Updates a single `Profile` using a unique key and a patch. */
  updateProfileByOpenId?: Maybe<UpdateProfilePayload>,
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTag?: Maybe<UpdateTagPayload>,
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagById?: Maybe<UpdateTagPayload>,
  /** Updates a single `UserDatum` using its globally unique id and a patch. */
  updateUserDatum?: Maybe<UpdateUserDatumPayload>,
  /** Updates a single `UserDatum` using a unique key and a patch. */
  updateUserDatumByUserId?: Maybe<UpdateUserDatumPayload>,
  /** Updates a single `UserRole` using its globally unique id and a patch. */
  updateUserRole?: Maybe<UpdateUserRolePayload>,
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRoleById?: Maybe<UpdateUserRolePayload>,
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRoleByUserIdAndRoleId?: Maybe<UpdateUserRolePayload>,
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUser?: Maybe<UpdateUserPayload>,
  /** Updates a single `User` using a unique key and a patch. */
  updateUserById?: Maybe<UpdateUserPayload>,
  /** Deletes a single `Consumable` using its globally unique id. */
  deleteConsumable?: Maybe<DeleteConsumablePayload>,
  /** Deletes a single `Consumable` using a unique key. */
  deleteConsumableById?: Maybe<DeleteConsumablePayload>,
  /** Deletes a single `Consumable` using a unique key. */
  deleteConsumableBySourceAndIdentifier?: Maybe<DeleteConsumablePayload>,
  /** Deletes a single `MealConsumable` using its globally unique id. */
  deleteMealConsumable?: Maybe<DeleteMealConsumablePayload>,
  /** Deletes a single `MealConsumable` using a unique key. */
  deleteMealConsumableById?: Maybe<DeleteMealConsumablePayload>,
  /** Deletes a single `MealTag` using its globally unique id. */
  deleteMealTag?: Maybe<DeleteMealTagPayload>,
  /** Deletes a single `MealTag` using a unique key. */
  deleteMealTagByMealIdAndTagId?: Maybe<DeleteMealTagPayload>,
  /** Deletes a single `Meal` using its globally unique id. */
  deleteMeal?: Maybe<DeleteMealPayload>,
  /** Deletes a single `Meal` using a unique key. */
  deleteMealById?: Maybe<DeleteMealPayload>,
  /** Deletes a single `MenuTemplateMeal` using its globally unique id. */
  deleteMenuTemplateMeal?: Maybe<DeleteMenuTemplateMealPayload>,
  /** Deletes a single `MenuTemplateMeal` using a unique key. */
  deleteMenuTemplateMealById?: Maybe<DeleteMenuTemplateMealPayload>,
  /** Deletes a single `Menu` using its globally unique id. */
  deleteMenu?: Maybe<DeleteMenuPayload>,
  /** Deletes a single `Menu` using a unique key. */
  deleteMenuById?: Maybe<DeleteMenuPayload>,
  /** Deletes a single `Organization` using its globally unique id. */
  deleteOrganization?: Maybe<DeleteOrganizationPayload>,
  /** Deletes a single `Organization` using a unique key. */
  deleteOrganizationById?: Maybe<DeleteOrganizationPayload>,
  /** Deletes a single `ProfileDatum` using its globally unique id. */
  deleteProfileDatum?: Maybe<DeleteProfileDatumPayload>,
  /** Deletes a single `ProfileDatum` using a unique key. */
  deleteProfileDatumByProfileId?: Maybe<DeleteProfileDatumPayload>,
  /** Deletes a single `ProfileScheduledMealtime` using its globally unique id. */
  deleteProfileScheduledMealtime?: Maybe<DeleteProfileScheduledMealtimePayload>,
  /** Deletes a single `ProfileScheduledMealtime` using a unique key. */
  deleteProfileScheduledMealtimeById?: Maybe<DeleteProfileScheduledMealtimePayload>,
  /** Deletes a single `Profile` using its globally unique id. */
  deleteProfile?: Maybe<DeleteProfilePayload>,
  /** Deletes a single `Profile` using a unique key. */
  deleteProfileById?: Maybe<DeleteProfilePayload>,
  /** Deletes a single `Profile` using a unique key. */
  deleteProfileByOpenId?: Maybe<DeleteProfilePayload>,
  acceptProfileInvite?: Maybe<AcceptProfileInvitePayload>,
  applyMenuToProfile?: Maybe<ApplyMenuToProfilePayload>,
  applyMenuToProfiles?: Maybe<ApplyMenuToProfilesPayload>,
  consumableSetIngredients?: Maybe<ConsumableSetIngredientsPayload>,
  consumableVerify?: Maybe<ConsumableVerifyPayload>,
  createProfileInviteCode?: Maybe<CreateProfileInviteCodePayload>,
  deleteMenuDayRange?: Maybe<DeleteMenuDayRangePayload>,
  duplicateMenuDayRange?: Maybe<DuplicateMenuDayRangePayload>,
  forgotPassword?: Maybe<ForgotPasswordPayload>,
  moveMenuTemplateMeal?: Maybe<MoveMenuTemplateMealPayload>,
  publishMeal?: Maybe<PublishMealPayload>,
  resetPasswordForEmail?: Maybe<ResetPasswordForEmailPayload>,
  sendProfileInviteCode?: Maybe<SendProfileInviteCodePayload>,
  setMealTags?: Maybe<SetMealTagsPayload>,
  setMenu?: Maybe<SetMenuPayload>,
  setProfile?: Maybe<SetProfilePayload>,
  verifyEmail?: Maybe<VerifyEmailPayload>,
  /** Create a NutritionOrder record */
  createFHIRNutritionOrder?: Maybe<FHIRNutritionOrder>,
  /** Update a NutritionOrder record */
  updateFHIRNutritionOrder?: Maybe<FHIRNutritionOrder>,
  /** Remove a NutritionOrder record */
  deleteFHIRNutritionOrder?: Maybe<FHIRNutritionOrder>,
  createNutritionIntake?: Maybe<CreateNutritionIntakePayload>,
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateConsumableArgs = {
  input: CreateConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMealConsumableArgs = {
  input: CreateMealConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMealTagArgs = {
  input: CreateMealTagInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMealArgs = {
  input: CreateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMenuTemplateMealArgs = {
  input: CreateMenuTemplateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMenuArgs = {
  input: CreateMenuInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateNutrientRangeArgs = {
  input: CreateNutrientRangeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOrganizationArgs = {
  input: CreateOrganizationInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProfileScheduledMealtimeArgs = {
  input: CreateProfileScheduledMealtimeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProfileArgs = {
  input: CreateProfileInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTagArgs = {
  input: CreateTagInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUserDatumArgs = {
  input: CreateUserDatumInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUserRoleArgs = {
  input: CreateUserRoleInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateConsumableArgs = {
  input: UpdateConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateConsumableByIdArgs = {
  input: UpdateConsumableByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateConsumableBySourceAndIdentifierArgs = {
  input: UpdateConsumableBySourceAndIdentifierInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMealConsumableArgs = {
  input: UpdateMealConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMealConsumableByIdArgs = {
  input: UpdateMealConsumableByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMealArgs = {
  input: UpdateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMealByIdArgs = {
  input: UpdateMealByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMenuTemplateMealArgs = {
  input: UpdateMenuTemplateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMenuTemplateMealByIdArgs = {
  input: UpdateMenuTemplateMealByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMenuArgs = {
  input: UpdateMenuInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMenuByIdArgs = {
  input: UpdateMenuByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNutrientRangeArgs = {
  input: UpdateNutrientRangeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNutrientRangeByIdArgs = {
  input: UpdateNutrientRangeByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientIdArgs = {
  input: UpdateNutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrganizationArgs = {
  input: UpdateOrganizationInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrganizationByIdArgs = {
  input: UpdateOrganizationByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileDatumArgs = {
  input: UpdateProfileDatumInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileDatumByProfileIdArgs = {
  input: UpdateProfileDatumByProfileIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileScheduledMealtimeArgs = {
  input: UpdateProfileScheduledMealtimeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileScheduledMealtimeByIdArgs = {
  input: UpdateProfileScheduledMealtimeByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileArgs = {
  input: UpdateProfileInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileByIdArgs = {
  input: UpdateProfileByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProfileByOpenIdArgs = {
  input: UpdateProfileByOpenIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagArgs = {
  input: UpdateTagInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagByIdArgs = {
  input: UpdateTagByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserDatumArgs = {
  input: UpdateUserDatumInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserDatumByUserIdArgs = {
  input: UpdateUserDatumByUserIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserRoleArgs = {
  input: UpdateUserRoleInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserRoleByIdArgs = {
  input: UpdateUserRoleByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserRoleByUserIdAndRoleIdArgs = {
  input: UpdateUserRoleByUserIdAndRoleIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserArgs = {
  input: UpdateUserInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserByIdArgs = {
  input: UpdateUserByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteConsumableArgs = {
  input: DeleteConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteConsumableByIdArgs = {
  input: DeleteConsumableByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteConsumableBySourceAndIdentifierArgs = {
  input: DeleteConsumableBySourceAndIdentifierInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealConsumableArgs = {
  input: DeleteMealConsumableInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealConsumableByIdArgs = {
  input: DeleteMealConsumableByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealTagArgs = {
  input: DeleteMealTagInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealTagByMealIdAndTagIdArgs = {
  input: DeleteMealTagByMealIdAndTagIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealArgs = {
  input: DeleteMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMealByIdArgs = {
  input: DeleteMealByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMenuTemplateMealArgs = {
  input: DeleteMenuTemplateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMenuTemplateMealByIdArgs = {
  input: DeleteMenuTemplateMealByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMenuArgs = {
  input: DeleteMenuInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMenuByIdArgs = {
  input: DeleteMenuByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrganizationArgs = {
  input: DeleteOrganizationInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrganizationByIdArgs = {
  input: DeleteOrganizationByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileDatumArgs = {
  input: DeleteProfileDatumInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileDatumByProfileIdArgs = {
  input: DeleteProfileDatumByProfileIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileScheduledMealtimeArgs = {
  input: DeleteProfileScheduledMealtimeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileScheduledMealtimeByIdArgs = {
  input: DeleteProfileScheduledMealtimeByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileArgs = {
  input: DeleteProfileInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileByIdArgs = {
  input: DeleteProfileByIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProfileByOpenIdArgs = {
  input: DeleteProfileByOpenIdInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationacceptProfileInviteArgs = {
  input: AcceptProfileInviteInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationapplyMenuToProfileArgs = {
  input: ApplyMenuToProfileInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationapplyMenuToProfilesArgs = {
  input: ApplyMenuToProfilesInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationconsumableSetIngredientsArgs = {
  input: ConsumableSetIngredientsInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationconsumableVerifyArgs = {
  input: ConsumableVerifyInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProfileInviteCodeArgs = {
  input: CreateProfileInviteCodeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMenuDayRangeArgs = {
  input: DeleteMenuDayRangeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationduplicateMenuDayRangeArgs = {
  input: DuplicateMenuDayRangeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationforgotPasswordArgs = {
  input: ForgotPasswordInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationmoveMenuTemplateMealArgs = {
  input: MoveMenuTemplateMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationpublishMealArgs = {
  input: PublishMealInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationresetPasswordForEmailArgs = {
  input: ResetPasswordForEmailInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationsendProfileInviteCodeArgs = {
  input: SendProfileInviteCodeInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationsetMealTagsArgs = {
  input: SetMealTagsInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationsetMenuArgs = {
  input: SetMenuInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationsetProfileArgs = {
  input: SetProfileInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationverifyEmailArgs = {
  input: VerifyEmailInput
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateFHIRNutritionOrderArgs = {
  id?: Maybe<Scalars['FHIRId']>,
  resource: FHIRNutritionOrder_Input
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateFHIRNutritionOrderArgs = {
  id?: Maybe<Scalars['FHIRId']>,
  resource: FHIRNutritionOrder_Input
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteFHIRNutritionOrderArgs = {
  id: Scalars['FHIRId']
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateNutritionIntakeArgs = {
  input: CreateNutritionIntakeInput
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
};

export type Nutrient = Node & {
   __typename?: 'Nutrient',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  source: Scalars['String'],
  identifier: Scalars['String'],
  name: Scalars['String'],
  group: Scalars['String'],
  unit: Scalars['String'],
  supplementId?: Maybe<Scalars['String']>,
  nutrientNbr?: Maybe<Scalars['Float']>,
  sourceMeta: Scalars['JSON'],
  categoryId?: Maybe<Scalars['Int']>,
  category1Id?: Maybe<Scalars['Int']>,
  category2Id?: Maybe<Scalars['Int']>,
  category3Id?: Maybe<Scalars['Int']>,
  category4Id?: Maybe<Scalars['Int']>,
  category5Id?: Maybe<Scalars['Int']>,
  category6Id?: Maybe<Scalars['Int']>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategoryId?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory1Id?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory2Id?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory3Id?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory4Id?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory5Id?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientCategory` that is related to this `Nutrient`. */
  nutrientCategoryByCategory6Id?: Maybe<NutrientCategory>,
  /** Reads and enables pagination through a set of `ConsumableNutrient`. */
  consumableNutrientsByNutrientId: ConsumableNutrientsConnection,
  /** Reads and enables pagination through a set of `MealNutrient`. */
  mealNutrientsByNutrientId: MealNutrientsConnection,
  /** Reads and enables pagination through a set of `MenuNutrientStatistic`. */
  menuNutrientStatisticsByNutrientId: MenuNutrientStatisticsConnection,
  /** Reads and enables pagination through a set of `NutrientRange`. */
  nutrientRangesByNutrientId: NutrientRangesConnection,
};


export type NutrientconsumableNutrientsByNutrientIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableNutrientsOrderBy>>,
  condition?: Maybe<ConsumableNutrientCondition>,
  filter?: Maybe<ConsumableNutrientFilter>
};


export type NutrientmealNutrientsByNutrientIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealNutrientsOrderBy>>,
  condition?: Maybe<MealNutrientCondition>,
  filter?: Maybe<MealNutrientFilter>
};


export type NutrientmenuNutrientStatisticsByNutrientIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuNutrientStatisticsOrderBy>>,
  condition?: Maybe<MenuNutrientStatisticCondition>,
  filter?: Maybe<MenuNutrientStatisticFilter>
};


export type NutrientnutrientRangesByNutrientIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientRangesOrderBy>>,
  condition?: Maybe<NutrientRangeCondition>,
  filter?: Maybe<NutrientRangeFilter>
};

/** A connection to a list of `NutrientCategory` values. */
export type NutrientCategoriesConnection = {
   __typename?: 'NutrientCategoriesConnection',
  /** A list of `NutrientCategory` objects. */
  nodes: Array<NutrientCategory>,
  /** A list of edges which contains the `NutrientCategory` and cursor to aid in pagination. */
  edges: Array<NutrientCategoriesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `NutrientCategory` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `NutrientCategory` edge in the connection. */
export type NutrientCategoriesEdge = {
   __typename?: 'NutrientCategoriesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `NutrientCategory` at the end of the edge. */
  node: NutrientCategory,
};

/** Methods to use when ordering `NutrientCategory`. */
export enum NutrientCategoriesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  OLD_ID_ASC = 'OLD_ID_ASC',
  OLD_ID_DESC = 'OLD_ID_DESC',
  PARENT_ID_ASC = 'PARENT_ID_ASC',
  PARENT_ID_DESC = 'PARENT_ID_DESC',
  LEVEL_ASC = 'LEVEL_ASC',
  LEVEL_DESC = 'LEVEL_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  DESCRIPTION_ASC = 'DESCRIPTION_ASC',
  DESCRIPTION_DESC = 'DESCRIPTION_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type NutrientCategory = Node & {
   __typename?: 'NutrientCategory',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  oldId?: Maybe<Scalars['Int']>,
  parentId?: Maybe<Scalars['Int']>,
  level: Scalars['Int'],
  name: Scalars['String'],
  description?: Maybe<Scalars['String']>,
  /** Reads a single `NutrientCategory` that is related to this `NutrientCategory`. */
  nutrientCategoryByParentId?: Maybe<NutrientCategory>,
  /** Reads and enables pagination through a set of `NutrientCategory`. */
  nutrientCategoriesByParentId: NutrientCategoriesConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategoryId: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory1Id: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory2Id: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory3Id: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory4Id: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory5Id: NutrientsConnection,
  /** Reads and enables pagination through a set of `Nutrient`. */
  nutrientsByCategory6Id: NutrientsConnection,
};


export type NutrientCategorynutrientCategoriesByParentIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientCategoriesOrderBy>>,
  condition?: Maybe<NutrientCategoryCondition>,
  filter?: Maybe<NutrientCategoryFilter>
};


export type NutrientCategorynutrientsByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory1IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory2IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory3IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory4IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory5IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


export type NutrientCategorynutrientsByCategory6IdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};

/** 
 * A condition to be used against `NutrientCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NutrientCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `oldId` field. */
  oldId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `level` field. */
  level?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>,
};

/** A filter to be used against `NutrientCategory` object types. All fields are combined with a logical ‘and.’ */
export type NutrientCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `oldId` field. */
  oldId?: Maybe<IntFilter>,
  /** Filter by the object’s `parentId` field. */
  parentId?: Maybe<IntFilter>,
  /** Filter by the object’s `level` field. */
  level?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NutrientCategoryFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NutrientCategoryFilter>>,
  /** Negates the expression. */
  not?: Maybe<NutrientCategoryFilter>,
};

/** 
 * A condition to be used against `Nutrient` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NutrientCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `group` field. */
  group?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `unit` field. */
  unit?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `supplementId` field. */
  supplementId?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `nutrientNbr` field. */
  nutrientNbr?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<Scalars['JSON']>,
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category1Id` field. */
  category1Id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category2Id` field. */
  category2Id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category3Id` field. */
  category3Id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category4Id` field. */
  category4Id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category5Id` field. */
  category5Id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `category6Id` field. */
  category6Id?: Maybe<Scalars['Int']>,
};

/** A filter to be used against `Nutrient` object types. All fields are combined with a logical ‘and.’ */
export type NutrientFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>,
  /** Filter by the object’s `identifier` field. */
  identifier?: Maybe<StringFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `group` field. */
  group?: Maybe<StringFilter>,
  /** Filter by the object’s `unit` field. */
  unit?: Maybe<StringFilter>,
  /** Filter by the object’s `supplementId` field. */
  supplementId?: Maybe<StringFilter>,
  /** Filter by the object’s `nutrientNbr` field. */
  nutrientNbr?: Maybe<FloatFilter>,
  /** Filter by the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<JSONFilter>,
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<IntFilter>,
  /** Filter by the object’s `category1Id` field. */
  category1Id?: Maybe<IntFilter>,
  /** Filter by the object’s `category2Id` field. */
  category2Id?: Maybe<IntFilter>,
  /** Filter by the object’s `category3Id` field. */
  category3Id?: Maybe<IntFilter>,
  /** Filter by the object’s `category4Id` field. */
  category4Id?: Maybe<IntFilter>,
  /** Filter by the object’s `category5Id` field. */
  category5Id?: Maybe<IntFilter>,
  /** Filter by the object’s `category6Id` field. */
  category6Id?: Maybe<IntFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NutrientFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NutrientFilter>>,
  /** Negates the expression. */
  not?: Maybe<NutrientFilter>,
};

export type NutrientRange = Node & {
   __typename?: 'NutrientRange',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['String'],
  snomedCid?: Maybe<Scalars['String']>,
  gender?: Maybe<Gender>,
  ageLowerMonths?: Maybe<Scalars['Int']>,
  ageUpperMonths?: Maybe<Scalars['Int']>,
  nutrientId?: Maybe<Scalars['Int']>,
  nutrientLower?: Maybe<Scalars['Float']>,
  nutrientUpper?: Maybe<Scalars['Float']>,
  /** Reads a single `SnomedProblemList` that is related to this `NutrientRange`. */
  snomedProblemListBySnomedCid?: Maybe<SnomedProblemList>,
  /** Reads a single `Nutrient` that is related to this `NutrientRange`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
};

/** 
 * A condition to be used against `NutrientRange` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NutrientRangeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `snomedCid` field. */
  snomedCid?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Gender>,
  /** Checks for equality with the object’s `ageLowerMonths` field. */
  ageLowerMonths?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `ageUpperMonths` field. */
  ageUpperMonths?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `nutrientId` field. */
  nutrientId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `nutrientLower` field. */
  nutrientLower?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `nutrientUpper` field. */
  nutrientUpper?: Maybe<Scalars['Float']>,
};

/** A filter to be used against `NutrientRange` object types. All fields are combined with a logical ‘and.’ */
export type NutrientRangeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>,
  /** Filter by the object’s `snomedCid` field. */
  snomedCid?: Maybe<StringFilter>,
  /** Filter by the object’s `gender` field. */
  gender?: Maybe<GenderFilter>,
  /** Filter by the object’s `ageLowerMonths` field. */
  ageLowerMonths?: Maybe<IntFilter>,
  /** Filter by the object’s `ageUpperMonths` field. */
  ageUpperMonths?: Maybe<IntFilter>,
  /** Filter by the object’s `nutrientId` field. */
  nutrientId?: Maybe<IntFilter>,
  /** Filter by the object’s `nutrientLower` field. */
  nutrientLower?: Maybe<FloatFilter>,
  /** Filter by the object’s `nutrientUpper` field. */
  nutrientUpper?: Maybe<FloatFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NutrientRangeFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NutrientRangeFilter>>,
  /** Negates the expression. */
  not?: Maybe<NutrientRangeFilter>,
};

/** An input for mutations affecting `NutrientRange` */
export type NutrientRangeInput = {
  snomedCid?: Maybe<Scalars['String']>,
  gender?: Maybe<Gender>,
  ageLowerMonths?: Maybe<Scalars['Int']>,
  ageUpperMonths?: Maybe<Scalars['Int']>,
  nutrientId?: Maybe<Scalars['Int']>,
  nutrientLower?: Maybe<Scalars['Float']>,
  nutrientUpper?: Maybe<Scalars['Float']>,
};

/** Represents an update to a `NutrientRange`. Fields that are set will be updated. */
export type NutrientRangePatch = {
  snomedCid?: Maybe<Scalars['String']>,
  gender?: Maybe<Gender>,
  ageLowerMonths?: Maybe<Scalars['Int']>,
  ageUpperMonths?: Maybe<Scalars['Int']>,
  nutrientId?: Maybe<Scalars['Int']>,
  nutrientLower?: Maybe<Scalars['Float']>,
  nutrientUpper?: Maybe<Scalars['Float']>,
};

/** A connection to a list of `NutrientRange` values. */
export type NutrientRangesConnection = {
   __typename?: 'NutrientRangesConnection',
  /** A list of `NutrientRange` objects. */
  nodes: Array<NutrientRange>,
  /** A list of edges which contains the `NutrientRange` and cursor to aid in pagination. */
  edges: Array<NutrientRangesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `NutrientRange` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `NutrientRange` edge in the connection. */
export type NutrientRangesEdge = {
   __typename?: 'NutrientRangesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `NutrientRange` at the end of the edge. */
  node: NutrientRange,
};

/** Methods to use when ordering `NutrientRange`. */
export enum NutrientRangesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  SNOMED_CID_ASC = 'SNOMED_CID_ASC',
  SNOMED_CID_DESC = 'SNOMED_CID_DESC',
  GENDER_ASC = 'GENDER_ASC',
  GENDER_DESC = 'GENDER_DESC',
  AGE_LOWER_MONTHS_ASC = 'AGE_LOWER_MONTHS_ASC',
  AGE_LOWER_MONTHS_DESC = 'AGE_LOWER_MONTHS_DESC',
  AGE_UPPER_MONTHS_ASC = 'AGE_UPPER_MONTHS_ASC',
  AGE_UPPER_MONTHS_DESC = 'AGE_UPPER_MONTHS_DESC',
  NUTRIENT_ID_ASC = 'NUTRIENT_ID_ASC',
  NUTRIENT_ID_DESC = 'NUTRIENT_ID_DESC',
  NUTRIENT_LOWER_ASC = 'NUTRIENT_LOWER_ASC',
  NUTRIENT_LOWER_DESC = 'NUTRIENT_LOWER_DESC',
  NUTRIENT_UPPER_ASC = 'NUTRIENT_UPPER_ASC',
  NUTRIENT_UPPER_DESC = 'NUTRIENT_UPPER_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Nutrient` values. */
export type NutrientsConnection = {
   __typename?: 'NutrientsConnection',
  /** A list of `Nutrient` objects. */
  nodes: Array<Nutrient>,
  /** A list of edges which contains the `Nutrient` and cursor to aid in pagination. */
  edges: Array<NutrientsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Nutrient` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Nutrient` edge in the connection. */
export type NutrientsEdge = {
   __typename?: 'NutrientsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Nutrient` at the end of the edge. */
  node: Nutrient,
};

export type NutrientsMap = Node & {
   __typename?: 'NutrientsMap',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  source: Scalars['String'],
  identifier: Scalars['String'],
  name: Scalars['String'],
  group: Scalars['String'],
  unit: Scalars['String'],
  supplementId?: Maybe<Scalars['String']>,
  nutrientNbr?: Maybe<Scalars['Float']>,
  sourceMeta: Scalars['JSON'],
};

/** 
 * A condition to be used against `NutrientsMap` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NutrientsMapCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `group` field. */
  group?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `unit` field. */
  unit?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `supplementId` field. */
  supplementId?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `nutrientNbr` field. */
  nutrientNbr?: Maybe<Scalars['Float']>,
  /** Checks for equality with the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<Scalars['JSON']>,
};

/** A filter to be used against `NutrientsMap` object types. All fields are combined with a logical ‘and.’ */
export type NutrientsMapFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>,
  /** Filter by the object’s `identifier` field. */
  identifier?: Maybe<StringFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `group` field. */
  group?: Maybe<StringFilter>,
  /** Filter by the object’s `unit` field. */
  unit?: Maybe<StringFilter>,
  /** Filter by the object’s `supplementId` field. */
  supplementId?: Maybe<StringFilter>,
  /** Filter by the object’s `nutrientNbr` field. */
  nutrientNbr?: Maybe<FloatFilter>,
  /** Filter by the object’s `sourceMeta` field. */
  sourceMeta?: Maybe<JSONFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NutrientsMapFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NutrientsMapFilter>>,
  /** Negates the expression. */
  not?: Maybe<NutrientsMapFilter>,
};

/** A connection to a list of `NutrientsMap` values. */
export type NutrientsMapsConnection = {
   __typename?: 'NutrientsMapsConnection',
  /** A list of `NutrientsMap` objects. */
  nodes: Array<NutrientsMap>,
  /** A list of edges which contains the `NutrientsMap` and cursor to aid in pagination. */
  edges: Array<NutrientsMapsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `NutrientsMap` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `NutrientsMap` edge in the connection. */
export type NutrientsMapsEdge = {
   __typename?: 'NutrientsMapsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `NutrientsMap` at the end of the edge. */
  node: NutrientsMap,
};

/** Methods to use when ordering `NutrientsMap`. */
export enum NutrientsMapsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  SOURCE_ASC = 'SOURCE_ASC',
  SOURCE_DESC = 'SOURCE_DESC',
  IDENTIFIER_ASC = 'IDENTIFIER_ASC',
  IDENTIFIER_DESC = 'IDENTIFIER_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  GROUP_ASC = 'GROUP_ASC',
  GROUP_DESC = 'GROUP_DESC',
  UNIT_ASC = 'UNIT_ASC',
  UNIT_DESC = 'UNIT_DESC',
  SUPPLEMENT_ID_ASC = 'SUPPLEMENT_ID_ASC',
  SUPPLEMENT_ID_DESC = 'SUPPLEMENT_ID_DESC',
  NUTRIENT_NBR_ASC = 'NUTRIENT_NBR_ASC',
  NUTRIENT_NBR_DESC = 'NUTRIENT_NBR_DESC',
  SOURCE_META_ASC = 'SOURCE_META_ASC',
  SOURCE_META_DESC = 'SOURCE_META_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `Nutrient`. */
export enum NutrientsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  SOURCE_ASC = 'SOURCE_ASC',
  SOURCE_DESC = 'SOURCE_DESC',
  IDENTIFIER_ASC = 'IDENTIFIER_ASC',
  IDENTIFIER_DESC = 'IDENTIFIER_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  GROUP_ASC = 'GROUP_ASC',
  GROUP_DESC = 'GROUP_DESC',
  UNIT_ASC = 'UNIT_ASC',
  UNIT_DESC = 'UNIT_DESC',
  SUPPLEMENT_ID_ASC = 'SUPPLEMENT_ID_ASC',
  SUPPLEMENT_ID_DESC = 'SUPPLEMENT_ID_DESC',
  NUTRIENT_NBR_ASC = 'NUTRIENT_NBR_ASC',
  NUTRIENT_NBR_DESC = 'NUTRIENT_NBR_DESC',
  SOURCE_META_ASC = 'SOURCE_META_ASC',
  SOURCE_META_DESC = 'SOURCE_META_DESC',
  CATEGORY_ID_ASC = 'CATEGORY_ID_ASC',
  CATEGORY_ID_DESC = 'CATEGORY_ID_DESC',
  CATEGORY1_ID_ASC = 'CATEGORY1_ID_ASC',
  CATEGORY1_ID_DESC = 'CATEGORY1_ID_DESC',
  CATEGORY2_ID_ASC = 'CATEGORY2_ID_ASC',
  CATEGORY2_ID_DESC = 'CATEGORY2_ID_DESC',
  CATEGORY3_ID_ASC = 'CATEGORY3_ID_ASC',
  CATEGORY3_ID_DESC = 'CATEGORY3_ID_DESC',
  CATEGORY4_ID_ASC = 'CATEGORY4_ID_ASC',
  CATEGORY4_ID_DESC = 'CATEGORY4_ID_DESC',
  CATEGORY5_ID_ASC = 'CATEGORY5_ID_ASC',
  CATEGORY5_ID_DESC = 'CATEGORY5_ID_DESC',
  CATEGORY6_ID_ASC = 'CATEGORY6_ID_ASC',
  CATEGORY6_ID_DESC = 'CATEGORY6_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** This type doesn't really exist */
export type NutrientValue = {
   __typename?: 'NutrientValue',
  nutrientId: Scalars['Int'],
  valueInNutrientUnits: Scalars['Float'],
  /** Reads a single `Nutrient` that is related to this `NutrientValue`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
};

/** 
 * A condition to be used against `NutrientValue` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NutrientValueCondition = {
  /** Checks for equality with the object’s `nutrientId` field. */
  nutrientId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `valueInNutrientUnits` field. */
  valueInNutrientUnits?: Maybe<Scalars['Float']>,
};

/** A filter to be used against `NutrientValue` object types. All fields are combined with a logical ‘and.’ */
export type NutrientValueFilter = {
  /** Filter by the object’s `nutrientId` field. */
  nutrientId?: Maybe<IntFilter>,
  /** Filter by the object’s `valueInNutrientUnits` field. */
  valueInNutrientUnits?: Maybe<FloatFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NutrientValueFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NutrientValueFilter>>,
  /** Negates the expression. */
  not?: Maybe<NutrientValueFilter>,
};

/** A connection to a list of `NutrientValue` values. */
export type NutrientValuesConnection = {
   __typename?: 'NutrientValuesConnection',
  /** A list of `NutrientValue` objects. */
  nodes: Array<NutrientValue>,
  /** A list of edges which contains the `NutrientValue` and cursor to aid in pagination. */
  edges: Array<NutrientValuesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `NutrientValue` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `NutrientValue` edge in the connection. */
export type NutrientValuesEdge = {
   __typename?: 'NutrientValuesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `NutrientValue` at the end of the edge. */
  node: NutrientValue,
};

export type NutritionIntake = {
   __typename?: 'NutritionIntake',
  id?: Maybe<Scalars['FHIRId']>,
  patient?: Maybe<FHIRPatient>,
  meta?: Maybe<FHIRMeta>,
  status?: Maybe<Scalars['FHIRCode']>,
};

export type NutritionIntakeList = {
   __typename?: 'NutritionIntakeList',
  nodes?: Maybe<Array<Maybe<NutritionIntake>>>,
  listInfo?: Maybe<FHIRListInfo>,
};

export type Organization = Node & {
   __typename?: 'Organization',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  fhirIdentifier?: Maybe<Scalars['String']>,
  fhirType?: Maybe<Scalars['String']>,
  name: Scalars['String'],
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  organizationUsersByOrganizationId: OrganizationUsersConnection,
  /** Reads and enables pagination through a set of `Profile`. */
  profilesByOrganizationId: ProfilesConnection,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  profileOrganizationsByOrganizationId: ProfileOrganizationsConnection,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  profileOrganizationsByProfileOrganizationId: ProfileOrganizationsConnection,
  /** Reads and enables pagination through a set of `ProfileDatum`. */
  profileDataByOrganizationId: ProfileDataConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByOrganizationId: ProfileScheduledMealtimesConnection,
};


export type OrganizationorganizationUsersByOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<OrganizationUsersOrderBy>>,
  condition?: Maybe<OrganizationUserCondition>,
  filter?: Maybe<OrganizationUserFilter>
};


export type OrganizationprofilesByOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfilesOrderBy>>,
  condition?: Maybe<ProfileCondition>,
  filter?: Maybe<ProfileFilter>
};


export type OrganizationprofileOrganizationsByOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


export type OrganizationprofileOrganizationsByProfileOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


export type OrganizationprofileDataByOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileDataOrderBy>>,
  condition?: Maybe<ProfileDatumCondition>,
  filter?: Maybe<ProfileDatumFilter>
};


export type OrganizationprofileScheduledMealtimesByOrganizationIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** 
 * A condition to be used against `Organization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `fhirIdentifier` field. */
  fhirIdentifier?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `fhirType` field. */
  fhirType?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `fhirIdentifier` field. */
  fhirIdentifier?: Maybe<StringFilter>,
  /** Filter by the object’s `fhirType` field. */
  fhirType?: Maybe<StringFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrganizationFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrganizationFilter>>,
  /** Negates the expression. */
  not?: Maybe<OrganizationFilter>,
};

/** An input for mutations affecting `Organization` */
export type OrganizationInput = {
  name: Scalars['String'],
};

/** Represents an update to a `Organization`. Fields that are set will be updated. */
export type OrganizationPatch = {
  name?: Maybe<Scalars['String']>,
};

/** A connection to a list of `Organization` values. */
export type OrganizationsConnection = {
   __typename?: 'OrganizationsConnection',
  /** A list of `Organization` objects. */
  nodes: Array<Organization>,
  /** A list of edges which contains the `Organization` and cursor to aid in pagination. */
  edges: Array<OrganizationsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Organization` edge in the connection. */
export type OrganizationsEdge = {
   __typename?: 'OrganizationsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Organization` at the end of the edge. */
  node: Organization,
};

/** Methods to use when ordering `Organization`. */
export enum OrganizationsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  FHIR_IDENTIFIER_ASC = 'FHIR_IDENTIFIER_ASC',
  FHIR_IDENTIFIER_DESC = 'FHIR_IDENTIFIER_DESC',
  FHIR_TYPE_ASC = 'FHIR_TYPE_ASC',
  FHIR_TYPE_DESC = 'FHIR_TYPE_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type OrganizationUser = Node & {
   __typename?: 'OrganizationUser',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  organizationId: Scalars['Int'],
  userId: Scalars['Int'],
  permissions: Scalars['Int'],
  owner: Scalars['Boolean'],
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `Organization` that is related to this `OrganizationUser`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `OrganizationUser`. */
  userByUserId?: Maybe<User>,
};

/** 
 * A condition to be used against `OrganizationUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationUserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `permissions` field. */
  permissions?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `owner` field. */
  owner?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `OrganizationUser` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationUserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `organizationId` field. */
  organizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `permissions` field. */
  permissions?: Maybe<IntFilter>,
  /** Filter by the object’s `owner` field. */
  owner?: Maybe<BooleanFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrganizationUserFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrganizationUserFilter>>,
  /** Negates the expression. */
  not?: Maybe<OrganizationUserFilter>,
};

/** A connection to a list of `OrganizationUser` values. */
export type OrganizationUsersConnection = {
   __typename?: 'OrganizationUsersConnection',
  /** A list of `OrganizationUser` objects. */
  nodes: Array<OrganizationUser>,
  /** A list of edges which contains the `OrganizationUser` and cursor to aid in pagination. */
  edges: Array<OrganizationUsersEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `OrganizationUser` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `OrganizationUser` edge in the connection. */
export type OrganizationUsersEdge = {
   __typename?: 'OrganizationUsersEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `OrganizationUser` at the end of the edge. */
  node: OrganizationUser,
};

/** Methods to use when ordering `OrganizationUser`. */
export enum OrganizationUsersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  ORGANIZATION_ID_ASC = 'ORGANIZATION_ID_ASC',
  ORGANIZATION_ID_DESC = 'ORGANIZATION_ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  PERMISSIONS_ASC = 'PERMISSIONS_ASC',
  PERMISSIONS_DESC = 'PERMISSIONS_DESC',
  OWNER_ASC = 'OWNER_ASC',
  OWNER_DESC = 'OWNER_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
   __typename?: 'PageInfo',
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'],
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'],
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>,
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>,
};

export enum PractitionerStatus {
  PENDING_APPLICATION = 'PENDING_APPLICATION',
  PENDING_REVIEW = 'PENDING_REVIEW',
  APPROVED = 'APPROVED',
  DECLINED = 'DECLINED',
  REVOKED = 'REVOKED'
}

export type Profile = Node & {
   __typename?: 'Profile',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  userId?: Maybe<Scalars['Int']>,
  organizationId: Scalars['Int'],
  openId?: Maybe<Scalars['String']>,
  fullUrl?: Maybe<Scalars['String']>,
  prefixName?: Maybe<Scalars['String']>,
  givenName?: Maybe<Scalars['String']>,
  familyName?: Maybe<Scalars['String']>,
  suffixName?: Maybe<Scalars['String']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  profileOrganizationsByProfileId: ProfileOrganizationsConnection,
  /** Reads and enables pagination through a set of `Menu`. */
  menusByProfileId: MenusConnection,
  /** Reads a single `ProfileDatum` that is related to this `Profile`. */
  profileDatumByProfileId?: Maybe<ProfileDatum>,
  /** Reads and enables pagination through a set of `ProfileDatum`. */
  profileDataByProfileId: ProfileDataConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByProfileId: ProfileScheduledMealtimesConnection,
  /** Reads and enables pagination through a set of `Menu`. */
  scheduledMenus: MenusConnection,
};


export type ProfileprofileOrganizationsByProfileIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


export type ProfilemenusByProfileIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenusOrderBy>>,
  condition?: Maybe<MenuCondition>,
  filter?: Maybe<MenuFilter>
};


export type ProfileprofileDataByProfileIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileDataOrderBy>>,
  condition?: Maybe<ProfileDatumCondition>,
  filter?: Maybe<ProfileDatumFilter>
};


export type ProfileprofileScheduledMealtimesByProfileIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};


export type ProfilescheduledMenusArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<MenuFilter>,
  condition?: Maybe<MenuCondition>
};

/** A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProfileCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `openId` field. */
  openId?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `fullUrl` field. */
  fullUrl?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `prefixName` field. */
  prefixName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `givenName` field. */
  givenName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `familyName` field. */
  familyName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `suffixName` field. */
  suffixName?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
  /** Filters the profiles to only those matching this search string. */
  search?: Maybe<Scalars['String']>,
};

/** A connection to a list of `ProfileDatum` values. */
export type ProfileDataConnection = {
   __typename?: 'ProfileDataConnection',
  /** A list of `ProfileDatum` objects. */
  nodes: Array<ProfileDatum>,
  /** A list of edges which contains the `ProfileDatum` and cursor to aid in pagination. */
  edges: Array<ProfileDataEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ProfileDatum` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ProfileDatum` edge in the connection. */
export type ProfileDataEdge = {
   __typename?: 'ProfileDataEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ProfileDatum` at the end of the edge. */
  node: ProfileDatum,
};

/** Methods to use when ordering `ProfileDatum`. */
export enum ProfileDataOrderBy {
  NATURAL = 'NATURAL',
  PROFILE_ID_ASC = 'PROFILE_ID_ASC',
  PROFILE_ID_DESC = 'PROFILE_ID_DESC',
  ORGANIZATION_ID_ASC = 'ORGANIZATION_ID_ASC',
  ORGANIZATION_ID_DESC = 'ORGANIZATION_ID_DESC',
  GENDER_ASC = 'GENDER_ASC',
  GENDER_DESC = 'GENDER_DESC',
  BIRTHDATE_ASC = 'BIRTHDATE_ASC',
  BIRTHDATE_DESC = 'BIRTHDATE_DESC',
  LINE_ASC = 'LINE_ASC',
  LINE_DESC = 'LINE_DESC',
  CITY_ASC = 'CITY_ASC',
  CITY_DESC = 'CITY_DESC',
  DISTRICT_ASC = 'DISTRICT_ASC',
  DISTRICT_DESC = 'DISTRICT_DESC',
  STATE_ASC = 'STATE_ASC',
  STATE_DESC = 'STATE_DESC',
  POSTAL_CODE_ASC = 'POSTAL_CODE_ASC',
  POSTAL_CODE_DESC = 'POSTAL_CODE_DESC',
  COUNTRY_ASC = 'COUNTRY_ASC',
  COUNTRY_DESC = 'COUNTRY_DESC',
  EMAIL_ASC = 'EMAIL_ASC',
  EMAIL_DESC = 'EMAIL_DESC',
  LIKES_ASC = 'LIKES_ASC',
  LIKES_DESC = 'LIKES_DESC',
  DISLIKES_ASC = 'DISLIKES_ASC',
  DISLIKES_DESC = 'DISLIKES_DESC',
  ALLERGIES_ASC = 'ALLERGIES_ASC',
  ALLERGIES_DESC = 'ALLERGIES_DESC',
  INTOLERANCES_ASC = 'INTOLERANCES_ASC',
  INTOLERANCES_DESC = 'INTOLERANCES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ProfileDatum = Node & {
   __typename?: 'ProfileDatum',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  profileId: Scalars['Int'],
  organizationId: Scalars['Int'],
  gender?: Maybe<Gender>,
  birthdate?: Maybe<Scalars['Datetime']>,
  line?: Maybe<Scalars['String']>,
  city?: Maybe<Scalars['String']>,
  district?: Maybe<Scalars['String']>,
  state?: Maybe<Scalars['String']>,
  postalCode?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  likes?: Maybe<Array<Maybe<Scalars['String']>>>,
  dislikes?: Maybe<Array<Maybe<Scalars['String']>>>,
  allergies?: Maybe<Array<Maybe<Scalars['String']>>>,
  intolerances?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Reads a single `Profile` that is related to this `ProfileDatum`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `Organization` that is related to this `ProfileDatum`. */
  organizationByOrganizationId?: Maybe<Organization>,
};

/** 
 * A condition to be used against `ProfileDatum` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProfileDatumCondition = {
  /** Checks for equality with the object’s `profileId` field. */
  profileId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Gender>,
  /** Checks for equality with the object’s `birthdate` field. */
  birthdate?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `line` field. */
  line?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `district` field. */
  district?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `state` field. */
  state?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `postalCode` field. */
  postalCode?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `country` field. */
  country?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `likes` field. */
  likes?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Checks for equality with the object’s `dislikes` field. */
  dislikes?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Checks for equality with the object’s `allergies` field. */
  allergies?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Checks for equality with the object’s `intolerances` field. */
  intolerances?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** A filter to be used against `ProfileDatum` object types. All fields are combined with a logical ‘and.’ */
export type ProfileDatumFilter = {
  /** Filter by the object’s `profileId` field. */
  profileId?: Maybe<IntFilter>,
  /** Filter by the object’s `organizationId` field. */
  organizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `gender` field. */
  gender?: Maybe<GenderFilter>,
  /** Filter by the object’s `birthdate` field. */
  birthdate?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `line` field. */
  line?: Maybe<StringFilter>,
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>,
  /** Filter by the object’s `district` field. */
  district?: Maybe<StringFilter>,
  /** Filter by the object’s `state` field. */
  state?: Maybe<StringFilter>,
  /** Filter by the object’s `postalCode` field. */
  postalCode?: Maybe<StringFilter>,
  /** Filter by the object’s `country` field. */
  country?: Maybe<StringFilter>,
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>,
  /** Filter by the object’s `likes` field. */
  likes?: Maybe<StringListFilter>,
  /** Filter by the object’s `dislikes` field. */
  dislikes?: Maybe<StringListFilter>,
  /** Filter by the object’s `allergies` field. */
  allergies?: Maybe<StringListFilter>,
  /** Filter by the object’s `intolerances` field. */
  intolerances?: Maybe<StringListFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProfileDatumFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProfileDatumFilter>>,
  /** Negates the expression. */
  not?: Maybe<ProfileDatumFilter>,
};

/** Represents an update to a `ProfileDatum`. Fields that are set will be updated. */
export type ProfileDatumPatch = {
  gender?: Maybe<Gender>,
  birthdate?: Maybe<Scalars['Datetime']>,
  line?: Maybe<Scalars['String']>,
  city?: Maybe<Scalars['String']>,
  district?: Maybe<Scalars['String']>,
  state?: Maybe<Scalars['String']>,
  postalCode?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  likes?: Maybe<Array<Maybe<Scalars['String']>>>,
  dislikes?: Maybe<Array<Maybe<Scalars['String']>>>,
  allergies?: Maybe<Array<Maybe<Scalars['String']>>>,
  intolerances?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** A filter to be used against `Profile` object types. All fields are combined with a logical ‘and.’ */
export type ProfileFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `organizationId` field. */
  organizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `openId` field. */
  openId?: Maybe<StringFilter>,
  /** Filter by the object’s `fullUrl` field. */
  fullUrl?: Maybe<StringFilter>,
  /** Filter by the object’s `prefixName` field. */
  prefixName?: Maybe<StringFilter>,
  /** Filter by the object’s `givenName` field. */
  givenName?: Maybe<StringFilter>,
  /** Filter by the object’s `familyName` field. */
  familyName?: Maybe<StringFilter>,
  /** Filter by the object’s `suffixName` field. */
  suffixName?: Maybe<StringFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProfileFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProfileFilter>>,
  /** Negates the expression. */
  not?: Maybe<ProfileFilter>,
};

/** An input for mutations affecting `Profile` */
export type ProfileInput = {
  userId?: Maybe<Scalars['Int']>,
  organizationId: Scalars['Int'],
  openId?: Maybe<Scalars['String']>,
  fullUrl?: Maybe<Scalars['String']>,
  prefixName?: Maybe<Scalars['String']>,
  givenName?: Maybe<Scalars['String']>,
  familyName?: Maybe<Scalars['String']>,
  suffixName?: Maybe<Scalars['String']>,
};

export type ProfileOrganization = Node & {
   __typename?: 'ProfileOrganization',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  profileId: Scalars['Int'],
  organizationId: Scalars['Int'],
  profileUserId: Scalars['Int'],
  profileOrganizationId: Scalars['Int'],
  grantedByUserId: Scalars['Int'],
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `Profile` that is related to this `ProfileOrganization`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `Organization` that is related to this `ProfileOrganization`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileOrganization`. */
  userByProfileUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `ProfileOrganization`. */
  organizationByProfileOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileOrganization`. */
  userByGrantedByUserId?: Maybe<User>,
};

/** 
 * A condition to be used against `ProfileOrganization` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ProfileOrganizationCondition = {
  /** Checks for equality with the object’s `profileId` field. */
  profileId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `profileUserId` field. */
  profileUserId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `profileOrganizationId` field. */
  profileOrganizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `grantedByUserId` field. */
  grantedByUserId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `ProfileOrganization` object types. All fields are combined with a logical ‘and.’ */
export type ProfileOrganizationFilter = {
  /** Filter by the object’s `profileId` field. */
  profileId?: Maybe<IntFilter>,
  /** Filter by the object’s `organizationId` field. */
  organizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `profileUserId` field. */
  profileUserId?: Maybe<IntFilter>,
  /** Filter by the object’s `profileOrganizationId` field. */
  profileOrganizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `grantedByUserId` field. */
  grantedByUserId?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProfileOrganizationFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProfileOrganizationFilter>>,
  /** Negates the expression. */
  not?: Maybe<ProfileOrganizationFilter>,
};

/** A connection to a list of `ProfileOrganization` values. */
export type ProfileOrganizationsConnection = {
   __typename?: 'ProfileOrganizationsConnection',
  /** A list of `ProfileOrganization` objects. */
  nodes: Array<ProfileOrganization>,
  /** A list of edges which contains the `ProfileOrganization` and cursor to aid in pagination. */
  edges: Array<ProfileOrganizationsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ProfileOrganization` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ProfileOrganization` edge in the connection. */
export type ProfileOrganizationsEdge = {
   __typename?: 'ProfileOrganizationsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ProfileOrganization` at the end of the edge. */
  node: ProfileOrganization,
};

/** Methods to use when ordering `ProfileOrganization`. */
export enum ProfileOrganizationsOrderBy {
  NATURAL = 'NATURAL',
  PROFILE_ID_ASC = 'PROFILE_ID_ASC',
  PROFILE_ID_DESC = 'PROFILE_ID_DESC',
  ORGANIZATION_ID_ASC = 'ORGANIZATION_ID_ASC',
  ORGANIZATION_ID_DESC = 'ORGANIZATION_ID_DESC',
  PROFILE_USER_ID_ASC = 'PROFILE_USER_ID_ASC',
  PROFILE_USER_ID_DESC = 'PROFILE_USER_ID_DESC',
  PROFILE_ORGANIZATION_ID_ASC = 'PROFILE_ORGANIZATION_ID_ASC',
  PROFILE_ORGANIZATION_ID_DESC = 'PROFILE_ORGANIZATION_ID_DESC',
  GRANTED_BY_USER_ID_ASC = 'GRANTED_BY_USER_ID_ASC',
  GRANTED_BY_USER_ID_DESC = 'GRANTED_BY_USER_ID_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Profile`. Fields that are set will be updated. */
export type ProfilePatch = {
  prefixName?: Maybe<Scalars['String']>,
  givenName?: Maybe<Scalars['String']>,
  familyName?: Maybe<Scalars['String']>,
  suffixName?: Maybe<Scalars['String']>,
};

export type ProfileScheduledMealtime = Node & {
   __typename?: 'ProfileScheduledMealtime',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  profileId: Scalars['Int'],
  /** The MenuTemplateMeal that this scheduled mealtime is based upon */
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  datetime: Scalars['Datetime'],
  /** Allows re-ordering the scheduled mealtimes within a single date */
  position: Scalars['Int'],
  organizationId: Scalars['Int'],
  userId?: Maybe<Scalars['Int']>,
  mealId?: Maybe<Scalars['Int']>,
  /** The mealId that was in use when this record was created. */
  originalMealId?: Maybe<Scalars['Int']>,
  /** This will be automatically set to true if the meal has been customised beyond that of the source MenuTemplateMeal */
  isMealModified: Scalars['Boolean'],
  mealtimeId: Scalars['Int'],
  /** The Menu of the source MenuTemplateMeal */
  menuId?: Maybe<Scalars['Int']>,
  /** The day number that was originally set in the source MenuTemplateMeal */
  menuDayNumber: Scalars['Int'],
  /** 
 * The position that was originally set in the source MenuTemplateMeal, you may
   * reposition the scheduled mealtimes by changing the `position` field instead
 */
  menuPosition: Scalars['Int'],
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads a single `Profile` that is related to this `ProfileScheduledMealtime`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `MenuTemplateMeal` that is related to this `ProfileScheduledMealtime`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `Organization` that is related to this `ProfileScheduledMealtime`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileScheduledMealtime`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByOriginalMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `ProfileScheduledMealtime`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `Menu` that is related to this `ProfileScheduledMealtime`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `ProfileScheduledMealtime`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** Reads and enables pagination through a set of `Meal`. */
  mealsByProfileScheduledMealtimeId: MealsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByProfileScheduledMealtimeId: ProfileScheduledMealtimesConnection,
};


export type ProfileScheduledMealtimemealsByProfileScheduledMealtimeIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


export type ProfileScheduledMealtimeprofileScheduledMealtimesByProfileScheduledMealtimeIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** 
 * A condition to be used against `ProfileScheduledMealtime` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ProfileScheduledMealtimeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `profileId` field. */
  profileId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `datetime` field. */
  datetime?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `mealId` field. */
  mealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `originalMealId` field. */
  originalMealId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `isMealModified` field. */
  isMealModified?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuId` field. */
  menuId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuDayNumber` field. */
  menuDayNumber?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `menuPosition` field. */
  menuPosition?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `profileScheduledMealtimeId` field. */
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `ProfileScheduledMealtime` object types. All fields are combined with a logical ‘and.’ */
export type ProfileScheduledMealtimeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `profileId` field. */
  profileId?: Maybe<IntFilter>,
  /** Filter by the object’s `menuTemplateMealId` field. */
  menuTemplateMealId?: Maybe<IntFilter>,
  /** Filter by the object’s `datetime` field. */
  datetime?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `position` field. */
  position?: Maybe<IntFilter>,
  /** Filter by the object’s `organizationId` field. */
  organizationId?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `mealId` field. */
  mealId?: Maybe<IntFilter>,
  /** Filter by the object’s `originalMealId` field. */
  originalMealId?: Maybe<IntFilter>,
  /** Filter by the object’s `isMealModified` field. */
  isMealModified?: Maybe<BooleanFilter>,
  /** Filter by the object’s `mealtimeId` field. */
  mealtimeId?: Maybe<IntFilter>,
  /** Filter by the object’s `menuId` field. */
  menuId?: Maybe<IntFilter>,
  /** Filter by the object’s `menuDayNumber` field. */
  menuDayNumber?: Maybe<IntFilter>,
  /** Filter by the object’s `menuPosition` field. */
  menuPosition?: Maybe<IntFilter>,
  /** Filter by the object’s `profileScheduledMealtimeId` field. */
  profileScheduledMealtimeId?: Maybe<IntFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProfileScheduledMealtimeFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProfileScheduledMealtimeFilter>>,
  /** Negates the expression. */
  not?: Maybe<ProfileScheduledMealtimeFilter>,
};

/** An input for mutations affecting `ProfileScheduledMealtime` */
export type ProfileScheduledMealtimeInput = {
  profileId: Scalars['Int'],
  /** The MenuTemplateMeal that this scheduled mealtime is based upon */
  menuTemplateMealId?: Maybe<Scalars['Int']>,
  datetime: Scalars['Datetime'],
  mealId?: Maybe<Scalars['Int']>,
  mealtimeId?: Maybe<Scalars['Int']>,
  profileScheduledMealtimeId?: Maybe<Scalars['Int']>,
};

/** Represents an update to a `ProfileScheduledMealtime`. Fields that are set will be updated. */
export type ProfileScheduledMealtimePatch = {
  datetime?: Maybe<Scalars['Datetime']>,
  /** Allows re-ordering the scheduled mealtimes within a single date */
  position?: Maybe<Scalars['Int']>,
  mealId?: Maybe<Scalars['Int']>,
  mealtimeId?: Maybe<Scalars['Int']>,
};

/** A connection to a list of `ProfileScheduledMealtime` values. */
export type ProfileScheduledMealtimesConnection = {
   __typename?: 'ProfileScheduledMealtimesConnection',
  /** A list of `ProfileScheduledMealtime` objects. */
  nodes: Array<ProfileScheduledMealtime>,
  /** A list of edges which contains the `ProfileScheduledMealtime` and cursor to aid in pagination. */
  edges: Array<ProfileScheduledMealtimesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `ProfileScheduledMealtime` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `ProfileScheduledMealtime` edge in the connection. */
export type ProfileScheduledMealtimesEdge = {
   __typename?: 'ProfileScheduledMealtimesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `ProfileScheduledMealtime` at the end of the edge. */
  node: ProfileScheduledMealtime,
};

/** Methods to use when ordering `ProfileScheduledMealtime`. */
export enum ProfileScheduledMealtimesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  PROFILE_ID_ASC = 'PROFILE_ID_ASC',
  PROFILE_ID_DESC = 'PROFILE_ID_DESC',
  MENU_TEMPLATE_MEAL_ID_ASC = 'MENU_TEMPLATE_MEAL_ID_ASC',
  MENU_TEMPLATE_MEAL_ID_DESC = 'MENU_TEMPLATE_MEAL_ID_DESC',
  DATETIME_ASC = 'DATETIME_ASC',
  DATETIME_DESC = 'DATETIME_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  ORGANIZATION_ID_ASC = 'ORGANIZATION_ID_ASC',
  ORGANIZATION_ID_DESC = 'ORGANIZATION_ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  MEAL_ID_ASC = 'MEAL_ID_ASC',
  MEAL_ID_DESC = 'MEAL_ID_DESC',
  ORIGINAL_MEAL_ID_ASC = 'ORIGINAL_MEAL_ID_ASC',
  ORIGINAL_MEAL_ID_DESC = 'ORIGINAL_MEAL_ID_DESC',
  IS_MEAL_MODIFIED_ASC = 'IS_MEAL_MODIFIED_ASC',
  IS_MEAL_MODIFIED_DESC = 'IS_MEAL_MODIFIED_DESC',
  MEALTIME_ID_ASC = 'MEALTIME_ID_ASC',
  MEALTIME_ID_DESC = 'MEALTIME_ID_DESC',
  MENU_ID_ASC = 'MENU_ID_ASC',
  MENU_ID_DESC = 'MENU_ID_DESC',
  MENU_DAY_NUMBER_ASC = 'MENU_DAY_NUMBER_ASC',
  MENU_DAY_NUMBER_DESC = 'MENU_DAY_NUMBER_DESC',
  MENU_POSITION_ASC = 'MENU_POSITION_ASC',
  MENU_POSITION_DESC = 'MENU_POSITION_DESC',
  PROFILE_SCHEDULED_MEALTIME_ID_ASC = 'PROFILE_SCHEDULED_MEALTIME_ID_ASC',
  PROFILE_SCHEDULED_MEALTIME_ID_DESC = 'PROFILE_SCHEDULED_MEALTIME_ID_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Profile` values. */
export type ProfilesConnection = {
   __typename?: 'ProfilesConnection',
  /** A list of `Profile` objects. */
  nodes: Array<Profile>,
  /** A list of edges which contains the `Profile` and cursor to aid in pagination. */
  edges: Array<ProfilesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Profile` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Profile` edge in the connection. */
export type ProfilesEdge = {
   __typename?: 'ProfilesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Profile` at the end of the edge. */
  node: Profile,
};

/** Methods to use when ordering `Profile`. */
export enum ProfilesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  ORGANIZATION_ID_ASC = 'ORGANIZATION_ID_ASC',
  ORGANIZATION_ID_DESC = 'ORGANIZATION_ID_DESC',
  OPEN_ID_ASC = 'OPEN_ID_ASC',
  OPEN_ID_DESC = 'OPEN_ID_DESC',
  FULL_URL_ASC = 'FULL_URL_ASC',
  FULL_URL_DESC = 'FULL_URL_DESC',
  PREFIX_NAME_ASC = 'PREFIX_NAME_ASC',
  PREFIX_NAME_DESC = 'PREFIX_NAME_DESC',
  GIVEN_NAME_ASC = 'GIVEN_NAME_ASC',
  GIVEN_NAME_DESC = 'GIVEN_NAME_DESC',
  FAMILY_NAME_ASC = 'FAMILY_NAME_ASC',
  FAMILY_NAME_DESC = 'FAMILY_NAME_DESC',
  SUFFIX_NAME_ASC = 'SUFFIX_NAME_ASC',
  SUFFIX_NAME_DESC = 'SUFFIX_NAME_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `publishMeal` mutation. */
export type PublishMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  mealId?: Maybe<Scalars['Int']>,
};

/** The output of our `publishMeal` mutation. */
export type PublishMealPayload = {
   __typename?: 'PublishMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  meal?: Maybe<Meal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `Meal`. May be used by Relay 1. */
  mealEdge?: Maybe<MealsEdge>,
};


/** The output of our `publishMeal` mutation. */
export type PublishMealPayloadmealEdgeArgs = {
  orderBy?: Maybe<Array<MealsOrderBy>>
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
   __typename?: 'Query',
  /** 
 * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
 */
  query: Query,
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'],
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>,
  /** Reads and enables pagination through a set of `ConsumableCategory`. */
  allConsumableCategories?: Maybe<ConsumableCategoriesConnection>,
  /** Reads and enables pagination through a set of `ConsumableGroup`. */
  allConsumableGroups?: Maybe<ConsumableGroupsConnection>,
  /** Reads and enables pagination through a set of `ConsumableIngredient`. */
  allConsumableIngredients?: Maybe<ConsumableIngredientsConnection>,
  /** Reads and enables pagination through a set of `ConsumableLangual`. */
  allConsumableLanguals?: Maybe<ConsumableLangualsConnection>,
  /** Reads and enables pagination through a set of `ConsumableSource`. */
  allConsumableSources?: Maybe<ConsumableSourcesConnection>,
  /** Reads and enables pagination through a set of `Consumable`. */
  allConsumables?: Maybe<ConsumablesConnection>,
  /** Reads and enables pagination through a set of `FhirOrganizationType`. */
  allFhirOrganizationTypes?: Maybe<FhirOrganizationTypesConnection>,
  /** Reads and enables pagination through a set of `Langual`. */
  allLanguals?: Maybe<LangualsConnection>,
  /** Reads and enables pagination through a set of `MealConsumableCategory`. */
  allMealConsumableCategories?: Maybe<MealConsumableCategoriesConnection>,
  /** Reads and enables pagination through a set of `MealTag`. */
  allMealTags?: Maybe<MealTagsConnection>,
  /** Reads and enables pagination through a set of `Meal`. */
  allMeals?: Maybe<MealsConnection>,
  /** Reads and enables pagination through a set of `Mealtime`. */
  allMealtimes?: Maybe<MealtimesConnection>,
  /** Reads and enables pagination through a set of `MeasureUnit`. */
  allMeasureUnits?: Maybe<MeasureUnitsConnection>,
  /** Reads and enables pagination through a set of `Menu`. */
  allMenus?: Maybe<MenusConnection>,
  /** Reads and enables pagination through a set of `NutrientCategory`. */
  allNutrientCategories?: Maybe<NutrientCategoriesConnection>,
  /** Reads and enables pagination through a set of `NutrientRange`. */
  allNutrientRanges?: Maybe<NutrientRangesConnection>,
  /** Reads and enables pagination through a set of `Nutrient`. */
  allNutrients?: Maybe<NutrientsConnection>,
  /** Reads and enables pagination through a set of `NutrientsMap`. */
  allNutrientsMaps?: Maybe<NutrientsMapsConnection>,
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  allOrganizationUsers?: Maybe<OrganizationUsersConnection>,
  /** Reads and enables pagination through a set of `Organization`. */
  allOrganizations?: Maybe<OrganizationsConnection>,
  /** Reads and enables pagination through a set of `ProfileDatum`. */
  allProfileData?: Maybe<ProfileDataConnection>,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  allProfileOrganizations?: Maybe<ProfileOrganizationsConnection>,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  allProfileScheduledMealtimes?: Maybe<ProfileScheduledMealtimesConnection>,
  /** Reads and enables pagination through a set of `Profile`. */
  allProfiles?: Maybe<ProfilesConnection>,
  /** Reads and enables pagination through a set of `Role`. */
  allRoles?: Maybe<RolesConnection>,
  /** Reads and enables pagination through a set of `SnomedProblemList`. */
  allSnomedProblemLists?: Maybe<SnomedProblemListsConnection>,
  /** Reads and enables pagination through a set of `Tag`. */
  allTags?: Maybe<TagsConnection>,
  /** Reads and enables pagination through a set of `UnitsOfMeasure`. */
  allUnitsOfMeasures?: Maybe<UnitsOfMeasuresConnection>,
  /** Reads and enables pagination through a set of `UserDatum`. */
  allUserData?: Maybe<UserDataConnection>,
  /** Reads and enables pagination through a set of `UserRole`. */
  allUserRoles?: Maybe<UserRolesConnection>,
  /** Reads and enables pagination through a set of `User`. */
  allUsers?: Maybe<UsersConnection>,
  consumableCategoryById?: Maybe<ConsumableCategory>,
  consumableGroupById?: Maybe<ConsumableGroup>,
  consumableGroupBySourceAndIdentifier?: Maybe<ConsumableGroup>,
  consumableIngredientById?: Maybe<ConsumableIngredient>,
  consumableLangualByConsumableIdAndLangualCode?: Maybe<ConsumableLangual>,
  consumableMeasureById?: Maybe<ConsumableMeasure>,
  consumableMeasureByConsumableIdAndId?: Maybe<ConsumableMeasure>,
  consumableMeasureByConsumableIdAndLabelAndQuantity?: Maybe<ConsumableMeasure>,
  consumableNutrientById?: Maybe<ConsumableNutrient>,
  consumableNutrientByConsumableIdAndNutrientId?: Maybe<ConsumableNutrient>,
  consumableSourceById?: Maybe<ConsumableSource>,
  consumableById?: Maybe<Consumable>,
  consumableBySourceAndIdentifier?: Maybe<Consumable>,
  langualByCode?: Maybe<Langual>,
  mealConsumableCategoryById?: Maybe<MealConsumableCategory>,
  mealConsumableById?: Maybe<MealConsumable>,
  mealNutrientByMealIdAndNutrientId?: Maybe<MealNutrient>,
  mealTagByMealIdAndTagId?: Maybe<MealTag>,
  mealById?: Maybe<Meal>,
  mealtimeById?: Maybe<Mealtime>,
  measureUnitById?: Maybe<MeasureUnit>,
  menuNutrientStatisticByMenuIdAndNutrientId?: Maybe<MenuNutrientStatistic>,
  menuTemplateMealById?: Maybe<MenuTemplateMeal>,
  menuById?: Maybe<Menu>,
  nutrientCategoryById?: Maybe<NutrientCategory>,
  nutrientRangeById?: Maybe<NutrientRange>,
  nutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientId?: Maybe<NutrientRange>,
  nutrientById?: Maybe<Nutrient>,
  nutrientBySourceAndIdentifier?: Maybe<Nutrient>,
  nutrientsMapById?: Maybe<NutrientsMap>,
  nutrientsMapBySourceAndIdentifier?: Maybe<NutrientsMap>,
  organizationUserById?: Maybe<OrganizationUser>,
  organizationById?: Maybe<Organization>,
  profileDatumByProfileId?: Maybe<ProfileDatum>,
  profileOrganizationByProfileIdAndOrganizationId?: Maybe<ProfileOrganization>,
  profileScheduledMealtimeById?: Maybe<ProfileScheduledMealtime>,
  profileById?: Maybe<Profile>,
  profileByOpenId?: Maybe<Profile>,
  roleById?: Maybe<Role>,
  snomedProblemListBySnomedCid?: Maybe<SnomedProblemList>,
  tagById?: Maybe<Tag>,
  unitsOfMeasureById?: Maybe<UnitsOfMeasure>,
  unitsOfMeasureByCode?: Maybe<UnitsOfMeasure>,
  userDatumByUserId?: Maybe<UserDatum>,
  userEmailById?: Maybe<UserEmail>,
  userRoleById?: Maybe<UserRole>,
  userRoleByUserIdAndRoleId?: Maybe<UserRole>,
  userById?: Maybe<User>,
  /** Reads and enables pagination through a set of `NutrientValue`. */
  calculateAggregateNutritionStatisticsForMeals: NutrientValuesConnection,
  /** Reads and enables pagination through a set of `NutrientValue`. */
  calculateAggregateNutritionStatisticsForMenuDayRange: NutrientValuesConnection,
  consumableByUsdaId?: Maybe<Scalars['Int']>,
  currentUser?: Maybe<User>,
  currentUserId?: Maybe<Scalars['Int']>,
  currentUserIsAdmin?: Maybe<Scalars['Boolean']>,
  /** Reads and enables pagination through a set of `Meal`. */
  getMealsWithoutNullConsumables: MealsConnection,
  /** Reads and enables pagination through a set of `Consumable`. */
  searchConsumables: ConsumablesConnection,
  /** Reads and enables pagination through a set of `Meal`. */
  searchMeals: MealsConnection,
  /** Reads and enables pagination through a set of `Menu`. */
  searchMenus: MenusConnection,
  /** Reads and enables pagination through a set of `Profile`. */
  searchProfiles: ProfilesConnection,
  /** Reads a single `ConsumableCategory` using its globally unique `ID`. */
  consumableCategory?: Maybe<ConsumableCategory>,
  /** Reads a single `ConsumableGroup` using its globally unique `ID`. */
  consumableGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `ConsumableIngredient` using its globally unique `ID`. */
  consumableIngredient?: Maybe<ConsumableIngredient>,
  /** Reads a single `ConsumableLangual` using its globally unique `ID`. */
  consumableLangual?: Maybe<ConsumableLangual>,
  /** Reads a single `ConsumableMeasure` using its globally unique `ID`. */
  consumableMeasure?: Maybe<ConsumableMeasure>,
  /** Reads a single `ConsumableNutrient` using its globally unique `ID`. */
  consumableNutrient?: Maybe<ConsumableNutrient>,
  /** Reads a single `ConsumableSource` using its globally unique `ID`. */
  consumableSource?: Maybe<ConsumableSource>,
  /** Reads a single `Consumable` using its globally unique `ID`. */
  consumable?: Maybe<Consumable>,
  /** Reads a single `Langual` using its globally unique `ID`. */
  langual?: Maybe<Langual>,
  /** Reads a single `MealConsumableCategory` using its globally unique `ID`. */
  mealConsumableCategory?: Maybe<MealConsumableCategory>,
  /** Reads a single `MealConsumable` using its globally unique `ID`. */
  mealConsumable?: Maybe<MealConsumable>,
  /** Reads a single `MealNutrient` using its globally unique `ID`. */
  mealNutrient?: Maybe<MealNutrient>,
  /** Reads a single `MealTag` using its globally unique `ID`. */
  mealTag?: Maybe<MealTag>,
  /** Reads a single `Meal` using its globally unique `ID`. */
  meal?: Maybe<Meal>,
  /** Reads a single `Mealtime` using its globally unique `ID`. */
  mealtime?: Maybe<Mealtime>,
  /** Reads a single `MeasureUnit` using its globally unique `ID`. */
  measureUnit?: Maybe<MeasureUnit>,
  /** Reads a single `MenuNutrientStatistic` using its globally unique `ID`. */
  menuNutrientStatistic?: Maybe<MenuNutrientStatistic>,
  /** Reads a single `MenuTemplateMeal` using its globally unique `ID`. */
  menuTemplateMeal?: Maybe<MenuTemplateMeal>,
  /** Reads a single `Menu` using its globally unique `ID`. */
  menu?: Maybe<Menu>,
  /** Reads a single `NutrientCategory` using its globally unique `ID`. */
  nutrientCategory?: Maybe<NutrientCategory>,
  /** Reads a single `NutrientRange` using its globally unique `ID`. */
  nutrientRange?: Maybe<NutrientRange>,
  /** Reads a single `Nutrient` using its globally unique `ID`. */
  nutrient?: Maybe<Nutrient>,
  /** Reads a single `NutrientsMap` using its globally unique `ID`. */
  nutrientsMap?: Maybe<NutrientsMap>,
  /** Reads a single `OrganizationUser` using its globally unique `ID`. */
  organizationUser?: Maybe<OrganizationUser>,
  /** Reads a single `Organization` using its globally unique `ID`. */
  organization?: Maybe<Organization>,
  /** Reads a single `ProfileDatum` using its globally unique `ID`. */
  profileDatum?: Maybe<ProfileDatum>,
  /** Reads a single `ProfileOrganization` using its globally unique `ID`. */
  profileOrganization?: Maybe<ProfileOrganization>,
  /** Reads a single `ProfileScheduledMealtime` using its globally unique `ID`. */
  profileScheduledMealtime?: Maybe<ProfileScheduledMealtime>,
  /** Reads a single `Profile` using its globally unique `ID`. */
  profile?: Maybe<Profile>,
  /** Reads a single `Role` using its globally unique `ID`. */
  role?: Maybe<Role>,
  /** Reads a single `SnomedProblemList` using its globally unique `ID`. */
  snomedProblemList?: Maybe<SnomedProblemList>,
  /** Reads a single `Tag` using its globally unique `ID`. */
  tag?: Maybe<Tag>,
  /** Reads a single `UnitsOfMeasure` using its globally unique `ID`. */
  unitsOfMeasure?: Maybe<UnitsOfMeasure>,
  /** Reads a single `UserDatum` using its globally unique `ID`. */
  userDatum?: Maybe<UserDatum>,
  /** Reads a single `UserEmail` using its globally unique `ID`. */
  userEmail?: Maybe<UserEmail>,
  /** Reads a single `UserRole` using its globally unique `ID`. */
  userRole?: Maybe<UserRole>,
  /** Reads a single `User` using its globally unique `ID`. */
  user?: Maybe<User>,
  allFHIRPatients?: Maybe<FHIRPatientList>,
  allFHIRNutritionOrders?: Maybe<FHIRNutritionOrderList>,
  fhirPatientById?: Maybe<FHIRPatient>,
  fhirNutritionOrderById?: Maybe<FHIRNutritionOrder>,
  fhirNutritionOrdersByPatientId?: Maybe<FHIRNutritionOrderList>,
  allNutritionIntakes?: Maybe<NutritionIntakeList>,
};


/** The root query type which gives access points into the data universe. */
export type QuerynodeArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumableCategoriesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableCategoriesOrderBy>>,
  condition?: Maybe<ConsumableCategoryCondition>,
  filter?: Maybe<ConsumableCategoryFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumableGroupsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableGroupsOrderBy>>,
  condition?: Maybe<ConsumableGroupCondition>,
  filter?: Maybe<ConsumableGroupFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumableIngredientsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableIngredientsOrderBy>>,
  condition?: Maybe<ConsumableIngredientCondition>,
  filter?: Maybe<ConsumableIngredientFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumableLangualsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableLangualsOrderBy>>,
  condition?: Maybe<ConsumableLangualCondition>,
  filter?: Maybe<ConsumableLangualFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumableSourcesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumableSourcesOrderBy>>,
  condition?: Maybe<ConsumableSourceCondition>,
  filter?: Maybe<ConsumableSourceFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallConsumablesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumablesOrderBy>>,
  condition?: Maybe<ConsumableCondition>,
  filter?: Maybe<ConsumableFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallFhirOrganizationTypesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<FhirOrganizationTypesOrderBy>>,
  condition?: Maybe<FhirOrganizationTypeCondition>,
  filter?: Maybe<FhirOrganizationTypeFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallLangualsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<LangualsOrderBy>>,
  condition?: Maybe<LangualCondition>,
  filter?: Maybe<LangualFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMealConsumableCategoriesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealConsumableCategoriesOrderBy>>,
  condition?: Maybe<MealConsumableCategoryCondition>,
  filter?: Maybe<MealConsumableCategoryFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMealTagsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealTagsOrderBy>>,
  condition?: Maybe<MealTagCondition>,
  filter?: Maybe<MealTagFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMealsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMealtimesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealtimesOrderBy>>,
  condition?: Maybe<MealtimeCondition>,
  filter?: Maybe<MealtimeFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMeasureUnitsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MeasureUnitsOrderBy>>,
  condition?: Maybe<MeasureUnitCondition>,
  filter?: Maybe<MeasureUnitFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallMenusArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenusOrderBy>>,
  condition?: Maybe<MenuCondition>,
  filter?: Maybe<MenuFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallNutrientCategoriesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientCategoriesOrderBy>>,
  condition?: Maybe<NutrientCategoryCondition>,
  filter?: Maybe<NutrientCategoryFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallNutrientRangesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientRangesOrderBy>>,
  condition?: Maybe<NutrientRangeCondition>,
  filter?: Maybe<NutrientRangeFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallNutrientsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsOrderBy>>,
  condition?: Maybe<NutrientCondition>,
  filter?: Maybe<NutrientFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallNutrientsMapsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientsMapsOrderBy>>,
  condition?: Maybe<NutrientsMapCondition>,
  filter?: Maybe<NutrientsMapFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrganizationUsersArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<OrganizationUsersOrderBy>>,
  condition?: Maybe<OrganizationUserCondition>,
  filter?: Maybe<OrganizationUserFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrganizationsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<OrganizationsOrderBy>>,
  condition?: Maybe<OrganizationCondition>,
  filter?: Maybe<OrganizationFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallProfileDataArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileDataOrderBy>>,
  condition?: Maybe<ProfileDatumCondition>,
  filter?: Maybe<ProfileDatumFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallProfileOrganizationsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallProfileScheduledMealtimesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallProfilesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfilesOrderBy>>,
  condition?: Maybe<ProfileCondition>,
  filter?: Maybe<ProfileFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallRolesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<RolesOrderBy>>,
  condition?: Maybe<RoleCondition>,
  filter?: Maybe<RoleFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallSnomedProblemListsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<SnomedProblemListsOrderBy>>,
  condition?: Maybe<SnomedProblemListCondition>,
  filter?: Maybe<SnomedProblemListFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallTagsArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<TagsOrderBy>>,
  condition?: Maybe<TagCondition>,
  filter?: Maybe<TagFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallUnitsOfMeasuresArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UnitsOfMeasuresOrderBy>>,
  condition?: Maybe<UnitsOfMeasureCondition>,
  filter?: Maybe<UnitsOfMeasureFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallUserDataArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserDataOrderBy>>,
  condition?: Maybe<UserDatumCondition>,
  filter?: Maybe<UserDatumFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallUserRolesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserRolesOrderBy>>,
  condition?: Maybe<UserRoleCondition>,
  filter?: Maybe<UserRoleFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryallUsersArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UsersOrderBy>>,
  condition?: Maybe<UserCondition>,
  filter?: Maybe<UserFilter>
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableCategoryByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableGroupByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableGroupBySourceAndIdentifierArgs = {
  source: Scalars['String'],
  identifier: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableIngredientByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableLangualByConsumableIdAndLangualCodeArgs = {
  consumableId: Scalars['Int'],
  langualCode: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableMeasureByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableMeasureByConsumableIdAndIdArgs = {
  consumableId: Scalars['Int'],
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableMeasureByConsumableIdAndLabelAndQuantityArgs = {
  consumableId: Scalars['Int'],
  label: Scalars['String'],
  quantity: Scalars['Float']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableNutrientByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableNutrientByConsumableIdAndNutrientIdArgs = {
  consumableId: Scalars['Int'],
  nutrientId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableSourceByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableBySourceAndIdentifierArgs = {
  source: Scalars['String'],
  identifier: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QuerylangualByCodeArgs = {
  code: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealConsumableCategoryByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealConsumableByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealNutrientByMealIdAndNutrientIdArgs = {
  mealId: Scalars['Int'],
  nutrientId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealTagByMealIdAndTagIdArgs = {
  mealId: Scalars['Int'],
  tagId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealtimeByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymeasureUnitByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuNutrientStatisticByMenuIdAndNutrientIdArgs = {
  menuId: Scalars['Int'],
  nutrientId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuTemplateMealByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientCategoryByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientRangeByIdArgs = {
  id: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientIdArgs = {
  snomedCid: Scalars['String'],
  ageLowerMonths: Scalars['Int'],
  ageUpperMonths: Scalars['Int'],
  nutrientId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientBySourceAndIdentifierArgs = {
  source: Scalars['String'],
  identifier: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientsMapByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientsMapBySourceAndIdentifierArgs = {
  source: Scalars['String'],
  identifier: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryorganizationUserByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryorganizationByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileDatumByProfileIdArgs = {
  profileId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileOrganizationByProfileIdAndOrganizationIdArgs = {
  profileId: Scalars['Int'],
  organizationId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileScheduledMealtimeByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileByOpenIdArgs = {
  openId: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryroleByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerysnomedProblemListBySnomedCidArgs = {
  snomedCid: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QuerytagByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryunitsOfMeasureByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryunitsOfMeasureByCodeArgs = {
  code: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserDatumByUserIdArgs = {
  userId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserEmailByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserRoleByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserRoleByUserIdAndRoleIdArgs = {
  userId: Scalars['Int'],
  roleId: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserByIdArgs = {
  id: Scalars['Int']
};


/** The root query type which gives access points into the data universe. */
export type QuerycalculateAggregateNutritionStatisticsForMealsArgs = {
  mealIds?: Maybe<Array<Maybe<Scalars['Int']>>>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<NutrientValueFilter>,
  condition?: Maybe<NutrientValueCondition>
};


/** The root query type which gives access points into the data universe. */
export type QuerycalculateAggregateNutritionStatisticsForMenuDayRangeArgs = {
  menuId: Scalars['Int'],
  startDay?: Maybe<Scalars['Int']>,
  endDay?: Maybe<Scalars['Int']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<NutrientValueFilter>,
  condition?: Maybe<NutrientValueCondition>
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableByUsdaIdArgs = {
  id?: Maybe<Scalars['String']>
};


/** The root query type which gives access points into the data universe. */
export type QuerygetMealsWithoutNullConsumablesArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<MealFilter>,
  condition?: Maybe<MealCondition>
};


/** The root query type which gives access points into the data universe. */
export type QuerysearchConsumablesArgs = {
  searchTerms?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<ConsumableFilter>,
  condition?: Maybe<ConsumableCondition>
};


/** The root query type which gives access points into the data universe. */
export type QuerysearchMealsArgs = {
  searchTerms?: Maybe<Scalars['String']>,
  tagIds?: Maybe<Array<Maybe<Scalars['Int']>>>,
  mealNutrientRanges?: Maybe<Array<Maybe<MealNutrientRangeInput>>>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<MealFilter>,
  condition?: Maybe<MealCondition>
};


/** The root query type which gives access points into the data universe. */
export type QuerysearchMenusArgs = {
  searchTerms?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<MenuFilter>,
  condition?: Maybe<MenuCondition>
};


/** The root query type which gives access points into the data universe. */
export type QuerysearchProfilesArgs = {
  searchTerms?: Maybe<Scalars['String']>,
  organizationIds?: Maybe<Array<Maybe<Scalars['Int']>>>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  filter?: Maybe<ProfileFilter>,
  condition?: Maybe<ProfileCondition>
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableCategoryArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableGroupArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableIngredientArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableLangualArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableMeasureArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableNutrientArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableSourceArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryconsumableArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerylangualArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealConsumableCategoryArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealConsumableArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealNutrientArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealTagArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymealtimeArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymeasureUnitArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuNutrientStatisticArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuTemplateMealArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerymenuArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientCategoryArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientRangeArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerynutrientsMapArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryorganizationUserArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryorganizationArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileDatumArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileOrganizationArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileScheduledMealtimeArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryprofileArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryroleArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerysnomedProblemListArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QuerytagArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryunitsOfMeasureArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserDatumArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserEmailArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserRoleArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryuserArgs = {
  nodeId: Scalars['ID']
};


/** The root query type which gives access points into the data universe. */
export type QueryallFHIRPatientsArgs = {
  after?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<FHIRPatientOrderBy>,
  searchTerms?: Maybe<Scalars['String']>
};


/** The root query type which gives access points into the data universe. */
export type QueryallFHIRNutritionOrdersArgs = {
  after?: Maybe<Scalars['String']>
};


/** The root query type which gives access points into the data universe. */
export type QueryfhirPatientByIdArgs = {
  id: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryfhirNutritionOrderByIdArgs = {
  id: Scalars['String']
};


/** The root query type which gives access points into the data universe. */
export type QueryfhirNutritionOrdersByPatientIdArgs = {
  id: Scalars['String']
};

/** All input for the `resetPasswordForEmail` mutation. */
export type ResetPasswordForEmailInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  token?: Maybe<Scalars['String']>,
  newPassword?: Maybe<Scalars['String']>,
};

/** The output of our `resetPasswordForEmail` mutation. */
export type ResetPasswordForEmailPayload = {
   __typename?: 'ResetPasswordForEmailPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  boolean?: Maybe<Scalars['Boolean']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

export type Role = Node & {
   __typename?: 'Role',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  name: Scalars['String'],
  canCreateMenusAndManagePatients: Scalars['Boolean'],
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads and enables pagination through a set of `UserRole`. */
  userRolesByRoleId: UserRolesConnection,
};


export type RoleuserRolesByRoleIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserRolesOrderBy>>,
  condition?: Maybe<UserRoleCondition>,
  filter?: Maybe<UserRoleFilter>
};

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `canCreateMenusAndManagePatients` field. */
  canCreateMenusAndManagePatients?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export type RoleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `canCreateMenusAndManagePatients` field. */
  canCreateMenusAndManagePatients?: Maybe<BooleanFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RoleFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RoleFilter>>,
  /** Negates the expression. */
  not?: Maybe<RoleFilter>,
};

/** A connection to a list of `Role` values. */
export type RolesConnection = {
   __typename?: 'RolesConnection',
  /** A list of `Role` objects. */
  nodes: Array<Role>,
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Role` edge in the connection. */
export type RolesEdge = {
   __typename?: 'RolesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Role` at the end of the edge. */
  node: Role,
};

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  CAN_CREATE_MENUS_AND_MANAGE_PATIENTS_ASC = 'CAN_CREATE_MENUS_AND_MANAGE_PATIENTS_ASC',
  CAN_CREATE_MENUS_AND_MANAGE_PATIENTS_DESC = 'CAN_CREATE_MENUS_AND_MANAGE_PATIENTS_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `sendProfileInviteCode` mutation. */
export type SendProfileInviteCodeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profileId?: Maybe<Scalars['Int']>,
  mode?: Maybe<Scalars['String']>,
};

/** The output of our `sendProfileInviteCode` mutation. */
export type SendProfileInviteCodePayload = {
   __typename?: 'SendProfileInviteCodePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  boolean?: Maybe<Scalars['Boolean']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

/** All input for the `setMealTags` mutation. */
export type SetMealTagsInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  mealId: Scalars['Int'],
  tags: Array<Maybe<Scalars['String']>>,
};

/** The output of our `setMealTags` mutation. */
export type SetMealTagsPayload = {
   __typename?: 'SetMealTagsPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  meal?: Maybe<Meal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `Meal`. May be used by Relay 1. */
  mealEdge?: Maybe<MealsEdge>,
};


/** The output of our `setMealTags` mutation. */
export type SetMealTagsPayloadmealEdgeArgs = {
  orderBy?: Maybe<Array<MealsOrderBy>>
};

/** All input for the `setMenu` mutation. */
export type SetMenuInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  id: Scalars['Int'],
};

/** The output of our `setMenu` mutation. */
export type SetMenuPayload = {
   __typename?: 'SetMenuPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

/** All input for the `setProfile` mutation. */
export type SetProfileInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  profileId: Scalars['String'],
  givenName: Scalars['String'],
  familyName: Scalars['String'],
  organizationId: Scalars['Int'],
  enduserId: Scalars['Int'],
};

/** The output of our `setProfile` mutation. */
export type SetProfilePayload = {
   __typename?: 'SetProfilePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
};

export type SnomedProblemList = Node & {
   __typename?: 'SnomedProblemList',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  snomedCid: Scalars['String'],
  snomedFsn?: Maybe<Scalars['String']>,
  snomedConceptStatus?: Maybe<Scalars['String']>,
  umlsCui?: Maybe<Scalars['String']>,
  occurrence?: Maybe<Scalars['String']>,
  usage?: Maybe<Scalars['String']>,
  firstInSubset?: Maybe<Scalars['String']>,
  isRetiredFromSubset?: Maybe<Scalars['String']>,
  lastInSubset?: Maybe<Scalars['String']>,
  replacedBySnomedCid?: Maybe<Scalars['String']>,
  /** Reads and enables pagination through a set of `NutrientRange`. */
  nutrientRangesBySnomedCid: NutrientRangesConnection,
};


export type SnomedProblemListnutrientRangesBySnomedCidArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<NutrientRangesOrderBy>>,
  condition?: Maybe<NutrientRangeCondition>,
  filter?: Maybe<NutrientRangeFilter>
};

/** 
 * A condition to be used against `SnomedProblemList` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SnomedProblemListCondition = {
  /** Checks for equality with the object’s `snomedCid` field. */
  snomedCid?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `snomedFsn` field. */
  snomedFsn?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `snomedConceptStatus` field. */
  snomedConceptStatus?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `umlsCui` field. */
  umlsCui?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `occurrence` field. */
  occurrence?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `usage` field. */
  usage?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `firstInSubset` field. */
  firstInSubset?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `isRetiredFromSubset` field. */
  isRetiredFromSubset?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `lastInSubset` field. */
  lastInSubset?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `replacedBySnomedCid` field. */
  replacedBySnomedCid?: Maybe<Scalars['String']>,
};

/** A filter to be used against `SnomedProblemList` object types. All fields are combined with a logical ‘and.’ */
export type SnomedProblemListFilter = {
  /** Filter by the object’s `snomedCid` field. */
  snomedCid?: Maybe<StringFilter>,
  /** Filter by the object’s `snomedFsn` field. */
  snomedFsn?: Maybe<StringFilter>,
  /** Filter by the object’s `snomedConceptStatus` field. */
  snomedConceptStatus?: Maybe<StringFilter>,
  /** Filter by the object’s `umlsCui` field. */
  umlsCui?: Maybe<StringFilter>,
  /** Filter by the object’s `occurrence` field. */
  occurrence?: Maybe<StringFilter>,
  /** Filter by the object’s `usage` field. */
  usage?: Maybe<StringFilter>,
  /** Filter by the object’s `firstInSubset` field. */
  firstInSubset?: Maybe<StringFilter>,
  /** Filter by the object’s `isRetiredFromSubset` field. */
  isRetiredFromSubset?: Maybe<StringFilter>,
  /** Filter by the object’s `lastInSubset` field. */
  lastInSubset?: Maybe<StringFilter>,
  /** Filter by the object’s `replacedBySnomedCid` field. */
  replacedBySnomedCid?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SnomedProblemListFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SnomedProblemListFilter>>,
  /** Negates the expression. */
  not?: Maybe<SnomedProblemListFilter>,
};

/** A connection to a list of `SnomedProblemList` values. */
export type SnomedProblemListsConnection = {
   __typename?: 'SnomedProblemListsConnection',
  /** A list of `SnomedProblemList` objects. */
  nodes: Array<SnomedProblemList>,
  /** A list of edges which contains the `SnomedProblemList` and cursor to aid in pagination. */
  edges: Array<SnomedProblemListsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `SnomedProblemList` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `SnomedProblemList` edge in the connection. */
export type SnomedProblemListsEdge = {
   __typename?: 'SnomedProblemListsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `SnomedProblemList` at the end of the edge. */
  node: SnomedProblemList,
};

/** Methods to use when ordering `SnomedProblemList`. */
export enum SnomedProblemListsOrderBy {
  NATURAL = 'NATURAL',
  SNOMED_CID_ASC = 'SNOMED_CID_ASC',
  SNOMED_CID_DESC = 'SNOMED_CID_DESC',
  SNOMED_FSN_ASC = 'SNOMED_FSN_ASC',
  SNOMED_FSN_DESC = 'SNOMED_FSN_DESC',
  SNOMED_CONCEPT_STATUS_ASC = 'SNOMED_CONCEPT_STATUS_ASC',
  SNOMED_CONCEPT_STATUS_DESC = 'SNOMED_CONCEPT_STATUS_DESC',
  UMLS_CUI_ASC = 'UMLS_CUI_ASC',
  UMLS_CUI_DESC = 'UMLS_CUI_DESC',
  OCCURRENCE_ASC = 'OCCURRENCE_ASC',
  OCCURRENCE_DESC = 'OCCURRENCE_DESC',
  USAGE_ASC = 'USAGE_ASC',
  USAGE_DESC = 'USAGE_DESC',
  FIRST_IN_SUBSET_ASC = 'FIRST_IN_SUBSET_ASC',
  FIRST_IN_SUBSET_DESC = 'FIRST_IN_SUBSET_DESC',
  IS_RETIRED_FROM_SUBSET_ASC = 'IS_RETIRED_FROM_SUBSET_ASC',
  IS_RETIRED_FROM_SUBSET_DESC = 'IS_RETIRED_FROM_SUBSET_DESC',
  LAST_IN_SUBSET_ASC = 'LAST_IN_SUBSET_ASC',
  LAST_IN_SUBSET_DESC = 'LAST_IN_SUBSET_DESC',
  REPLACED_BY_SNOMED_CID_ASC = 'REPLACED_BY_SNOMED_CID_ASC',
  REPLACED_BY_SNOMED_CID_DESC = 'REPLACED_BY_SNOMED_CID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>,
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>,
  /** Contains the specified string (case-sensitive). */
  contains?: Maybe<Scalars['String']>,
  /** Does not contain the specified string (case-sensitive). */
  notContains?: Maybe<Scalars['String']>,
  /** Contains the specified string (case-insensitive). */
  containsInsensitive?: Maybe<Scalars['String']>,
  /** Does not contain the specified string (case-insensitive). */
  notContainsInsensitive?: Maybe<Scalars['String']>,
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>,
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>,
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>,
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>,
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>,
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>,
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>,
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>,
  /** 
 * Matches the specified pattern (case-sensitive). An underscore (_) matches any
   * single character; a percent sign (%) matches any sequence of zero or more characters.
 */
  like?: Maybe<Scalars['String']>,
  /** 
 * Does not match the specified pattern (case-sensitive). An underscore (_)
   * matches any single character; a percent sign (%) matches any sequence of zero
   * or more characters.
 */
  notLike?: Maybe<Scalars['String']>,
  /** 
 * Matches the specified pattern (case-insensitive). An underscore (_) matches
   * any single character; a percent sign (%) matches any sequence of zero or more characters.
 */
  likeInsensitive?: Maybe<Scalars['String']>,
  /** 
 * Does not match the specified pattern (case-insensitive). An underscore (_)
   * matches any single character; a percent sign (%) matches any sequence of zero
   * or more characters.
 */
  notLikeInsensitive?: Maybe<Scalars['String']>,
  /** Matches the specified pattern using the SQL standard's definition of a regular expression. */
  similarTo?: Maybe<Scalars['String']>,
  /** Does not match the specified pattern using the SQL standard's definition of a regular expression. */
  notSimilarTo?: Maybe<Scalars['String']>,
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Contains the specified list of values. */
  jsonbContains?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Contained by the specified list of values. */
  jsonbContainedBy?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>,
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>,
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>,
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>,
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>,
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>,
};

export type Tag = Node & {
   __typename?: 'Tag',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  name: Scalars['String'],
  /** Reads and enables pagination through a set of `MealTag`. */
  mealTagsByTagId: MealTagsConnection,
};


export type TagmealTagsByTagIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealTagsOrderBy>>,
  condition?: Maybe<MealTagCondition>,
  filter?: Maybe<MealTagFilter>
};

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
};

/** A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’ */
export type TagFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TagFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TagFilter>>,
  /** Negates the expression. */
  not?: Maybe<TagFilter>,
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  name: Scalars['String'],
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  name?: Maybe<Scalars['String']>,
};

/** A connection to a list of `Tag` values. */
export type TagsConnection = {
   __typename?: 'TagsConnection',
  /** A list of `Tag` objects. */
  nodes: Array<Tag>,
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: Array<TagsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `Tag` edge in the connection. */
export type TagsEdge = {
   __typename?: 'TagsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `Tag` at the end of the edge. */
  node: Tag,
};

/** Methods to use when ordering `Tag`. */
export enum TagsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}


/** A range of `Time`. */
export type TimeRange = {
   __typename?: 'TimeRange',
  /** The starting bound of our range. */
  start?: Maybe<TimeRangeBound>,
  /** The ending bound of our range. */
  end?: Maybe<TimeRangeBound>,
};

/** The value at one end of a range. A range can either include this value, or not. */
export type TimeRangeBound = {
   __typename?: 'TimeRangeBound',
  /** The value at one end of our range. */
  value: Scalars['Time'],
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean'],
};

/** The value at one end of a range. A range can either include this value, or not. */
export type TimeRangeBoundInput = {
  /** The value at one end of our range. */
  value: Scalars['Time'],
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean'],
};

/** A filter to be used against TimeRange fields. All fields are combined with a logical ‘and.’ */
export type TimeRangeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>,
  /** Equal to the specified value. */
  equalTo?: Maybe<TimeRangeInput>,
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TimeRangeInput>,
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TimeRangeInput>,
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TimeRangeInput>,
  /** Included in the specified list. */
  in?: Maybe<Array<TimeRangeInput>>,
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TimeRangeInput>>,
  /** Less than the specified value. */
  lessThan?: Maybe<TimeRangeInput>,
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TimeRangeInput>,
  /** Greater than the specified value. */
  greaterThan?: Maybe<TimeRangeInput>,
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TimeRangeInput>,
  /** Contains the specified range. */
  jsonbContains?: Maybe<TimeRangeInput>,
  /** Contains the specified value. */
  containsElement?: Maybe<Scalars['Time']>,
  /** Contained by the specified range. */
  jsonbContainedBy?: Maybe<TimeRangeInput>,
  /** Overlaps the specified range. */
  overlaps?: Maybe<TimeRangeInput>,
  /** Strictly left of the specified range. */
  strictlyLeftOf?: Maybe<TimeRangeInput>,
  /** Strictly right of the specified range. */
  strictlyRightOf?: Maybe<TimeRangeInput>,
  /** Does not extend right of the specified range. */
  notExtendsRightOf?: Maybe<TimeRangeInput>,
  /** Does not extend left of the specified range. */
  notExtendsLeftOf?: Maybe<TimeRangeInput>,
  /** Adjacent to the specified range. */
  adjacentTo?: Maybe<TimeRangeInput>,
};

/** A range of `Time`. */
export type TimeRangeInput = {
  /** The starting bound of our range. */
  start?: Maybe<TimeRangeBoundInput>,
  /** The ending bound of our range. */
  end?: Maybe<TimeRangeBoundInput>,
};

export type UnitsOfMeasure = Node & {
   __typename?: 'UnitsOfMeasure',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  code: Scalars['String'],
  display: Scalars['String'],
  active: Scalars['Boolean'],
};

/** 
 * A condition to be used against `UnitsOfMeasure` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UnitsOfMeasureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `display` field. */
  display?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `active` field. */
  active?: Maybe<Scalars['Boolean']>,
};

/** A filter to be used against `UnitsOfMeasure` object types. All fields are combined with a logical ‘and.’ */
export type UnitsOfMeasureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>,
  /** Filter by the object’s `display` field. */
  display?: Maybe<StringFilter>,
  /** Filter by the object’s `active` field. */
  active?: Maybe<BooleanFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UnitsOfMeasureFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UnitsOfMeasureFilter>>,
  /** Negates the expression. */
  not?: Maybe<UnitsOfMeasureFilter>,
};

/** A connection to a list of `UnitsOfMeasure` values. */
export type UnitsOfMeasuresConnection = {
   __typename?: 'UnitsOfMeasuresConnection',
  /** A list of `UnitsOfMeasure` objects. */
  nodes: Array<UnitsOfMeasure>,
  /** A list of edges which contains the `UnitsOfMeasure` and cursor to aid in pagination. */
  edges: Array<UnitsOfMeasuresEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `UnitsOfMeasure` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `UnitsOfMeasure` edge in the connection. */
export type UnitsOfMeasuresEdge = {
   __typename?: 'UnitsOfMeasuresEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `UnitsOfMeasure` at the end of the edge. */
  node: UnitsOfMeasure,
};

/** Methods to use when ordering `UnitsOfMeasure`. */
export enum UnitsOfMeasuresOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  CODE_ASC = 'CODE_ASC',
  CODE_DESC = 'CODE_DESC',
  DISPLAY_ASC = 'DISPLAY_ASC',
  DISPLAY_DESC = 'DISPLAY_DESC',
  ACTIVE_ASC = 'ACTIVE_ASC',
  ACTIVE_DESC = 'ACTIVE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `updateConsumableById` mutation. */
export type UpdateConsumableByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Consumable` being updated. */
  consumablePatch: ConsumablePatch,
  id: Scalars['Int'],
};

/** All input for the `updateConsumableBySourceAndIdentifier` mutation. */
export type UpdateConsumableBySourceAndIdentifierInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Consumable` being updated. */
  consumablePatch: ConsumablePatch,
  source: Scalars['String'],
  identifier: Scalars['String'],
};

/** All input for the `updateConsumable` mutation. */
export type UpdateConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Consumable` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Consumable` being updated. */
  consumablePatch: ConsumablePatch,
};

/** The output of our update `Consumable` mutation. */
export type UpdateConsumablePayload = {
   __typename?: 'UpdateConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Consumable` that was updated by this mutation. */
  consumable?: Maybe<Consumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `ConsumableGroup` that is related to this `Consumable`. */
  consumableGroupByFoodGroup?: Maybe<ConsumableGroup>,
  /** Reads a single `User` that is related to this `Consumable`. */
  userByVerifiedByUserId?: Maybe<User>,
  /** Reads a single `ConsumableSource` that is related to this `Consumable`. */
  consumableSourceByConsumableSourceId?: Maybe<ConsumableSource>,
  /** An edge for our `Consumable`. May be used by Relay 1. */
  consumableEdge?: Maybe<ConsumablesEdge>,
};


/** The output of our update `Consumable` mutation. */
export type UpdateConsumablePayloadconsumableEdgeArgs = {
  orderBy?: Maybe<Array<ConsumablesOrderBy>>
};

/** All input for the `updateMealById` mutation. */
export type UpdateMealByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Meal` being updated. */
  mealPatch: MealPatch,
  id: Scalars['Int'],
};

/** All input for the `updateMealConsumableById` mutation. */
export type UpdateMealConsumableByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `MealConsumable` being updated. */
  mealConsumablePatch: MealConsumablePatch,
  id: Scalars['Int'],
};

/** All input for the `updateMealConsumable` mutation. */
export type UpdateMealConsumableInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `MealConsumable` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `MealConsumable` being updated. */
  mealConsumablePatch: MealConsumablePatch,
};

/** The output of our update `MealConsumable` mutation. */
export type UpdateMealConsumablePayload = {
   __typename?: 'UpdateMealConsumablePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MealConsumable` that was updated by this mutation. */
  mealConsumable?: Maybe<MealConsumable>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Meal` that is related to this `MealConsumable`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Consumable` that is related to this `MealConsumable`. */
  consumableByConsumableId?: Maybe<Consumable>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableIdAndConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** Reads a single `MealConsumableCategory` that is related to this `MealConsumable`. */
  mealConsumableCategoryByMealConsumableCategoryId?: Maybe<MealConsumableCategory>,
  /** Reads a single `ConsumableMeasure` that is related to this `MealConsumable`. */
  consumableMeasureByConsumableMeasureId?: Maybe<ConsumableMeasure>,
  /** An edge for our `MealConsumable`. May be used by Relay 1. */
  mealConsumableEdge?: Maybe<MealConsumablesEdge>,
};


/** The output of our update `MealConsumable` mutation. */
export type UpdateMealConsumablePayloadmealConsumableEdgeArgs = {
  orderBy?: Maybe<Array<MealConsumablesOrderBy>>
};

/** All input for the `updateMeal` mutation. */
export type UpdateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Meal` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Meal` being updated. */
  mealPatch: MealPatch,
};

/** The output of our update `Meal` mutation. */
export type UpdateMealPayload = {
   __typename?: 'UpdateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Meal` that was updated by this mutation. */
  meal?: Maybe<Meal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Meal`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `Meal`. */
  mealByCopyOfMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `Meal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `MenuTemplateMeal` that is related to this `Meal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `Meal`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `Meal`. May be used by Relay 1. */
  mealEdge?: Maybe<MealsEdge>,
};


/** The output of our update `Meal` mutation. */
export type UpdateMealPayloadmealEdgeArgs = {
  orderBy?: Maybe<Array<MealsOrderBy>>
};

/** All input for the `updateMenuById` mutation. */
export type UpdateMenuByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Menu` being updated. */
  menuPatch: MenuPatch,
  id: Scalars['Int'],
};

/** All input for the `updateMenu` mutation. */
export type UpdateMenuInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Menu` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Menu` being updated. */
  menuPatch: MenuPatch,
};

/** The output of our update `Menu` mutation. */
export type UpdateMenuPayload = {
   __typename?: 'UpdateMenuPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Menu` that was updated by this mutation. */
  menu?: Maybe<Menu>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Menu`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Menu` that is related to this `Menu`. */
  menuByParentMenuId?: Maybe<Menu>,
  /** Reads a single `Profile` that is related to this `Menu`. */
  profileByProfileId?: Maybe<Profile>,
  /** An edge for our `Menu`. May be used by Relay 1. */
  menuEdge?: Maybe<MenusEdge>,
};


/** The output of our update `Menu` mutation. */
export type UpdateMenuPayloadmenuEdgeArgs = {
  orderBy?: Maybe<Array<MenusOrderBy>>
};

/** All input for the `updateMenuTemplateMealById` mutation. */
export type UpdateMenuTemplateMealByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `MenuTemplateMeal` being updated. */
  menuTemplateMealPatch: MenuTemplateMealPatch,
  id: Scalars['Int'],
};

/** All input for the `updateMenuTemplateMeal` mutation. */
export type UpdateMenuTemplateMealInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `MenuTemplateMeal` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `MenuTemplateMeal` being updated. */
  menuTemplateMealPatch: MenuTemplateMealPatch,
};

/** The output of our update `MenuTemplateMeal` mutation. */
export type UpdateMenuTemplateMealPayload = {
   __typename?: 'UpdateMenuTemplateMealPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `MenuTemplateMeal` that was updated by this mutation. */
  menuTemplateMeal?: Maybe<MenuTemplateMeal>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Menu` that is related to this `MenuTemplateMeal`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `Mealtime` that is related to this `MenuTemplateMeal`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `User` that is related to this `MenuTemplateMeal`. */
  userByAuthorId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `MenuTemplateMeal`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `MenuTemplateMeal` that is related to this `MenuTemplateMeal`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** An edge for our `MenuTemplateMeal`. May be used by Relay 1. */
  menuTemplateMealEdge?: Maybe<MenuTemplateMealsEdge>,
};


/** The output of our update `MenuTemplateMeal` mutation. */
export type UpdateMenuTemplateMealPayloadmenuTemplateMealEdgeArgs = {
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>
};

/** All input for the `updateNutrientRangeById` mutation. */
export type UpdateNutrientRangeByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `NutrientRange` being updated. */
  nutrientRangePatch: NutrientRangePatch,
  id: Scalars['String'],
};

/** All input for the `updateNutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientId` mutation. */
export type UpdateNutrientRangeBySnomedCidAndAgeLowerMonthsAndAgeUpperMonthsAndNutrientIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `NutrientRange` being updated. */
  nutrientRangePatch: NutrientRangePatch,
  snomedCid: Scalars['String'],
  ageLowerMonths: Scalars['Int'],
  ageUpperMonths: Scalars['Int'],
  nutrientId: Scalars['Int'],
};

/** All input for the `updateNutrientRange` mutation. */
export type UpdateNutrientRangeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `NutrientRange` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `NutrientRange` being updated. */
  nutrientRangePatch: NutrientRangePatch,
};

/** The output of our update `NutrientRange` mutation. */
export type UpdateNutrientRangePayload = {
   __typename?: 'UpdateNutrientRangePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `NutrientRange` that was updated by this mutation. */
  nutrientRange?: Maybe<NutrientRange>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `SnomedProblemList` that is related to this `NutrientRange`. */
  snomedProblemListBySnomedCid?: Maybe<SnomedProblemList>,
  /** Reads a single `Nutrient` that is related to this `NutrientRange`. */
  nutrientByNutrientId?: Maybe<Nutrient>,
  /** An edge for our `NutrientRange`. May be used by Relay 1. */
  nutrientRangeEdge?: Maybe<NutrientRangesEdge>,
};


/** The output of our update `NutrientRange` mutation. */
export type UpdateNutrientRangePayloadnutrientRangeEdgeArgs = {
  orderBy?: Maybe<Array<NutrientRangesOrderBy>>
};

/** All input for the `updateOrganizationById` mutation. */
export type UpdateOrganizationByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Organization` being updated. */
  organizationPatch: OrganizationPatch,
  id: Scalars['Int'],
};

/** All input for the `updateOrganization` mutation. */
export type UpdateOrganizationInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Organization` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Organization` being updated. */
  organizationPatch: OrganizationPatch,
};

/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayload = {
   __typename?: 'UpdateOrganizationPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Organization` that was updated by this mutation. */
  organization?: Maybe<Organization>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>,
};


/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayloadorganizationEdgeArgs = {
  orderBy?: Maybe<Array<OrganizationsOrderBy>>
};

/** All input for the `updateProfileById` mutation. */
export type UpdateProfileByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Profile` being updated. */
  profilePatch: ProfilePatch,
  id: Scalars['Int'],
};

/** All input for the `updateProfileByOpenId` mutation. */
export type UpdateProfileByOpenIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Profile` being updated. */
  profilePatch: ProfilePatch,
  openId: Scalars['String'],
};

/** All input for the `updateProfileDatumByProfileId` mutation. */
export type UpdateProfileDatumByProfileIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `ProfileDatum` being updated. */
  profileDatumPatch: ProfileDatumPatch,
  profileId: Scalars['Int'],
};

/** All input for the `updateProfileDatum` mutation. */
export type UpdateProfileDatumInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `ProfileDatum` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `ProfileDatum` being updated. */
  profileDatumPatch: ProfileDatumPatch,
};

/** The output of our update `ProfileDatum` mutation. */
export type UpdateProfileDatumPayload = {
   __typename?: 'UpdateProfileDatumPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileDatum` that was updated by this mutation. */
  profileDatum?: Maybe<ProfileDatum>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Profile` that is related to this `ProfileDatum`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `Organization` that is related to this `ProfileDatum`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `ProfileDatum`. May be used by Relay 1. */
  profileDatumEdge?: Maybe<ProfileDataEdge>,
};


/** The output of our update `ProfileDatum` mutation. */
export type UpdateProfileDatumPayloadprofileDatumEdgeArgs = {
  orderBy?: Maybe<Array<ProfileDataOrderBy>>
};

/** All input for the `updateProfile` mutation. */
export type UpdateProfileInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Profile` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Profile` being updated. */
  profilePatch: ProfilePatch,
};

/** The output of our update `Profile` mutation. */
export type UpdateProfilePayload = {
   __typename?: 'UpdateProfilePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Profile` that was updated by this mutation. */
  profile?: Maybe<Profile>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `Profile`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Organization` that is related to this `Profile`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>,
};


/** The output of our update `Profile` mutation. */
export type UpdateProfilePayloadprofileEdgeArgs = {
  orderBy?: Maybe<Array<ProfilesOrderBy>>
};

/** All input for the `updateProfileScheduledMealtimeById` mutation. */
export type UpdateProfileScheduledMealtimeByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `ProfileScheduledMealtime` being updated. */
  profileScheduledMealtimePatch: ProfileScheduledMealtimePatch,
  id: Scalars['Int'],
};

/** All input for the `updateProfileScheduledMealtime` mutation. */
export type UpdateProfileScheduledMealtimeInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `ProfileScheduledMealtime` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `ProfileScheduledMealtime` being updated. */
  profileScheduledMealtimePatch: ProfileScheduledMealtimePatch,
};

/** The output of our update `ProfileScheduledMealtime` mutation. */
export type UpdateProfileScheduledMealtimePayload = {
   __typename?: 'UpdateProfileScheduledMealtimePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `ProfileScheduledMealtime` that was updated by this mutation. */
  profileScheduledMealtime?: Maybe<ProfileScheduledMealtime>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `Profile` that is related to this `ProfileScheduledMealtime`. */
  profileByProfileId?: Maybe<Profile>,
  /** Reads a single `MenuTemplateMeal` that is related to this `ProfileScheduledMealtime`. */
  menuTemplateMealByMenuTemplateMealId?: Maybe<MenuTemplateMeal>,
  /** Reads a single `Organization` that is related to this `ProfileScheduledMealtime`. */
  organizationByOrganizationId?: Maybe<Organization>,
  /** Reads a single `User` that is related to this `ProfileScheduledMealtime`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByMealId?: Maybe<Meal>,
  /** Reads a single `Meal` that is related to this `ProfileScheduledMealtime`. */
  mealByOriginalMealId?: Maybe<Meal>,
  /** Reads a single `Mealtime` that is related to this `ProfileScheduledMealtime`. */
  mealtimeByMealtimeId?: Maybe<Mealtime>,
  /** Reads a single `Menu` that is related to this `ProfileScheduledMealtime`. */
  menuByMenuId?: Maybe<Menu>,
  /** Reads a single `ProfileScheduledMealtime` that is related to this `ProfileScheduledMealtime`. */
  profileScheduledMealtimeByProfileScheduledMealtimeId?: Maybe<ProfileScheduledMealtime>,
  /** An edge for our `ProfileScheduledMealtime`. May be used by Relay 1. */
  profileScheduledMealtimeEdge?: Maybe<ProfileScheduledMealtimesEdge>,
};


/** The output of our update `ProfileScheduledMealtime` mutation. */
export type UpdateProfileScheduledMealtimePayloadprofileScheduledMealtimeEdgeArgs = {
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>
};

/** All input for the `updateTagById` mutation. */
export type UpdateTagByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch,
  id: Scalars['Int'],
};

/** All input for the `updateTag` mutation. */
export type UpdateTagInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch,
};

/** The output of our update `Tag` mutation. */
export type UpdateTagPayload = {
   __typename?: 'UpdateTagPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `Tag` that was updated by this mutation. */
  tag?: Maybe<Tag>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>,
};


/** The output of our update `Tag` mutation. */
export type UpdateTagPayloadtagEdgeArgs = {
  orderBy?: Maybe<Array<TagsOrderBy>>
};

/** All input for the `updateUserById` mutation. */
export type UpdateUserByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch,
  id: Scalars['Int'],
};

/** All input for the `updateUserDatumByUserId` mutation. */
export type UpdateUserDatumByUserIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `UserDatum` being updated. */
  userDatumPatch: UserDatumPatch,
  userId: Scalars['Int'],
};

/** All input for the `updateUserDatum` mutation. */
export type UpdateUserDatumInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `UserDatum` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `UserDatum` being updated. */
  userDatumPatch: UserDatumPatch,
};

/** The output of our update `UserDatum` mutation. */
export type UpdateUserDatumPayload = {
   __typename?: 'UpdateUserDatumPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserDatum` that was updated by this mutation. */
  userDatum?: Maybe<UserDatum>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `UserDatum`. */
  userByUserId?: Maybe<User>,
  /** An edge for our `UserDatum`. May be used by Relay 1. */
  userDatumEdge?: Maybe<UserDataEdge>,
};


/** The output of our update `UserDatum` mutation. */
export type UpdateUserDatumPayloaduserDatumEdgeArgs = {
  orderBy?: Maybe<Array<UserDataOrderBy>>
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch,
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
   __typename?: 'UpdateUserPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>,
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloaduserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>
};

/** All input for the `updateUserRoleById` mutation. */
export type UpdateUserRoleByIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  userRolePatch: UserRolePatch,
  id: Scalars['Int'],
};

/** All input for the `updateUserRoleByUserIdAndRoleId` mutation. */
export type UpdateUserRoleByUserIdAndRoleIdInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  userRolePatch: UserRolePatch,
  userId: Scalars['Int'],
  roleId: Scalars['Int'],
};

/** All input for the `updateUserRole` mutation. */
export type UpdateUserRoleInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The globally unique `ID` which will identify a single `UserRole` to be updated. */
  nodeId: Scalars['ID'],
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  userRolePatch: UserRolePatch,
};

/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayload = {
   __typename?: 'UpdateUserRolePayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The `UserRole` that was updated by this mutation. */
  userRole?: Maybe<UserRole>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `UserRole`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Role` that is related to this `UserRole`. */
  roleByRoleId?: Maybe<Role>,
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>,
};


/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayloaduserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>
};

export type User = Node & {
   __typename?: 'User',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  lastLoggedInAt?: Maybe<Scalars['Datetime']>,
  name?: Maybe<Scalars['String']>,
  username?: Maybe<Scalars['String']>,
  avatarUrl?: Maybe<Scalars['String']>,
  bio?: Maybe<Scalars['String']>,
  credentials?: Maybe<Scalars['String']>,
  createdAt: Scalars['Datetime'],
  updatedAt: Scalars['Datetime'],
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  organizationUsersByUserId: OrganizationUsersConnection,
  /** Reads and enables pagination through a set of `Profile`. */
  profilesByUserId: ProfilesConnection,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  profileOrganizationsByProfileUserId: ProfileOrganizationsConnection,
  /** Reads and enables pagination through a set of `ProfileOrganization`. */
  profileOrganizationsByGrantedByUserId: ProfileOrganizationsConnection,
  /** Reads and enables pagination through a set of `UserRole`. */
  userRolesByUserId: UserRolesConnection,
  /** Reads a single `UserDatum` that is related to this `User`. */
  userDatumByUserId?: Maybe<UserDatum>,
  /** Reads and enables pagination through a set of `UserDatum`. */
  userDataByUserId: UserDataConnection,
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmailsByUserId: UserEmailsConnection,
  /** Reads and enables pagination through a set of `Consumable`. */
  consumablesByUserId: ConsumablesConnection,
  /** Reads and enables pagination through a set of `Consumable`. */
  consumablesByVerifiedByUserId: ConsumablesConnection,
  /** Reads and enables pagination through a set of `Menu`. */
  menusByAuthorId: MenusConnection,
  /** Reads and enables pagination through a set of `Meal`. */
  mealsByUserId: MealsConnection,
  /** Reads and enables pagination through a set of `MenuTemplateMeal`. */
  menuTemplateMealsByAuthorId: MenuTemplateMealsConnection,
  /** Reads and enables pagination through a set of `ProfileScheduledMealtime`. */
  profileScheduledMealtimesByUserId: ProfileScheduledMealtimesConnection,
  isAdmin?: Maybe<Scalars['Boolean']>,
  /** Returns null on all but the logged in user. Determines if the user has verified one of their email addresses. */
  isVerified?: Maybe<Scalars['Boolean']>,
  /** Returns null on all but the logged in user. Determines the user's practitioner application status. */
  practitionerStatus?: Maybe<PractitionerStatus>,
};


export type UserorganizationUsersByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<OrganizationUsersOrderBy>>,
  condition?: Maybe<OrganizationUserCondition>,
  filter?: Maybe<OrganizationUserFilter>
};


export type UserprofilesByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfilesOrderBy>>,
  condition?: Maybe<ProfileCondition>,
  filter?: Maybe<ProfileFilter>
};


export type UserprofileOrganizationsByProfileUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


export type UserprofileOrganizationsByGrantedByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileOrganizationsOrderBy>>,
  condition?: Maybe<ProfileOrganizationCondition>,
  filter?: Maybe<ProfileOrganizationFilter>
};


export type UseruserRolesByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserRolesOrderBy>>,
  condition?: Maybe<UserRoleCondition>,
  filter?: Maybe<UserRoleFilter>
};


export type UseruserDataByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserDataOrderBy>>,
  condition?: Maybe<UserDatumCondition>,
  filter?: Maybe<UserDatumFilter>
};


export type UseruserEmailsByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<UserEmailsOrderBy>>,
  condition?: Maybe<UserEmailCondition>,
  filter?: Maybe<UserEmailFilter>
};


export type UserconsumablesByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumablesOrderBy>>,
  condition?: Maybe<ConsumableCondition>,
  filter?: Maybe<ConsumableFilter>
};


export type UserconsumablesByVerifiedByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ConsumablesOrderBy>>,
  condition?: Maybe<ConsumableCondition>,
  filter?: Maybe<ConsumableFilter>
};


export type UsermenusByAuthorIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenusOrderBy>>,
  condition?: Maybe<MenuCondition>,
  filter?: Maybe<MenuFilter>
};


export type UsermealsByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MealsOrderBy>>,
  condition?: Maybe<MealCondition>,
  filter?: Maybe<MealFilter>
};


export type UsermenuTemplateMealsByAuthorIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<MenuTemplateMealsOrderBy>>,
  condition?: Maybe<MenuTemplateMealCondition>,
  filter?: Maybe<MenuTemplateMealFilter>
};


export type UserprofileScheduledMealtimesByUserIdArgs = {
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  offset?: Maybe<Scalars['Int']>,
  before?: Maybe<Scalars['Cursor']>,
  after?: Maybe<Scalars['Cursor']>,
  orderBy?: Maybe<Array<ProfileScheduledMealtimesOrderBy>>,
  condition?: Maybe<ProfileScheduledMealtimeCondition>,
  filter?: Maybe<ProfileScheduledMealtimeFilter>
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `lastLoggedInAt` field. */
  lastLoggedInAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `avatarUrl` field. */
  avatarUrl?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `bio` field. */
  bio?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `credentials` field. */
  credentials?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>,
};

/** A connection to a list of `UserDatum` values. */
export type UserDataConnection = {
   __typename?: 'UserDataConnection',
  /** A list of `UserDatum` objects. */
  nodes: Array<UserDatum>,
  /** A list of edges which contains the `UserDatum` and cursor to aid in pagination. */
  edges: Array<UserDataEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `UserDatum` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `UserDatum` edge in the connection. */
export type UserDataEdge = {
   __typename?: 'UserDataEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `UserDatum` at the end of the edge. */
  node: UserDatum,
};

/** Methods to use when ordering `UserDatum`. */
export enum UserDataOrderBy {
  NATURAL = 'NATURAL',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  ADDRESS_LINE_ASC = 'ADDRESS_LINE_ASC',
  ADDRESS_LINE_DESC = 'ADDRESS_LINE_DESC',
  CITY_ASC = 'CITY_ASC',
  CITY_DESC = 'CITY_DESC',
  DISTRICT_ASC = 'DISTRICT_ASC',
  DISTRICT_DESC = 'DISTRICT_DESC',
  POSTAL_CODE_ASC = 'POSTAL_CODE_ASC',
  POSTAL_CODE_DESC = 'POSTAL_CODE_DESC',
  COUNTRY_ASC = 'COUNTRY_ASC',
  COUNTRY_DESC = 'COUNTRY_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type UserDatum = Node & {
   __typename?: 'UserDatum',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  userId: Scalars['Int'],
  addressLine?: Maybe<Scalars['String']>,
  city?: Maybe<Scalars['String']>,
  district?: Maybe<Scalars['String']>,
  postalCode?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
  /** Reads a single `User` that is related to this `UserDatum`. */
  userByUserId?: Maybe<User>,
};

/** 
 * A condition to be used against `UserDatum` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserDatumCondition = {
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `addressLine` field. */
  addressLine?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `district` field. */
  district?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `postalCode` field. */
  postalCode?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `country` field. */
  country?: Maybe<Scalars['String']>,
};

/** A filter to be used against `UserDatum` object types. All fields are combined with a logical ‘and.’ */
export type UserDatumFilter = {
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `addressLine` field. */
  addressLine?: Maybe<StringFilter>,
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>,
  /** Filter by the object’s `district` field. */
  district?: Maybe<StringFilter>,
  /** Filter by the object’s `postalCode` field. */
  postalCode?: Maybe<StringFilter>,
  /** Filter by the object’s `country` field. */
  country?: Maybe<StringFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserDatumFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserDatumFilter>>,
  /** Negates the expression. */
  not?: Maybe<UserDatumFilter>,
};

/** An input for mutations affecting `UserDatum` */
export type UserDatumInput = {
  addressLine?: Maybe<Scalars['String']>,
  city?: Maybe<Scalars['String']>,
  district?: Maybe<Scalars['String']>,
  postalCode?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
};

/** Represents an update to a `UserDatum`. Fields that are set will be updated. */
export type UserDatumPatch = {
  addressLine?: Maybe<Scalars['String']>,
  city?: Maybe<Scalars['String']>,
  district?: Maybe<Scalars['String']>,
  postalCode?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
};

export type UserEmail = Node & {
   __typename?: 'UserEmail',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  userId: Scalars['Int'],
  email: Scalars['String'],
  verified: Scalars['Boolean'],
  primary: Scalars['Boolean'],
  /** Reads a single `User` that is related to this `UserEmail`. */
  userByUserId?: Maybe<User>,
};

/** 
 * A condition to be used against `UserEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserEmailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>,
  /** Checks for equality with the object’s `verified` field. */
  verified?: Maybe<Scalars['Boolean']>,
  /** Checks for equality with the object’s `primary` field. */
  primary?: Maybe<Scalars['Boolean']>,
};

/** A filter to be used against `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserEmailFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>,
  /** Filter by the object’s `verified` field. */
  verified?: Maybe<BooleanFilter>,
  /** Filter by the object’s `primary` field. */
  primary?: Maybe<BooleanFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserEmailFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserEmailFilter>>,
  /** Negates the expression. */
  not?: Maybe<UserEmailFilter>,
};

/** A connection to a list of `UserEmail` values. */
export type UserEmailsConnection = {
   __typename?: 'UserEmailsConnection',
  /** A list of `UserEmail` objects. */
  nodes: Array<UserEmail>,
  /** A list of edges which contains the `UserEmail` and cursor to aid in pagination. */
  edges: Array<UserEmailsEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `UserEmail` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `UserEmail` edge in the connection. */
export type UserEmailsEdge = {
   __typename?: 'UserEmailsEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `UserEmail` at the end of the edge. */
  node: UserEmail,
};

/** Methods to use when ordering `UserEmail`. */
export enum UserEmailsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  EMAIL_ASC = 'EMAIL_ASC',
  EMAIL_DESC = 'EMAIL_DESC',
  VERIFIED_ASC = 'VERIFIED_ASC',
  VERIFIED_DESC = 'VERIFIED_DESC',
  PRIMARY_ASC = 'PRIMARY_ASC',
  PRIMARY_DESC = 'PRIMARY_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `lastLoggedInAt` field. */
  lastLoggedInAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>,
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>,
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: Maybe<StringFilter>,
  /** Filter by the object’s `bio` field. */
  bio?: Maybe<StringFilter>,
  /** Filter by the object’s `credentials` field. */
  credentials?: Maybe<StringFilter>,
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>,
  /** Negates the expression. */
  not?: Maybe<UserFilter>,
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  name?: Maybe<Scalars['String']>,
  username?: Maybe<Scalars['String']>,
  avatarUrl?: Maybe<Scalars['String']>,
  bio?: Maybe<Scalars['String']>,
  credentials?: Maybe<Scalars['String']>,
};

export type UserRole = Node & {
   __typename?: 'UserRole',
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'],
  id: Scalars['Int'],
  userId: Scalars['Int'],
  roleId: Scalars['Int'],
  requestedAt: Scalars['Datetime'],
  grantedAt?: Maybe<Scalars['Datetime']>,
  revokedAt?: Maybe<Scalars['Datetime']>,
  /** Reads a single `User` that is related to this `UserRole`. */
  userByUserId?: Maybe<User>,
  /** Reads a single `Role` that is related to this `UserRole`. */
  roleByRoleId?: Maybe<Role>,
};

/** 
 * A condition to be used against `UserRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserRoleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: Maybe<Scalars['Int']>,
  /** Checks for equality with the object’s `requestedAt` field. */
  requestedAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `grantedAt` field. */
  grantedAt?: Maybe<Scalars['Datetime']>,
  /** Checks for equality with the object’s `revokedAt` field. */
  revokedAt?: Maybe<Scalars['Datetime']>,
};

/** A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’ */
export type UserRoleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>,
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>,
  /** Filter by the object’s `roleId` field. */
  roleId?: Maybe<IntFilter>,
  /** Filter by the object’s `requestedAt` field. */
  requestedAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `grantedAt` field. */
  grantedAt?: Maybe<DatetimeFilter>,
  /** Filter by the object’s `revokedAt` field. */
  revokedAt?: Maybe<DatetimeFilter>,
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserRoleFilter>>,
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserRoleFilter>>,
  /** Negates the expression. */
  not?: Maybe<UserRoleFilter>,
};

/** An input for mutations affecting `UserRole` */
export type UserRoleInput = {
  userId?: Maybe<Scalars['Int']>,
  roleId: Scalars['Int'],
  grantedAt?: Maybe<Scalars['Datetime']>,
  revokedAt?: Maybe<Scalars['Datetime']>,
};

/** Represents an update to a `UserRole`. Fields that are set will be updated. */
export type UserRolePatch = {
  grantedAt?: Maybe<Scalars['Datetime']>,
  revokedAt?: Maybe<Scalars['Datetime']>,
};

/** A connection to a list of `UserRole` values. */
export type UserRolesConnection = {
   __typename?: 'UserRolesConnection',
  /** A list of `UserRole` objects. */
  nodes: Array<UserRole>,
  /** A list of edges which contains the `UserRole` and cursor to aid in pagination. */
  edges: Array<UserRolesEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `UserRole` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `UserRole` edge in the connection. */
export type UserRolesEdge = {
   __typename?: 'UserRolesEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `UserRole` at the end of the edge. */
  node: UserRole,
};

/** Methods to use when ordering `UserRole`. */
export enum UserRolesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  USER_ID_ASC = 'USER_ID_ASC',
  USER_ID_DESC = 'USER_ID_DESC',
  ROLE_ID_ASC = 'ROLE_ID_ASC',
  ROLE_ID_DESC = 'ROLE_ID_DESC',
  REQUESTED_AT_ASC = 'REQUESTED_AT_ASC',
  REQUESTED_AT_DESC = 'REQUESTED_AT_DESC',
  GRANTED_AT_ASC = 'GRANTED_AT_ASC',
  GRANTED_AT_DESC = 'GRANTED_AT_DESC',
  REVOKED_AT_ASC = 'REVOKED_AT_ASC',
  REVOKED_AT_DESC = 'REVOKED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `User` values. */
export type UsersConnection = {
   __typename?: 'UsersConnection',
  /** A list of `User` objects. */
  nodes: Array<User>,
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>,
  /** Information to aid in pagination. */
  pageInfo: PageInfo,
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'],
};

/** A `User` edge in the connection. */
export type UsersEdge = {
   __typename?: 'UsersEdge',
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>,
  /** The `User` at the end of the edge. */
  node: User,
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LAST_LOGGED_IN_AT_ASC = 'LAST_LOGGED_IN_AT_ASC',
  LAST_LOGGED_IN_AT_DESC = 'LAST_LOGGED_IN_AT_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  USERNAME_ASC = 'USERNAME_ASC',
  USERNAME_DESC = 'USERNAME_DESC',
  AVATAR_URL_ASC = 'AVATAR_URL_ASC',
  AVATAR_URL_DESC = 'AVATAR_URL_DESC',
  BIO_ASC = 'BIO_ASC',
  BIO_DESC = 'BIO_DESC',
  CREDENTIALS_ASC = 'CREDENTIALS_ASC',
  CREDENTIALS_DESC = 'CREDENTIALS_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  UPDATED_AT_ASC = 'UPDATED_AT_ASC',
  UPDATED_AT_DESC = 'UPDATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /** 
 * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  code?: Maybe<Scalars['String']>,
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
   __typename?: 'VerifyEmailPayload',
  /** 
 * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
 */
  clientMutationId?: Maybe<Scalars['String']>,
  userEmail?: Maybe<UserEmail>,
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>,
  /** Reads a single `User` that is related to this `UserEmail`. */
  userByUserId?: Maybe<User>,
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge?: Maybe<UserEmailsEdge>,
};


/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayloaduserEmailEdgeArgs = {
  orderBy?: Maybe<Array<UserEmailsOrderBy>>
};

export type CurrentUserQueryVariables = {};


export type CurrentUserQuery = (
  { __typename?: 'Query' }
  & { currentUser: Maybe<(
    { __typename?: 'User' }
    & Pick<User, 'nodeId' | 'id'>
    & CurrentUser_UserFragment
  )> }
);

export type CurrentUser_UserFragment = (
  { __typename?: 'User' }
  & Pick<User, 'nodeId' | 'id' | 'name' | 'bio' | 'isAdmin' | 'isVerified' | 'credentials' | 'username' | 'avatarUrl' | 'practitionerStatus' | 'createdAt' | 'updatedAt'>
  & { organizationUsersByUserId: (
    { __typename?: 'OrganizationUsersConnection' }
    & { nodes: Array<(
      { __typename?: 'OrganizationUser' }
      & Pick<OrganizationUser, 'nodeId' | 'id' | 'organizationId'>
    )> }
  ) }
);

export const CurrentUser_UserFragmentDoc = gql`
    fragment CurrentUser_User on User {
  nodeId
  id
  name
  bio
  isAdmin
  isVerified
  credentials
  username
  avatarUrl
  practitionerStatus
  createdAt
  updatedAt
  organizationUsersByUserId(first: 20) {
    nodes {
      nodeId
      id
      organizationId
    }
  }
}
    `;
export const CurrentUserDocument = gql`
    query CurrentUser {
  currentUser {
    nodeId
    id
    ...CurrentUser_User
  }
}
    ${CurrentUser_UserFragmentDoc}`;

/**
 * __useCurrentUserQuery__
 *
 * To run a query within a React component, call `useCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties 
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrentUserQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
        return ApolloReactHooks.useQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, baseOptions);
      }
export function useCurrentUserLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, baseOptions);
        }
export type CurrentUserQueryHookResult = ReturnType<typeof useCurrentUserQuery>;
export type CurrentUserLazyQueryHookResult = ReturnType<typeof useCurrentUserLazyQuery>;
export type CurrentUserQueryResult = ApolloReactCommon.QueryResult<CurrentUserQuery, CurrentUserQueryVariables>;